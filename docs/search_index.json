[
["index.html", "ENC2055: Introduction to Programming Languages for Linguistic Analysis Preface Course Objective Textbook Course Website Course Demo Data", " ENC2055: Introduction to Programming Languages for Linguistic Analysis Alvin Chen 2019-12-11 Preface Welcome to ENC2055. This is a grad-level course tailored to those who are interested in computational text analytics and data science in general. Have you decided to embark upon a digital journey to your future career, there are a series of courses provided in the Department of English, NTNU, Taiwan, offerring necessary skills and knowledge in important disciplines. This introductory course in basic computational coding would be a prerequisite course for many other advance-level courses. Also, our Linguistics group is dedicated to linguistics in particular. Course Objective The objective of this course is to provide a comprehensive introduction to programming languages with a special focus on its application in linguistic analyses. This course is especially tailored to those who do not have any background or experiences in coding. We will start from the very basic concepts, such as data types, variable assignments, control structures, to more complex procedures such as routines, functions, and project-based tasks. The course will consist of a series of theme-based hands-on tutorials, which demonstrate how the flexibility of the programming language can help you become a more efficient and productive data scientist. Specifically, this course will use the language R as our featuring programming language and introduce you to R, Rstudio, and a collection of R packages designed to work together to make linguistic analyses fast, fluent, and fun.By the end of the course, students should have a working knowledge of coding and an ability to read another programmer’s code. In this course, we will not be dealing with complex maths like: \\[ f(x)=\\frac{1}{\\sqrt{2 \\pi}} e^{-\\frac{1}{2} x^{2}} \\] \\[ P(A) = \\sum P(\\{ (e_1,\\dotsc,e_N) \\}) = \\binom{N}{k} \\cdot p^kq^{N-k} \\] Intead, we will have more experiences with coding: library(tidyverse) summary_monthly_temp &lt;- weather %&gt;% group_by(month) %&gt;% summarize(mean = mean(temp), std_dev = sd(temp)) Textbook We will not use a particular textbook for the course. However, I do like to recommend Wickham and Grolemund (2017) for its simplicity. Also, another great book for R lovers, by Davies (2016): Course Website We have a course website. You may need a password to get access to the course materials. If you are an officially enrolled student, please ask the instructor for the access code. Course Demo Data Dropbox Demo Data Directory References "],
["intro-ds.html", "Chapter 1 Data Science and R 1.1 What is Data Science? 1.2 Working Pipeline for Data Science 1.3 Why R? 1.4 tidyverse 1.5 More Skills", " Chapter 1 Data Science and R 1.1 What is Data Science? Data Science is an interdisciplinary subject, which integrates knowledge of statistics, computer science and other domina-specific areas. A graph by Drew Conway may summarize the essense of Data Science: 1.2 Working Pipeline for Data Science Hadley Wickham’s R for Data Science describes six important steps for data analysis: 1.3 Why R? According to a report by KDnuggets, among all the languages used by data scientists, python and R are the most popular two languages: It is true that Python now seems much more popular among developers. That being said, you may consult this article, &lt;&lt; Why R is the Best Data Science Language to Learn Today? &gt;&gt;, for a more comprehensive review of the strengths of R. The general tendency is that: if you want to go into the industry and take developers or programmers as your future career, you can choose python; if you are going to locate yourself in the academia, I would definitely recommend R. Here are a list of strengths for R language: powerful statistical analysis data visualization exploratory analysis re-usable reports tidyverse consistent grammar/syntax high readability of the codes, similar to human languages ( %&gt;% is a unique R feature!) In this course, our main objective is to introduce you to the world of coding. A high-level programming language like R would be a very friendly start, especially for those who have no background of computing. So, let us enjoy the journey of a simple yet powerful language learning! 1.4 tidyverse In this course, we will be working on a collection of packages included in tidyverse. This is a unique package in R, which can help you deal with data in a massively convenient way. It is hoped that the user can easily call particular functions and make use of the pipe operator %&gt;% to concatenate all your procedures serially, just like our natural languages. In particular, we will work on the following major libraries included in tidyverse: ggplot2: Data visualization dplyr: Data wrangling tidyr: Data wrangling stringr: String manipulation readr: Data importing purrr: Functional programming to avoid loops tibble: Powerful data structure 1.5 More Skills Data scientists are now becoming more and more popular. To know more about this job, one thing you may want to know is what kinds of skills are needed? The following two graphs were taken from &lt;The Most in Demand Skills for Data Scientists&gt;: While people still have various definitions regarding what data science encompasses, there are indeed several practical fields that have been commonly regarded as part of the definitions of Data Science. According to Mason and Wiggins (2010) A Taxonomy of Data Science, data science can be defined according to five crucial steps: Obtain: pointing and clicking does not scale. Scrub: the world is a messy place Explore: You can see a lot by looking Models: always bad, sometimes ugly iNterpret: “The purpose of computing is insight, not numbers.” This OSEMN (awesome!!) model should give you a much clearer picture of what you need to become a proficient data scientist. What we do here in this course is just a start….Take a deep breath:) "],
["r-fundamentals.html", "Chapter 2 R Fundamentals 2.1 Installing R 2.2 Installing RStudio 2.3 The Interface of Rstudio 2.4 Assignment 2.5 Data Structure 2.6 Function 2.7 Script 2.8 Library 2.9 Setting 2.10 Seeking Help 2.11 Language Learning Ain’t Easy! 2.12 Keyboard Shortcuts", " Chapter 2 R Fundamentals Download R: R-Project IDE: RStudio Tutorials: Online Learning 2.1 Installing R Download the install file: http://cran.r-project.org 2.2 Installing RStudio After you install R, you may install RStudio. RStudio is an editor which can help you write R codes. A good analogy is that R is the engine and Rstudio is the dashboard of the car. Please download the right version that is compatible with your PC operating system. https://www.rstudio.com/download Choose RStudio Desktop Important notes: Do not have Chinese characters in your directory names or on the path to the files Do not have spaces and weird symbols in your file path: D:/R D:/Rstudio /User/Alvinchen/ 2.3 The Interface of Rstudio When you start Rstudio, you will see an interface as follows: Rstudio Interface: Editor: You creat and edit our R-related files here (e.g., *.r, *.Rmd etc.) Console: This is the R engine, which runs the codes we send out either from the file or directly from the console input Output: You can view graphic outputs here The R console is like a calculator. You can type any R code in the console after the prompt &gt; and run the code line by line by pressing enter. All the above examples ask R to run lines of codes and print the results directly in the console. 1 + 1 ## [1] 2 log(10) ## [1] 2.302585 1:5 ## [1] 1 2 3 4 5 2.4 Assignment You can assign any object created in R to a variable using &lt;-: x &lt;- 5 y &lt;- &quot;wonderful&quot; Now the objects are stored in the variables. You can print out the varialbes by either making use of the auto-printing (i.e., the variable itself auto-prints its content) or print(): x ## [1] 5 print(x) ## [1] 5 y ## [1] &quot;wonderful&quot; print(y) ## [1] &quot;wonderful&quot; 2.5 Data Structure In R, the most primitive object is a vector. There are two types of primitive vectors: (a) numeric and (b) character vectors. In our previous examples, x is a numeric vector of one element; y is a character vector of one element. All elements in the factor have to be of the same data type. You use c() to create a vector of multiple elments. Within the parenthesis, you concatenate each element of the vector by ,: x2 &lt;- c(1, 2, 3, 4, 5, 6) x2 ## [1] 1 2 3 4 5 6 y2 &lt;- c(&quot;wonderful&quot;, &quot;excellent&quot;, &quot;brilliant&quot;) y2 ## [1] &quot;wonderful&quot; &quot;excellent&quot; &quot;brilliant&quot; Data structures that you often work with include: List: Data Frame: Matrix ex_list &lt;- list(&quot;First element&quot;, 5:10, TRUE) print(ex_list) ## [[1]] ## [1] &quot;First element&quot; ## ## [[2]] ## [1] 5 6 7 8 9 10 ## ## [[3]] ## [1] TRUE ex_array &lt;- matrix(c(1,5,6,3,8,19),byrow = T, nrow = 2) ex_array ## [,1] [,2] [,3] ## [1,] 1 5 6 ## [2,] 3 8 19 ex_df &lt;- data.frame( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34) ) ex_df 2.6 Function 2.7 Script Earlier you run R codes by entering each procedure line by line. You can also include all our R codes in one script file, which usually has the file extension of .R. And then you can run the whole script all at once in the Rstudio. First you open the *.R script file in Rstudio, which should appear in the Editor frame of the Rstudio. To run the whole script from start to the end, select all lines in the script file and press ctrl/cmd + shift + enter. To run a particular line of the script, put your mouse in the line and press ctrl/cmd + enter. 2.8 Library R, like other programming languages, comes with a huge database of packages and extensions, allowing us to do many different tasks without worrying about writing the codes all from the scratch. In CRAN Task Views, you can find relevant packages relevant to a specific topic or task. To install a package (i.e., library): install.packages(&quot;tidyverse&quot;) install.packages(c(&quot;ggplot2&quot;, &quot;devtools&quot;, &quot;dplyr&quot;)) 2.9 Setting Always set your default encoding of the files to UTF-8: 2.10 Seeking Help In the process of (learning) programming, one thing you will never be able to dodge is a strong desire for help. Here are the sources you may seek help. Within Rstudio, in the R console, you can always use ? to check the documentation of a particular function. When you run the command, you will see the documentation popping up in the output frame of the Rstudio. ?log ?read.table Figure 2.1: Help 1 If you need help from others, the first step is to create a reproducible example. The goal of a reproducible example is to package your problematic code in such a way that other people can run it and feel your pain. Then, hopefully, they can provide a solution and put you out of your misery. Figure 2.2: Help 2 So before you seek help from others (or before you yell at others for help, cf. Figure 2.2) : First, you need to make your code reproducible. This means that you need to capture everything, i.e., include any library() calls and create all necessary objects (e.g., files). The easiest way is to check the objects listed in the Environment tab of the Rstudio and identify objects that are relevant to your problematic code chunk. Second, you need to make it minimal. Strip away everything that is not directly related to your problem. This usually involves creating a much smaller and simpler R object than the one you’re facing in real life or even using built-in data. That sounds like a lot of work! And it can be, but it has a great payoff: 80% of the time creating an excellent reprex reveals the source of your problem. It’s amazing how often the process of writing up a self-contained and minimal example allows you to answer your own question. The other 20% of time you will have captured the essence of your problem in a way that is easy for others to play with. This substantially improves your chances of getting help! The following is a list of resources where people usually get external assistance quickly: http://www.r-project.org/mail.html http://stackoverflow.com/ Quick R: http://www.statmethods.net/ R CRAN Task Views: https://cran.r-project.org/web/views/ R for Data Science Text Mining with R R communities: R-Bloggers: https://www.r-bloggers.com/ kaggle: https://www.kaggle.com/ stackoverflow: https://stackoverflow.com/questions/tagged/r rstudio: https://community.rstudio.com/ 2.11 Language Learning Ain’t Easy! Learning R is like learning another foreign language. It should be a long journey. You can’t expect yourself to learn all the vocabuary of the new language in one day. Also, you will forget things you learn all the time. Everyone’s been there. When your script does not work as expected, don’t be frustrated. Take a break and resume later. What I can say is that: it is always NORMAL to debug a script for hours or even days via endless searches on Google. That being said, here I would like to share with you some of the most common problems R may usually run int: You created an R script file (*.r) and opened it in the Rstudio, but the script didn’t work simply because you didn’t execute the script in R console (i.e., you didn’t send the script to R console.) If you get an error message, saying &quot;object not found&quot;, check the object name again and see if you have mistyped the name of the object. If not, check your current environment and see if you have fotgot to execute some assignment commands in the previous parts of the script (i.e., the object has NOT even been created yet). If you get an error message, saying &quot;function not found&quot;, check the function and see if you have the correct name. Or more ofte, check if you have **loaded&quot; the necessary libraries where the function is defined. To understand the meaning of the error messages is crucial to your development of R proficiency. To achieve this, you have to know very well every object name you have created in your script (as well as your environment). For example: What type of object is it? (i.e., the class of the object, e.g., vector, list, data.frame?) For primitive vectors, what type of vector is it? (e.g., numeric, character, boolean,factor?) What is the dimensionality of the object? (nrows, ncols?) Sometimes the script fails due to the syntactic errors. Pay attention to all the punctuations in every R command. They are far more important (or lethal) than you think. They include: ,: commas between arguments inside a function &quot;: quotes for strings/characters (): parentheses for functions {}: curly brackets for control structures From my experiences, about 80 percent of the errors may in the end boil down to a simple typo. No kidding. Copy-and-paste helps. DO NOT assume that your R script always works as intended! Always keep two questions in mind: Did R produce the intended result? What is included in the R object? 2.12 Keyboard Shortcuts The best way to talk to a computer is via the keyboard. Scripting requires a lot of typing. Keyboard shortcuts may save you a lot of time. Here are some of the handy shortcuts: Crtl/Command + Enter: run the current line (send from the script to the console) Crtl/Command + A: select all Crtl/Command + C: copy Ctrl/Command + X: cut Ctrl/Command + V: paste Ctrl/Command + Z: undo (Mac) Alt/Option + Left/Right: move cursor by a word (Windows) Ctrl + Left/Right: move cursor by a word (Mac) Command + Left/Right: move cursor to the beginning/end of line (Windows) Home/End: move cursor to the beginning/end of line (Mac) Command + Tab: switch in-between different working windows/apps Ctrl/Command + S: save file Command + Shift + C: comment/uncomment selected lines "],
["code-format-convetion.html", "Chapter 3 Code Format Convention 3.1 Assignment &lt;- 3.2 Comment # 3.3 Script Naming 3.4 Object Naming 3.5 Whitespace 3.6 Indention and Linebreaks 3.7 More References", " Chapter 3 Code Format Convention Like your first time of learning English writing, you need to know the conventional writing styles and formats in coding as well. This is very important because scripts of good formats would increase their readability. This would save you a lot of time in case of future debugging and maintenace. This chapter will discuss common practices among most R users. 3.1 Assignment &lt;- In R, people normally use &lt;- to assign values to object names. In other languages such as Python, people often use =. While R usually would still understand the value-assignment when you use =, I would still suggest to use &lt;- just to avoid the chance of confusing your R. x1 &lt;- &quot;This is a sentence.&quot; x2 = &quot;This is a sentence.&quot; x1 ## [1] &quot;This is a sentence.&quot; x2 ## [1] &quot;This is a sentence.&quot; 3.2 Comment # When you write codes, you would need to commit your code extensively. This is very important because we often forget why and how we write it this way. In your R script, any strings after the # will be treated as comments, which will NOT be processed by R. We can often add additional - and = after the # to separate different code chunks. # ==================== # Variable Assignment # ==================== x &lt;- &quot;This is a sentence&quot; # ==================== # Variable Printing # ==================== x ## [1] &quot;This is a sentence&quot; 3.3 Script Naming When you name your R script files, don’t be TOO creative. Use meaningul strings. Most importantly, use alphanumeric characters ONLY. Never use Chinese characters. For multiword names, it is suggested to connect words with -. # Recommended my-first-script.R my-first-assignment.R # NOT Recommended my first script.R 語料庫assingment1.R 3.4 Object Naming In your script, you will create lots of objects. Spend some time thinking about how to name all these objects. Choose names that are intuitive and meaningful. It is often the case that you want to keep the names simple (as typing is really annoying) but easy to understand as well. There are some principles: Use nouns for the object names Use verbs for the function names (e.g., generate_ngrams()) Connect multiword names with _ (e.g., NTNU_corpus) Avoid using characters/strings that have been used by R (e.g., c, mean, sum, T etc.) 3.5 Whitespace For operators (i.e., =, +, -, &lt;-), they are usually embraced by whitespaces, which would make your script easier to read: # Recommended grade_average &lt;- mean(midterm * 0.5 + final * 0.5) # NOT Recommended grade_average&lt;-mean(midterm*0.5+final*0.5) For : and ::, usually we do not put whitespaces around them: # Recommended x &lt;- c(1:10) tidyr::separate() # NOT Recommended x &lt;- c(1 : 10) tidyr :: separate() For parentheses (, if it is in the control structure, we usually put a whitespace before the initial (: for (i in 1:10) if ( x == 1) But if the parenthesis is in the function call, we don’t put a whitespace before the initial (: mean(x) ggplot(aes(x = money, y = achievement)) For curely brackets, we usually put a linebreak after the initial { and the ending } should be one single line. Also, as sometimes you would embed many different control structures at the same time, leading to many ending } lines, it is always good to commit properly which ending } goes with which control structure. for (i in 1:10) { if (i &lt; 5){ print(i) } else { print(i+10) } #endif } #endfor ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 15 ## [1] 16 ## [1] 17 ## [1] 18 ## [1] 19 ## [1] 20 3.6 Indention and Linebreaks R does not care about line breaks, whitespaces, or tabs in your R script. But these formating characters are important because you need all these characters to help you quickly keep track of your script. Make good use of the indention to increase the readability of your script. long_function_name &lt;- function(a = &quot;a long argument&quot;, b = &quot;another argument&quot;, c = &quot;another long argument&quot;) { # As usual code is indented by two spaces. } 3.7 More References Readability of your code is an art. Please consult the following recommended readings if you are interested in more principles of clean code. "],
["subsetting.html", "Chapter 4 Subsetting 4.1 Vector 4.2 Factor 4.3 List 4.4 Data Frame 4.5 Tibble", " Chapter 4 Subsetting Subsetting is very important. To subset is to select a particular subset of elements from a data structure (e.g., vecotr, matrix, data.frame, list). In Chapter 2, we discuss very briefly about data structures. Here we will look at each type of data structure in more detail and introduce ways of subsetting them. 4.1 Vector As we have shown in Chapter 2 R Fundamentals, there are three types of primitive vectors in R: character vectors numeric vectors boolean vectors You can assess a particular subset of a vector by using[ ] right after the object name. Within the [], you can make use of at least three types of indexes: numeric vector char.vec &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;) char.vec[1] ## [1] &quot;one&quot; You can also assess several elements of a vector by putting in several indices, c(), in the []: char.vec[c(1,4)] ## [1] &quot;one&quot; &quot;four&quot; boolean vector You can also use a boolean vector as the index: whether.to.extract &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) char.vec[whether.to.extract] ## [1] &quot;one&quot; &quot;three&quot; negative numeric vector If you use negative numbers in the index [], you will get a new vector printed on the console, with those indexed elements removed: char.vec[-2] ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; However, please note that the original vector is still the same in length: char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; If you want to save the shortened vector, you can either (a) assign the shortened vector to a new object name or (b) assign the shortened vector to the same object name: char.vec.short &lt;- char.vec[-2] char.vec.short ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec &lt;- char.vec[-2] char.vec ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; For the two alternatives, which one would be better? Why? 4.2 Factor In Chapter 2, we did not talk about this data structure–factor. There is an obvious reason for that. A factor works pretty much similarly to a vector in R. One of the key features for a factor is that its values are limited to a finite number of dinstinct categories. In many statistical experimental designs, a factor is usually a grouping factor, i.e., a factor that groups the subjects into sub-groups. We usually create a factor from a numeric or character vector. To create a factor, use factor(): sbj_gender_num &lt;- c(1, 0, 0, 1, 1, 0, 1) sbj_gender_num ## [1] 1 0 0 1 1 0 1 sbj_gender_char &lt;- c(&quot;female&quot;,&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;,&quot;male&quot;,&quot;female&quot;) sbj_gender_char ## [1] &quot;female&quot; &quot;male&quot; &quot;male&quot; &quot;female&quot; &quot;female&quot; &quot;male&quot; &quot;female&quot; sbj_gender_num_fac &lt;- factor(x = sbj_gender_num) sbj_gender_num_fac ## [1] 1 0 0 1 1 0 1 ## Levels: 0 1 sbj_gender_char_fac &lt;- factor(x = sbj_gender_char) sbj_gender_char_fac ## [1] female male male female female male female ## Levels: female male For a factor, the most important information is its levels, i.e., the limit set of all possible values this factor can take. We can extract the levels as a vector of character strings using levels(): levels(sbj_gender_num_fac) ## [1] &quot;0&quot; &quot;1&quot; levels(sbj_gender_char_fac) ## [1] &quot;female&quot; &quot;male&quot; When do we need a factor? Sometimes when we do the annotation of the data, we use arbitrary numbers as labels for certain categorical labels. For example, we may use arbitrary numbers from 1 to 4 to label learners of varying proficiency levels: 1 = beginners, 2 = low-intermediate, 3 = upper-intermediate, 4 = advanced. When we read the data into R, R may first treat the data as a numeric vector: sbj_prof_num&lt;- c(1, 2, 4, 4, 2, 3, 3, 1, 1) sbj_prof_num ## [1] 1 2 4 4 2 3 3 1 1 However, these numbers may be confusing to the extent that (a) R may even consider them really to be numbers, or (b) they are not intuitive at all as numbers do not have meanings. In this case, we can create a factor from this numeric vector and re-label these numeric values into categorical labels that are more intuitive. We can do this by setting more argments in factor(), such as levels=..., labels=.... sbj_prof_fac &lt;- factor(x = sbj_prof_num, levels = c(1:4), labels = c(&quot;beginner&quot;,&quot;low-inter&quot;,&quot;upper-inter&quot;,&quot;advanced&quot;)) sbj_prof_fac ## [1] beginner low-inter advanced advanced low-inter upper-inter ## [7] upper-inter beginner beginner ## Levels: beginner low-inter upper-inter advanced levels = ...: this argument specifies all possible values this factor can take labels = ...: this argument provides own intuitive labels for each level It should now therefore be clear that labels = ... is a good way for us to re-label any artitrary annotation into meaningful labels. What’s even more brilliant is that we can decide whether the ranking of the levels is meaning. If the order of the levels of the factor is meaning, we can set the argument ordered = TRUE: sbj_prof_fac_ordered &lt;- factor(x = sbj_prof_num, levels = c(1:4), labels = c(&quot;beginner&quot;,&quot;low-inter&quot;,&quot;upper-inter&quot;,&quot;advanced&quot;), ordered = T) sbj_prof_fac_ordered ## [1] beginner low-inter advanced advanced low-inter upper-inter ## [7] upper-inter beginner beginner ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced Now from the R console we can see not only the levels of the factor but also the signs &lt;, indicating their order. Using this ordered factor, we can perform relational comparison: sbj_prof_fac_ordered[1] ## [1] beginner ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced sbj_prof_fac_ordered[4] ## [1] advanced ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced sbj_prof_fac_ordered[1] &lt; sbj_prof_fac_ordered[4] ## [1] TRUE But we cannot do the comparison for unordered factors (characters neither): sbj_prof_fac[1] ## [1] beginner ## Levels: beginner low-inter upper-inter advanced sbj_prof_fac[4] ## [1] advanced ## Levels: beginner low-inter upper-inter advanced sbj_prof_fac[1] &lt; sbj_prof_fac[4] ## Warning in Ops.factor(sbj_prof_fac[1], sbj_prof_fac[4]): &#39;&lt;&#39; not meaningful for ## factors ## [1] NA The difference between vectors and factors may look trivial for the moment but they are statistically very crucial. The choice of whether to instruct R to treat a vector as a factor, or even an ordered factor, will have important consequences in the implementation of many statistical methods, such as regression or othe generalized linear modeling. Rule of thumb: Always pay attention to what kind of object class you are dealing with:) 4.3 List A List is like a vector, which is a one-dimensional data structure. However, the main difference is that a List cna include a series of objects of different classess: # A list consists of (i) numeric vector, (ii) character vector, (iii) boolean vector list.example &lt;- list(&quot;one&quot; = c(1,2,3), &quot;two&quot; = c(&quot;Joe&quot;, &quot;Mary&quot;, &quot;John&quot;,&quot;Angela&quot;), &quot;three&quot; = c(TRUE, TRUE)) list.example ## $one ## [1] 1 2 3 ## ## $two ## [1] &quot;Joe&quot; &quot;Mary&quot; &quot;John&quot; &quot;Angela&quot; ## ## $three ## [1] TRUE TRUE Please note that not only the class of each object in the List does not have to be the same; the length of each object may also vary. You can subset a List in two ways: [: This always returns a List back [[: This returns the object of the List element, which is NOT NECESSARILY a List list.example[1] ## $one ## [1] 1 2 3 list.example[[1]] ## [1] 1 2 3 list.example[[&quot;one&quot;]] ## [1] 1 2 3 Please try the following codes but before you try them on the R console, could you first predict the outputs? ind &lt;- c(&quot;one&quot;, &quot;three&quot;) list.example[ind] list.example[[ind]] 4.4 Data Frame data.frame is the most frequently used object that you will work with in data analysis. This is a typical two-dimensional spreadsheet-like table. Normally, the rows are the subjects or tokens you are analyzing; the columns are the variables or factors you are interested in. You can also use [,] to subset a data frame. The indexes in [,] are Row-by-Column. ex_df &lt;- data.frame( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34) ) ex_df WORD POS FREQ the ART 1104 boy N 35 you PRO 104 him PRO 34 You can subset a particular row of the data frame: ex_df[1,] ex_df[c(1,3),] You can subset a particular column of the data frame: ex_df[,1] ## [1] the boy you him ## Levels: boy him the you ex_df[,c(1,3)] ex_df[,c(&quot;WORD&quot;,&quot;FREQ&quot;)] Please compare the following two ways of accessing a column from the data frame. Can you tell the differences in the returned results? ex_df[, c(&quot;FREQ&quot;)] ex_df[, c(&quot;FREQ&quot;), drop = FALSE] 4.5 Tibble tibble is a new data structure with lots of advantages. For the moment, we treat tibble and data.frame as the same, with the former being an augmented version of the latter. All functions that work of a data.frame should be compatible with a tibble. Now the tibble is the major structure that R users work with under the tidy framework. If you are new to tibbles, the best place to start is the tibbles chapter in R for data science. require(tibble) ## Loading required package: tibble ## Warning: package &#39;tibble&#39; was built under R version 3.5.2 ex_tb &lt;- tibble::tibble( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34)) ex_tb You can subset a tibble in exactly the same ways as you work with a data.frame: ex_tb[1,] ex_tb[,1] ex_tb[,c(1:3)] Exercise 4.1 Please compare again the following codes and see if you can tell the major differences between tibble and data.frame? ex_tb[,c(&quot;FREQ&quot;)] ex_df[,c(&quot;FREQ&quot;)] ## [1] 1104 35 104 34 There are three major advantages with tibble() when compared with data.frame(): tibbles default to character vectors while data.frames convert all character vectors to factors by default the auto-printing the content of the tibble would only display the first ten rows; with a data.frame, the object name prints out everything. This could be devestating! (Imagine that you have a table with hundreds of thousands rows.) the auto-printing of the tibble is a lot more informative, providing additional attributes of the tibble such as (a) row and column numbers and (b) data type of each column "],
["data-visualization.html", "Chapter 5 Data Visualization 5.1 Why Visualization? 5.2 ggplot2 5.3 One-variable Graph 5.4 Two-variable Graph 5.5 Adding Other Aesthetic Features 5.6 Saving Plots", " Chapter 5 Data Visualization 5.1 Why Visualization? Data visualization is very important. I would like to illustrate this point with two interesting examples. First, let us take a look at an interesting dataset datasaurus.csv: Table 5.1: An Interesting Dataset group x y dino 95.38460 36.794900 dino 98.20510 33.718000 away 91.63996 79.406603 away 82.11056 1.210552 h_lines 98.28812 30.603919 h_lines 95.24923 30.459454 v_lines 89.50485 48.423408 v_lines 89.50162 45.815179 x_shape 84.84824 95.424804 x_shape 85.44619 83.078294 star 82.54024 56.541052 star 86.43590 59.792762 high_lines 92.24840 32.377154 high_lines 96.08052 28.053601 dots 77.92604 50.318660 dots 77.95444 50.475579 circle 85.66476 45.542753 circle 85.62249 45.024166 bullseye 91.72601 52.623353 bullseye 91.73554 48.970211 slant_up 92.54879 42.901908 slant_up 95.26053 46.008830 slant_down 95.44349 36.189702 slant_down 95.59342 33.234129 wide_lines 77.06711 51.486918 wide_lines 77.91587 45.926843 We group the dataset by group and for each group we computate the mean scores and standard deviations of x and y. According to the summary statistics of each group, they look indeed similar: Table 5.2: An Interesting Dataset - Summary group x_fn1 y_fn1 x_fn2 y_fn2 away 54.266 47.835 16.770 26.940 bullseye 54.269 47.831 16.769 26.936 circle 54.267 47.838 16.760 26.930 dino 54.263 47.832 16.765 26.935 dots 54.260 47.840 16.768 26.930 h_lines 54.261 47.830 16.766 26.940 high_lines 54.269 47.835 16.767 26.940 slant_down 54.268 47.836 16.767 26.936 slant_up 54.266 47.831 16.769 26.939 star 54.267 47.840 16.769 26.930 v_lines 54.270 47.837 16.770 26.938 wide_lines 54.267 47.832 16.770 26.938 x_shape 54.260 47.840 16.770 26.930 So you may conclude that all groups show similar behaviors in x and y measures. But what if we plot all subjects by groups? See? What you see is sometimes NOT what you believe. Another example is Simpson’s Paradox, which occurs when trends that appear when a dataset is separated into groups reverse when the data are aggregated. Based on the above graph, you would probably conclude that when x increases, y decreases. However, if you plot the scatter plots by groups, you may get the opposite conclusions. All correlations between x and y in all groups are now positive. 5.2 ggplot2 R is famous for its power in data visualization. So why don’t we delve right into this beauty in R? In this chapter, we will introduce you a very powerful graphic library in R, ggplot2. For any data visualization, there are three basic elements: Data: The raw material of your visualization, i.e., a data frame. Aesthetics: The mapping of your data to aesthetic attributes, such as x, y, color, linetype, fill. Geometric Objects: The layers of geometric objects you would like to see on the plots, e.g., lines, points etc. I will demonstrate some basic functions of ggplot2, with the pre-loaded dataset mpg: library(tidyverse) mpg model: manufacturer model name displ: engine displacement, in litres (排氣量) hwy: highway miles per gallon cty: city miles per gallon cyl: number of cylinders (汽缸數目) class: car type We can look at the relation between displ and hwy: ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() ggplot() initializes the basic frame of the graph, with data = mpg specifying the data frame on which the plot is built aes() further specifies the mapping of axises and the factors in the data frame. aes(x = displ, y = hwy) indicates that displ is mapped as the x axis and hwy as y axis + means that you want to add one layer of the graph to the template. geom_point() means that you want to add a layer of point graph. 5.3 One-variable Graph Continuous variable ggplot(data = mpg, aes(hwy)) + geom_density(kernel=&quot;gaussian&quot;) ggplot(data = mpg, aes(hwy)) + geom_histogram() Categorical variable ggplot(data = mpg, aes(x = class)) + geom_bar() 5.4 Two-variable Graph Continuous X, Continuous Y ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() Discrete X, Continuous Y ggplot(data = mpg, aes(x = class, y = hwy)) + geom_boxplot() Discrete X, Discrete Y ggplot(data = mpg, aes(x = manufacturer, y = class)) + geom_count() + theme(axis.text.x = element_text(angle=-90)) 5.5 Adding Other Aesthetic Features Now I would like to demonstrate how we can add additional aesthetic mappings to your graphs. You can add color = ... in the aes() to creat the graphs on the basis of a grouping factor We can introduce a third variable into the plot by modifying the color of the points based on the value of that third variable. Color is an aesthetic and the color of each point can be mapped to a variable. Note that the x-coordinates and y-coordinates are aesthetics too, and they got mapped to the displ and hwy variables, respectively. In this case we will map the color to the drv variable which indicates whether a car is front wheel drive, rear wheel drive, or 4-wheel drive. ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() We can also add another geom object, such as a smooth line: ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth() Could you predict what kind of graph you would get with the following code? ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + geom_smooth() We can add texts and labels as well ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + labs(x = &quot;Engine Displacement (litres)&quot;, y = &quot;Highway Miles per Gallon&quot;, title = &quot;Scatter Plot -- DISPL by HWY&quot;) 5.6 Saving Plots Saving a ggplot can be easily done by ggsave(). You can first save a ggplot object to a variable and then use ggsave() to output the ggplot object to an external file. It is recommended to use common image formats for publications, e.g., png, jpg. my_first_graph &lt;- ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + labs(x = &quot;Engine Displacement (litres)&quot;, y = &quot;Highway Miles per Gallon&quot;, title = &quot;Scatter Plot -- DISPL by HWY&quot;) class(my_first_graph) # check the class ## [1] &quot;gg&quot; &quot;ggplot&quot; my_first_graph # auto-print the ggplot ggsave(filename = &quot;my_first_plot.png&quot;,plot = my_first_graph, width = 6, height = 6) "],
["data-manipulation.html", "Chapter 6 Data Manipulation 6.1 Dataset 6.2 rename() 6.3 Pipe %&gt;% 6.4 mutate() 6.5 select() 6.6 filter() 6.7 arrange() 6.8 group_by() and summarize() 6.9 count() 6.10 left_join() 6.11 Exerceises", " Chapter 6 Data Manipulation In this chapter, we will be working with a powerful package, dplyr, which provides a consistent “grammar” for data manipulation and exploration by simplifying operations on data frames to a great deal. We first load the library: library(dplyr) In this library, there are a list of key verbs: mutate(): add new variables/columns or transform existing variables %&gt;%: the “pipe” operator is used to connect multiple verb actions together into a pipeline select(): return a subset of the columns of a data frame, using a flexible notation filter(): extract a subset of rows from a data frame based on logical conditions summarise(): generate summary statistics of different variables in the data frame, possibly within strata group_by(): group the data frame into sub-tables according to a grouping factor arrange(): reorder rows of a data frame rename(): rename variables in a data frame left_join(): merge the data frame with another data frame 6.1 Dataset The dateaset we use in this chapter is a student performance dataset from kaggle. library(readr) student &lt;- read_csv(&quot;demo_data/StudentsPerformance.csv&quot;) student Usually we would start from an overview of the dataset: summary(student) ## gender race/ethnicity parental level of education ## Length:1000 Length:1000 Length:1000 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## lunch test preparation course math score reading score ## Length:1000 Length:1000 Min. : 0.00 Min. : 17.00 ## Class :character Class :character 1st Qu.: 57.00 1st Qu.: 59.00 ## Mode :character Mode :character Median : 66.00 Median : 70.00 ## Mean : 66.09 Mean : 69.17 ## 3rd Qu.: 77.00 3rd Qu.: 79.00 ## Max. :100.00 Max. :100.00 ## writing score ## Min. : 10.00 ## 1st Qu.: 57.75 ## Median : 69.00 ## Mean : 68.05 ## 3rd Qu.: 79.00 ## Max. :100.00 6.2 rename() The column names in student are a mess. These names include spaces in them, which would be difficult to index these columns in R. This is however normal in the real world, where the dataset we get is often very messy. So, the first thing we can do with the dataset is the rename all the column names in a R-compatible way. rename(student, race = `race/ethnicity`, parent_edu = `parental level of education`, prep_course = `test preparation course`, math = `math score`, reading = `reading score`, writing = `writing score`) -&gt; student1 student1 Please note that in our earlier code, we save the output of rename() to a new object named student1. In other words, the object student1 should contain a new data frame with all column names fixed as above. 6.3 Pipe %&gt;% Now let’s look at a fantastic syntax in R, the pipe %&gt;%, which is definitely one of my favorite R idioms! To start with, the following two expressions are the same, giving you the same results: sum(c(1:10)) ## [1] 55 c(1:10) %&gt;% sum ## [1] 55 The meaning of %&gt;% is that the object on the left of the pipe is passed on to the right side of the pipe for further processing. By default, the object is passed onto to be the first argument of the function on the right-hand side. This pipe-based syntax would render the script more reader-friendly. For example, is it easy to guess the output of the following code? sqrt(sum(abs(c(-10:10)))) ## [1] 10.48809 But the above code can be re-written with the %&gt;% as follows: c(-10:10) %&gt;% abs %&gt;% sum %&gt;% sqrt ## [1] 10.48809 Now we understand the idiomatic expression of %&gt;%, our earlier rename() can be re-written as follows as well (cf. student1 and student): student %&gt;% rename(race = `race/ethnicity`, parent_edu = `parental level of education`, prep_course = `test preparation course`, math = `math score`, reading = `reading score`, writing = `writing score`) -&gt; student1a student1a From now on, we will use the pipe-based syntax more often. 6.4 mutate() Now imagine that you would like to create a new variable called final_grade, which is a weighted average of the student’s academic performance. Let us assume that you have the following weights in mind: math (50%), reading (25%), writing (25%). You can use mutate() to create a new column (i.e., variable) in your data frame: student1 %&gt;% mutate(final_grade = math*0.5 + reading*0.25 + writing*0.25) We can create more than one new variables as well: student1 %&gt;% mutate(language = reading*0.5 + writing*0.5, final_grade = math + language) In the above practices of mutate(), we did not save the output of mutate() to a new object. We only print the output directly to the console. In order words, the original data frame is still the same (i.e., student, student1); no new variables have been created wrt to these original data frames. 6.5 select() select() is to select particular columns of the data frame that you would like to focus on. You can select just one column student1 %&gt;% select(math) Or multiple columns: student1 %&gt;% select(math, reading, writing) Or columns within a range: student1 %&gt;% select(math:writing) You can also omit variables using select() student1 %&gt;% select(-c(race:lunch)) 6.6 filter() While select() is for columns, filter() is for rows. You can extract subsets of rows from a data frame. Most importantly, you can extract rows according to self-defined conditions. one logical condition student1 %&gt;% filter(math &gt; 90) AND &amp; conditions: student1 %&gt;% filter(math &lt; 40 &amp; reading &lt; 40) OR | conditions: student1 %&gt;% filter(math &lt; 40 | reading &lt; 40) XOR xor conditions: student1 %&gt;% filter(xor(math &lt; 40, reading &lt; 40)) Please check the row numbers of the above three filtered data frames. Any connection? 6.7 arrange() We can arrange the rows of the data frame according to a particular variable. student1 %&gt;% arrange(math) By default, R will arrange the rows in an ascending order. If you like to arrange your data in a descending order, put a desc() around your variable name: student1 %&gt;% arrange(desc(math)) 6.8 group_by() and summarize() The group_by() function is used to generate summary statistics from the data frame within strata defined by a grouping variable. For example, in this student1 dataset, you might want to know what the average math scores are for students of different genders. In conjunction with the group_by() function we often use the summarize() function to create the summarized statistics. The general operation here is a combination of splitting a data frame into separate pieces defined by a variable or group of variables (group_by()), and then applying a summary function across those subsets (summarize()). student1 %&gt;% group_by(gender) %&gt;% summarize(math_average = mean(math), math_median = median(math), math_sd = sd(math)) 6.9 count() One of the most-often used feature when we have tables is to tally the frequencies of the subjects according to some of the columns. The function count() is born for this. For example, we can create a frequency distribution of male and female students of different parental levels of education (i.e., parent_edu x gender contingency table): student1 %&gt;% count(parent_edu, gender) Exercise 6.1 Continuing the above example, how can you create another column, which includes the percentage of male and female students for those of the same parental level education (see below)? 6.10 left_join() 6.11 Exerceises Exercise 6.2 In the dataset demo_data/StudentsPerformance.csv, please read in the dataset and print out those students who are female and whose math scores are &lt; 40. In your output, please show the following columns only: gender, math. Exercise 6.3 With the same dataset, please compute the mean scores and standard deviations of math for different races. Also, please include the number of students for each race sub-group. Exercise 6.4 With the same dataset, please create a summary, which includes the number of students, math mean scores, math standard deviations, for students of different genders and parental education levels. Exercise 6.5 (Bonus) Have you any ideas how to generate the following graphs using ggplot2()? "],
["data-import.html", "Chapter 7 Data Import 7.1 readLines() 7.2 read_csv() 7.3 Structured Data: XML", " Chapter 7 Data Import 7.1 readLines() 7.2 read_csv() 7.3 Structured Data: XML "],
["string-manipulation.html", "Chapter 8 String Manipulation 8.1 What is Regular Expression? 8.2 String Basics 8.3 Regular Expression Grammar 8.4 Pattern Matching 8.5 Advanced Pattern Matching: Look Ahead and Behind 8.6 More Practices 8.7 Case Study: Chinese Four-Character Idioms", " Chapter 8 String Manipulation In this chapter, we will introduce some techniques relating to string manipulation. library(tidyverse) library(stringr) 8.1 What is Regular Expression? In text processing, we often do “find” and “replace” in our documents. I am sure that you do this very often in MS-Word or MS-Excel. Regular expression is a language, which allows us to create a textual pattern and use this pattern to match other strings with the same pattern for later processing. This idea of one-pattern-for-multiple-matches is the beauty of regular expression. Several advantages of regular expressions are self-evident: Complicated pattern matching e-mail format checking, phone number checking reduplicated strings date format control Information extraction and text mining extract texts according to a particular format Proper names, e-mails, phone numbers, etc. 8.2 String Basics There are three basic functions: str_length(): get the length of the string (i.e., number of characters) word_string &lt;- c(&quot;the&quot;, &quot;word&quot;, &quot;string&quot;) word_string %&gt;% str_length ## [1] 3 4 6 str_c(): combine strings into a longer one str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;) ## [1] &quot;thewordstring&quot; str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;,sep = &quot;_&quot;) ## [1] &quot;the_word_string&quot; Please note that the following code will generate a different result from the above. Can you tell the differences? How can you generate exactly the same results by using str_c(word_string,…)? Please check ?str_c. str_c(word_string, sep = &quot;_&quot;) ## [1] &quot;the&quot; &quot;word&quot; &quot;string&quot; str_sub(): substract part of the string str_sub(string = &quot;international&quot;, start = 1, end = 5) ## [1] &quot;inter&quot; 8.3 Regular Expression Grammar Now let’s look at the grammar of regular expressions in more detail. In stringr, there is a very useful function, str_view(STRING, PATTERN), which can show us the match of the pattern in the string in a visually intuitive way: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;an&quot;) 8.3.1 Metacharacters In REGEX, . is a special character, referring to any character: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;.a.&quot;) But what if you really want to match a period . sign in your string? x &lt;- c(&quot;apple&quot;, &quot;banana&quot;,&quot;pear&quot;, &quot;orange. And&quot;) str_view(string = x, pattern = &quot;.&quot;) str_view(string = x, pattern = &quot;\\\\.&quot;) This leads us to the notion of escaping character \\. In R, \\ is used if you want to tell R that the character after \\ should be treated literally, not metaphorically as a meta character. But why two slashes \\\\? It’s simple: because \\ itself is a meta character in R as well. We use it to escape quotes like &quot; and '. Therefore, the first backslash is needed to tell R that the second backslash is matched literally (because we need it to serve as an escape character in the regular expression). 8.3.2 Anchors We can find a match anchored in a particular position. ^: The start of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) $: The end of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;^apple$&quot;) 8.3.3 Character Set \\\\d: matches any digit. \\\\s: matches any whitespace (e.g. space, tab, newline). \\\\w: matches any alphanumeric characters x&lt;-c(&quot;apple&quot;,&quot;apple123&quot;,&quot;banana1&quot;) str_view(string = x , pattern = &quot;\\\\d&quot;) x &lt;- c(&quot;aeiouAEIOU1234_ .\\\\$%-*()&quot;) str_view_all(string = x, pattern = &quot;\\\\w&quot;) #compare str_view_all(string = x, pattern = &quot;.&quot;) 8.3.4 Alternatives [abc]: matches a, b, or c. [^abc]: matches anything except a, b, or c. x &lt;- c(&quot;grey&quot;, &quot;gray&quot;) str_view(string = x, pattern = &quot;gr[ea]y&quot;) 8.3.5 Quantifiers We can use quantifiers to quantifier the degrees of repetition of the quantified character (i.e., the char preceding the quantifier): ?: 0 or 1 +: 1 or more *: 0 or more x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) str_view(x, &quot;X+&quot;) Specify exactly the number of repetition: {n}: exactly n {n,}: n or more {,m}: at most m {n,m}: between n and m x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;C{2}&quot;) str_view(x, &quot;C{2,}&quot;) str_view(x, &quot;C{2,3}&quot;) 8.3.6 Greedy vs. Non-greedy match x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CLX+&quot;) str_view(x, &quot;CLX+?&quot;) 8.3.7 Group and Back-reference x &lt;- fruit %&gt;% head(10) x ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; ## [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; Now if you want to extract English fruit words which has two same letter repeating twice in a row (e.g, apple, bell pepper). How would you create your regular expression pattern? str_view(x, &quot;.{2}&quot;) The results are not what you have expected. The trick is that when you use . to match any character, the quantifier does not help much as any character that repeats would fit the pattern. We need a new strategy to ask the regex engine to remember the matched character and quantify the number of occurrences of the remembered character: str_view(x, &quot;(.)\\\\1&quot;) .: matches any character (.): the parenthesis would label the matched as a group. Internally, the regex engine numbers all groups serially from left to right \\\\1: back-reference the first group. The same logic applies to the second group of the regular expression (i.e., \\\\2) So (.)\\\\1 means that when the engine matches a character (which can be any character), there has to be another same character following the former. Exercise 8.1 How do you match abab pattern, such as “banana”? Exercise 8.2 How do you match abba pattern, such as “pepper”? 8.4 Pattern Matching This section will show you examples of how we can make use of regular expresions to process strings. In stringr, there are a list of verbs that we use with regular expressions: str_detect(STRING, PATTERN): Determine which strings in STRING has a match of the PATTERN (binary) x &lt;- fruit %&gt;% head(10) str_detect(x, &quot;e$&quot;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE str_subset(STRING, PATTERN): Subset the full strings in STRING that have either a full or partial match of the PATTERN (character) str_subset(x, &quot;e$&quot;) ## [1] &quot;apple&quot; &quot;blood orange&quot; str_extract(STRING, PATTERN): Extract the content of the matches of the strings in STRING (character) str_extract(x, &quot;e$&quot;) ## [1] &quot;e&quot; NA NA NA NA NA NA NA &quot;e&quot; NA str_replace(STRING, PATTERN, REPLACEMENT): Replace matches of the PATTERN with REPLACEMENT in STRING (character): str_replace() str_replace(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) ## [1] &quot;Vpple&quot; &quot;Vpricot&quot; &quot;Vvocado&quot; &quot;bVnana&quot; &quot;bVll pepper&quot; ## [6] &quot;bVlberry&quot; &quot;blVckberry&quot; &quot;blVckcurrant&quot; &quot;blVod orange&quot; &quot;blVeberry&quot; It should be noted that str_replace() only replaces the first match of each string. str_replace_all(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) ## [1] &quot;VpplV&quot; &quot;VprVcVt&quot; &quot;VvVcVdV&quot; &quot;bVnVnV&quot; &quot;bVll pVppVr&quot; ## [6] &quot;bVlbVrry&quot; &quot;blVckbVrry&quot; &quot;blVckcVrrVnt&quot; &quot;blVVd VrVngV&quot; &quot;blVVbVrry&quot; str_split(STRING, PATTERN): Split a string in STRING based on a PATTERN (character) x &lt;- sentences %&gt;% head(5) x ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; str_split(string = x, pattern = &quot;\\\\s&quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; ## ## [[4]] ## [1] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; ## [8] &quot;rare&quot; &quot;dish.&quot; ## ## [[5]] ## [1] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; Please note that the return of str_split() is a list. fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;: &quot;) ## [[1]] ## [1] &quot;Name&quot; &quot;Hadley&quot; ## ## [[2]] ## [1] &quot;Country&quot; &quot;NZ&quot; ## ## [[3]] ## [1] &quot;Age&quot; &quot;35&quot; fields %&gt;% str_split(&quot;: &quot;, simplify = T) ## [,1] [,2] ## [1,] &quot;Name&quot; &quot;Hadley&quot; ## [2,] &quot;Country&quot; &quot;NZ&quot; ## [3,] &quot;Age&quot; &quot;35&quot; Exercise 8.3 Convert American dates to British dates. Exercise 8.4 Split filenames of ICNALE 8.5 Advanced Pattern Matching: Look Ahead and Behind If you want to find Windows, but only when it is followed by &quot;95, 98, NT, 2000&quot;: win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;Windows3.1&quot;) str_view(win, &quot;Windows(?=95|98|NT|2000)&quot;) Or the other way around: win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;Windows3.1&quot;) str_view(win, &quot;Windows(?!95|98|NT|2000)&quot;) In the regular expression, the () after Windows is a condition for matching. There are four alternatives to specify your conditions: Look-ahead conditions: (?=pattern): The target match has to be followed by the pattern in the condition (?!pattern): The target match cannot be followed by the pattern in the condition Look-behind conditions: (?&lt;=pattern): The target match has to be preceded by the pattern in the condition (?&lt;!pattern): The target match cannot be preceded by the pattern in the condition win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;3.1Windows&quot;) str_view(win, &quot;(?&lt;=95|98|NT|2000)Windows&quot;) win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;3.1Windows&quot;) str_view(win, &quot;(?&lt;!95|98|NT|2000)Windows&quot;) Exercise 8.5 Please use the first ten words in the fruit vector for this exercise. Based on the fruit vocabulary, can you give us all the a's that are followed by STOP_SOUNDS? STOP_SOUNDS refer to p, t, k, b, d, g. Exercise 8.6 Similar to the previous example, Exercise 8.5, also based on the first ten words in fruit, please identify all the vowels that are both followed and preceded by STOP_SOUNDS. 8.6 More Practices 8.6.1 Case 1 How to extract only the number of the week from the y column, and add this information to a new column, z? dt &lt;- tibble( x = 1:4, y = c(&quot;wk 3&quot;, &quot;week-1&quot;, &quot;7&quot;, &quot;w#9&quot;) ) dt 8.6.2 Case 2 How to extract all the vowels from the first ten words in fruit? dt &lt;- tibble( WORD = fruit[1:10] ) dt 8.6.3 Case 3 How to separate the English and Chinese and create two new columns, EN, CH? tb &lt;- tibble(x = c(&quot;I我&quot;, &quot;love愛&quot;, &quot;you你&quot;)) tb 8.6.4 Case 4 How to extract the numbers and split the numbers into START and END? df &lt;- tibble(x = c(&quot;1-12周&quot;, &quot;1-10周&quot;, &quot;5-12周&quot;)) df 8.6.5 Case 5 How to extract numbers of each token and compute the sum of the number and save the results in a new column SUM? df &lt;- tibble( x = c(&quot;1234&quot;, &quot;B246&quot;, &quot;217C&quot;, &quot;2357f&quot;, &quot;21WD4&quot;) ) df 8.6.6 Case 6 How to extract all the numbers that follow a upper-casing letter? For example, 34 after W; 217 after B? df &lt;- tibble( x = c(&quot;12W34&quot;, &quot;AB2C46&quot;, &quot;B217C&quot;, &quot;akTs6df&quot;, &quot;21WD4&quot;) ) df 8.6.7 Case 7 Relating to Section 8.6.6, can you add another column to the resulting data frame, which records the upper-casing letter that the numbers follow for each token? 8.7 Case Study: Chinese Four-Character Idioms Many studies have shown that Chinese makes use of large proportion of four-character idioms in the discourse. Let’s have an exploratory analysis of four-character idioms in Chinese. 8.7.1 Dictionary Entries In our demo_data directory, there is a file dict-ch-idiom.txt, which includes a list of four-character idioms in Chinese. These idioms are collected from 搜狗輸入法詞庫 and the original file formats (.scel) have been combined, removed of duplicate cases, and converted to a more machine-readable format, i.e., .txt. Let’s first import the idioms in the file. all_idioms &lt;- readLines(con = &quot;demo_data/dict-ch-idiom.txt&quot;) head(all_idioms) ## [1] &quot;阿保之功&quot; &quot;阿保之勞&quot; &quot;阿鼻地獄&quot; &quot;阿鼻叫喚&quot; &quot;阿斗太子&quot; &quot;阿芙蓉膏&quot; tail(all_idioms) ## [1] &quot;罪無可逭&quot; &quot;罪人不帑&quot; &quot;作纛旗兒&quot; &quot;坐纛旂兒&quot; &quot;作姦犯科&quot; &quot;作育英才&quot; length(all_idioms) ## [1] 56536 In order to make use of the tidy structure in R, we convert the data into a tibble: idiom &lt;- tibble(string = all_idioms) 8.7.2 Case Study: X來Y去 We can create a regular expression pattern to extract all idioms with the format of X來X去: idiom %&gt;% filter(str_detect(string, &quot;.來.去&quot;)) To analyze the meaning of this constructional schema, we may need to extract the X and Y in the schema: idiom_laiqu &lt;-idiom %&gt;% filter(str_detect(string, &quot;.來.去&quot;)) %&gt;% mutate(pattern = str_replace(string, &quot;(.)來(.)去&quot;, &quot;\\\\1_\\\\2&quot;)) %&gt;% separate(pattern, into = c(&quot;w1&quot;, &quot;w2&quot;), sep = &quot;_&quot;) idiom_laiqu One empirical question is how many of these idioms are of the pattern X=Y (e.g., 想來想去, 直來直去) and how many are of X!=Y (e.g., 說來道去, 朝來暮去): idiom_laiqu %&gt;% mutate(structure = ifelse(w1==w2, &quot;XX&quot;,&quot;XY&quot;)) %&gt;% count(structure) idiom_laiqu %&gt;% mutate(structure = ifelse(w1==w2, &quot;XX&quot;,&quot;XY&quot;)) %&gt;% count(structure) %&gt;% ggplot(aes(structure, n, fill = structure)) + geom_col() 8.7.3 Exercises Exercise 8.7 Please use idiom and extract the idioms with the schema of 一X一Y. Exercise 8.8 Also with the idiom as our data source, now if we are interested in all idioms that have duplicated characters in them, with schemas like either _A_A or A_A_, where A is a fixed character. How can we extract all idioms of these two types from idiom? Also, provide the distribution of the two types. Exercise 8.9 Following Exercise 8.8, for each type of the idioms, please provide their respective proportions of X=Y vs. X!=Y. Exercise 8.10 Folloing Exercise 8.9, please identify the character that is duplicated in the idioms. One follow-up analysis would be to look at the distribution of these pivotal characters. Can you reproduce a graph as shown below as closely as possible? "],
["conditions-and-loops.html", "Chapter 9 Conditions and Loops 9.1 if Statements 9.2 for 9.3 while loop 9.4 Toy Example", " Chapter 9 Conditions and Loops When you start to write more sophisticated programs with R, you will very often need to control the flow and order the executation in your code. You will usually run into two types of scenarios: Make the execution of a particular code chunk dependent on a condition Repeat a particular code chunk a certain number of times, which is often referred to as loops. In this Chapter, we will explore these core programming techniques using if-else statements, for and while loops. However, in Chapter 10, we will talk about loops more and point you to the idiomatic ways of dealing with loops in R. 9.1 if Statements The main purpose of if is to control precisely which operations are carried out in a given code chunk. A if statement runs a code chunk only if a certain condition is true. This conditional expression allows R to respond differently depending on whether the condition is TRUE or FALSE. The basic template of if is as follows: if(CONDITION IS TRUE){ DO THIS CODE CHUNK 1 } else{ DO THIS CODE CHUNK 2 } The condition is palced in parentheses after if. The condition must be an expression that returns only a single logical value (TRUE or FALSE). If it is TRUE, the code chunk 1 in the braces will be executed; if the condition is not satisfied, the code chunk 2 in the braces after else will be executed. Let’s create a simple password checker. Imagine that your system password is stored on the server. You can only get into the system if you enter the correct password. For every password you enter, the system gatekeeper will check if your input password matches the one stored on the server. If they match, you will be allowed to get through. input &lt;- 113 if(input == 987){ writeLines(&quot;Congratulations! Now you may get in!&quot;) } else{ writeLines(&quot;Sorry! Wrong password.&quot;) } ## Sorry! Wrong password. Now we can read the input directly from the user’s input in the R console: input &lt;- readline(prompt=&quot;Please enter your password:&quot;) if(input == 987){ writeLines(&quot;Congratulations! Now you may get in!&quot;) } else{ writeLines(&quot;Sorry! Wrong password.&quot;) } 9.2 for The for loop statment is to repeat a code chunk, often while incrementing an index or counter. The most frequent scenario is to repeat a code chunk through a vector/list, element by element, or through a data frame row by row (or column by column). The basic for loop template is as follows: for(LOOP_INDEX in LOOP_VECTOR){ DO THIS CODE CHUNK } The LOOP_INDEX is a placeholder that represents an element in the LOOP_VECTOR. When the loop begins, the LOOP_INDEX starts off as the first element in the vector. When the loop reaches the end of the brace, the LOOP_INDEX is incremented, taking on the next element in the vector. This process continues until the loop reaches the final element of the LOOP_VECTOR. At this point, the code chunk is executed for the last time, and the loop exits. For example, if we have a character vector with a few words in it. We can use a for loop to get the number of characters for each element in the vector. word_vec &lt;- c(&quot;apple&quot;,&quot;banana&quot;,&quot;watermelon&quot;,&quot;papaya&quot;) for(w in word_vec){ word_nchar &lt;- nchar(w) writeLines(as.character(word_nchar)) } ## 5 ## 6 ## 10 ## 6 For the above example, there is another way to write the for loop: for(i in 1:length(word_vec)){ word_nchar &lt;- nchar(word_vec[i]) writeLines(as.character(word_nchar)) } ## 5 ## 6 ## 10 ## 6 In our first example, the LOOP_INDEX directly represent elements in the LOOP_VECTOR. In our second example, the LOOP_INDEX represents indexs of the vector. 9.3 while loop There is another type of loop. Unlike the for loop, which repeats a code chunk by going through every element in a vector, the while loop repeats a code chunk UNTIL a specific condition evalutes to FALSE. The basic template is as follows: while(LOOP_CONDITION){ DO THIS CODE CHUNK (UNTIL THE LOOP_CONDITION BECOMES FALSE) } Upon the start of a while loop, the LOOP_CONDITION is evaluated. If the condition is TRUE, the braced code chunk is executed line by line till the end of the chunk. At this point, the LOOP_CONDITION will be checked again. The loop terminates immediately when the condition is evaluated to be FALSE. Based on the template above, you should infer that the code chunk executed must somehow cause the loop to exit, and very often will change the value of certain objects, which would eventaully lead to the change of the LOOP_CONDITION. If nothing ever changes the LOOP_CONDITION, R will crash due to the infinite loops. Let’s come back to our password checker. This time let’s create a dumb checker. When you give a wrong password which is smaller than your true answer, it will automatically approach the right asnwer for you (and of course no real-world application would do that!) ans &lt;- 87 guess &lt;- 83 while(guess != ans){ writeLines(&quot;Your `guess` is too small! The system will take care for you!&quot;) guess &lt;- guess + 1 cat(&quot;Now the system is adjusting your `guess` to &quot;, guess, &quot;\\n&quot;) } ## Your `guess` is too small! The system will take care for you! ## Now the system is adjusting your `guess` to 84 ## Your `guess` is too small! The system will take care for you! ## Now the system is adjusting your `guess` to 85 ## Your `guess` is too small! The system will take care for you! ## Now the system is adjusting your `guess` to 86 ## Your `guess` is too small! The system will take care for you! ## Now the system is adjusting your `guess` to 87 9.4 Toy Example Now we are playing the Guess Game. The game is as follows: I pick a number from 1 to 100. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. ans &lt;- 18 guess &lt;- readline(prompt = &quot;Please guess my number(0~100):&quot;) while(guess != ans){ if(guess &lt; ans){ writeLines(&quot;The asnwer is higher.&quot;) guess &lt;- readline(prompt = &quot;Please guess my number(0~100):&quot;) }else{ writeLines(&quot;The asnwer is lower&quot;) guess &lt;- readline(prompt = &quot;Please guess my number(0~100):&quot;) } } writeLines(&quot;Correct!&quot;) "],
["iteration.html", "Chapter 10 Iteration 10.1 Code Duplication 10.2 vector vs. list in R 10.3 Iteration 10.4 purr 10.5 Writing Own Functions", " Chapter 10 Iteration 10.1 Code Duplication Code duplication is tedious and hard to maintain and debug. Plus, there are obvious advantages for reducing code duplications. According to Wickham and Grolemund (2017) Chapter 21 Iteration, there are three main advantages of doing so: It’s easier to see the intent of your code, because your eyes are drawn to what’s different, not what stays the same. It’s easier to respond to changes in requirements. As your needs change, you only need to make changes in one place, rather than remembering to change every place that you copied-and-pasted the code. You’re likely to have fewer bugs because each line of code is used in more places. There are in general two major ways to reduce duplication in coding: wrap the duplicate procedures into a function use iteration This chapter would focus on the second strategy.In this chapter, we talk about code efficiency. In particular we will work on the library purr. 10.2 vector vs. list in R Most of the R-internal functions are vectorized. By default, if we apply a function to a multi-element vector, R will automatically apply the same procedure to each element of the vector, and return the results of the same length. a.vec &lt;- c(1:10) sqrt(a.vec) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 But this is NOT something we can do with a list: a.list &lt;- list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) sqrt(a.list) ## Error in sqrt(a.list): non-numeric argument to mathematical function 10.3 Iteration As we work with list and data.frame very often, it would great if we can have a easy way to apply the same procedure to: - each element in the list - each row in the data.frame - each column in the data.frame Let’s start with a scenario. We first create a pseudo data set, with students’ grades from five different classes. exams.list &lt;- list( class1 = round(runif(30, 0, 100)), # 30 tokens of random numbers in the range &lt;0, 100&gt; class2 = round(runif(30, 0, 100)), class3 = round(runif(30, 0, 100)), class4 = round(runif(30, 0, 100)), class5 = round(runif(30, 0, 100)) ) exams.list ## $class1 ## [1] 91 16 19 12 84 19 26 5 51 25 9 6 31 60 25 96 77 39 8 89 52 89 71 51 36 ## [26] 81 38 98 68 33 ## ## $class2 ## [1] 3 9 55 7 39 15 50 45 28 94 84 76 27 4 47 18 50 85 65 86 24 13 63 14 31 ## [26] 83 24 49 85 9 ## ## $class3 ## [1] 27 20 83 65 35 97 89 38 1 3 34 73 90 36 75 16 93 30 31 60 21 12 84 80 54 ## [26] 32 29 88 75 76 ## ## $class4 ## [1] 0 21 89 13 43 2 35 58 69 86 12 7 60 5 30 3 56 46 6 26 16 74 71 19 50 ## [26] 56 76 19 27 82 ## ## $class5 ## [1] 66 91 81 75 71 0 64 100 55 35 76 18 48 19 52 46 6 67 85 ## [20] 43 89 18 70 1 3 21 26 29 100 14 If we like to compute the mean scores of each cluster, you probably want to use mean(): mean(exams.list) ## [1] NA It should be clear now that mean() expects a numeric vector, on which the mean score is computed. So you may think that why don’t we use the dumb way: set.seed(123) # Make sure we get the same results exams.list.means &lt;- list( class1mean = mean(exams.list$class1), class2mean = mean(exams.list$class2), class3mean = mean(exams.list$class3), class4mean = mean(exams.list$class4), class5mean = mean(exams.list$class5) ) exams.list.means ## $class1mean ## [1] 46.83333 ## ## $class2mean ## [1] 42.73333 ## ## $class3mean ## [1] 51.56667 ## ## $class4mean ## [1] 38.56667 ## ## $class5mean ## [1] 48.96667 The advantage is obvious: (a) what if you have 10 classes? 100 classes? (b) what if now you decide to compute standard deviation? 10.4 purr library(tidyverse) exams.list %&gt;% map(mean) ## $class1 ## [1] 46.83333 ## ## $class2 ## [1] 42.73333 ## ## $class3 ## [1] 51.56667 ## ## $class4 ## [1] 38.56667 ## ## $class5 ## [1] 48.96667 With only one-line code, you have achieved your goal. map() is a very powerful function to do iteration. Its usage is as follows: To conceptualize this code map(exams.list, mean): For each element in the exams.list, apply the function mean Do the first element, and save the result in the first elemenet of the new list Do the second element, and save the result in the second elemvent of the new list … After finishing all elements in the exams.list, return the new list result In purrr, by default map() returns results in a list format. You can specify a particular data structure you like by using other variants of the mapping function: exams.list %&gt;% map_df(mean) exams.list %&gt;% map_dbl(mean) ## class1 class2 class3 class4 class5 ## 46.83333 42.73333 51.56667 38.56667 48.96667 Exercise 10.1 Use the same dataset, exam.list, and compute the median and standard deviation for each class. Median ## class1 class2 class3 class4 class5 ## 38.5 42.0 46.0 32.5 50.0 Standard Deviation ## class1 class2 class3 class4 class5 ## 30.75160 29.22556 30.12466 28.50249 31.49766 10.5 Writing Own Functions With the power and flexibility of purrr::map(), we can basically do everything iteratively. More attractively, we can apply a self-defined function as well! First we create own self-defined function my_center: - This function takes a vector object x - Substract each element of x by the mean score of x - return the resulting vector as the output of the function my_center &lt;- function(x) { x - mean(x) } Now we can apply our my_center function to each class in exams.list: exams.list %&gt;% map_df(my_center) Exercise 10.2 Use the built-in the mtcars dataset (?mtcars for more detail). How to get the class type of each column in the mtcars? Exercise 10.3 Create a self-defined function to convert each number of a numeric vector to a “z” score. y &lt;- c(1, 4, 6, 10, 20) my_z(y) ## [1] -7.2000000 -2.1000000 -0.8981462 0.5692100 2.6385602 Exercise 10.4 Use the dataset exams.list in this chapter. For each class, please convert the student’s score to a z-score. exams.list %&gt;% map_df(my_z) References "],
["data-scientist-first-step.html", "Chapter 11 Data Scientist First Step 11.1 Nobel Laureates Dataset 11.2 Before we start 11.3 Data Completeness NA 11.4 Hypotheses 11.5 At what age did these people receive the prizes?", " Chapter 11 Data Scientist First Step Finally this chapter will demonstrate how you can make use of what you have learned from the previous chapters to perform a exploratory data analysis on the dataset you are interested in. Here we will look at a dataset of Nobel Laureates. library(tidyverse) 11.1 Nobel Laureates Dataset df &lt;- read_csv(&quot;demo_data/nobel-laureates.csv&quot;) df 11.2 Before we start Before we start, it is clear to see that the column names are full of spaces, which we would like to get rid off. So first, we remove all the spaces in the columns and replace them with _: names(df) &lt;- str_replace_all(names(df), &quot;\\\\s&quot;,&quot;_&quot;) df 11.3 Data Completeness NA It is always important to check if the information of each row is complete. check_num_NA &lt;- function(x){ x %&gt;% is.na %&gt;% sum } df %&gt;% map_df(check_num_NA) You can check rows with NA’s: df %&gt;% filter(is.na(Sex)) 11.4 Hypotheses When given a dataset, before you explore your data, you may first have some hypotheses in mind: 11.4.1 How many laureates were there in different discplines? df %&gt;% count(Category) df %&gt;% count(Category) %&gt;% ggplot(aes(x = Category, y = n, fill = Category)) + geom_col() + geom_text(aes(label = n), vjust = -0.25) + labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) df %&gt;% count(Category) %&gt;% ggplot(aes(x = fct_reorder(Category, n), y = n, fill = Category)) + geom_col() + geom_text(aes(label = n), vjust = -0.25) + labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) An even more dynamic graph: library(gganimate) #install.packages(&quot;gganimate&quot;, dependencies = T) df %&gt;% count(Category) %&gt;% mutate(Category = fct_reorder(Category, n)) %&gt;% ggplot(aes(x = Category, y = n, fill = Category)) + geom_text(aes(label = n), vjust = -0.25) + geom_col()+ labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) + transition_states(Category) + shadow_mark(past = TRUE) 11.4.2 Chinese Laureates df %&gt;% filter(Birth_Country == &quot;China&quot;) There are duplicate tokens in our dataset. nobel_winners &lt;- df %&gt;% mutate_if(is.character, tolower) %&gt;% # lower all character vectors distinct_at(vars(Full_Name, Year, Category), .keep_all = TRUE) %&gt;% mutate(Decade = 10 * (Year %/% 10), Prize_Age = Year - lubridate::year(Birth_Date)) nobel_winners Check Chinese laureates again: nobel_winners %&gt;% filter(Birth_Country == &quot;china&quot;) %&gt;% select(Full_Name, Year, Category) Create a subset of `nobel_winners`, which includes only winners who won the prizes more than once and in more than one category. 11.5 At what age did these people receive the prizes? nobel_winners %&gt;% ggplot(aes(x = Prize_Age)) + geom_histogram(color=&quot;white&quot;) nobel_winners %&gt;% filter(!is.na(Prize_Age)) %&gt;% ggplot(aes(x = Prize_Age, fill = Category, color = Category)) + geom_density() + facet_wrap(~Category) + theme(legend.position = &quot;none&quot;) Exercise 11.1 Please create data frame that shows us the average agae of the winners in different categories, as shown below. Exercise 11.2 Please create data frame that shows us the distributions of male and female winners in different categories. Please show the number of males and females as well as the proportions. (i.e., frequencies and normalizaed frequencies) Exercise 11.3 Please show us the states distribution of the US Nobel Winners. This would give us an idea from which states in the United States there were the most Nobel winners. Exercise 11.4 Following Exercise 11.3, can you include the full names of states in the above table by adding another column? In the demo-data directory, you can find a csv with the mapping between states abbreviations and their full names. The US-states.csv dataset US_states &lt;- read_csv(&quot;demo_data/US-states.csv&quot;) US_states "],
["references.html", "References", " References "]
]
