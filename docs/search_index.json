[
["data-import.html", "Chapter 9 Data Import 9.1 Overview 9.2 Importing Data 9.3 Character Encoding 9.4 Character, Code Point, and Hexadecimal Mode 9.5 R Base Functions 9.6 readr Functions 9.7 Directory Operations", " Chapter 9 Data Import Most of the time, we need to work with our own data. In this chapter, we will learn the fundamental concepts and techniques in data I/O (input/output). In particular, we have two main objectives: Learn how to load our data in R from external files Learn how to save our data in R to external files 9.1 Overview There are two major file types that data analysts often work with: txt and csv files. Following the spirit of tidy structure, we will introduce the package, readr, which is also part of the tidyverse. This package provides several useful functions for R users to load their data efficiently from plain-text files. In particular, we will introduce the most effective functions: read_csv() and write_csv() for the loading of CSV files. 9.1.1 What is a CSV file? A CSV is a comma-separated values file, which allows data to be saved in a tabular format. CSVs look like a spreadsheet but with a .csv extension. A CSV file has a fairly simple structure. It’s a list of data separated by commas. For example, let’s say you have a few contacts in a contact manager, and you export them as a CSV file. You’d get a file containing texts like this: Name,Email,Phone Number,Address Bob Smith,bob@example.com,123-456-7890,123 Fake Street Mike Jones,mike@example.com,098-765-4321,321 Fake Avenue CSV files can be easily viewed with any of the text editors (e.g., Notepad++, TextEdit), or spreadsheet programs, such as Microsoft Excel or Google Spreadsheets. But you can only have one single sheet in a file and all data are kept as normal texts in the file. 9.1.2 Why are .CSV files used? There are several advantages of using CSV files for data exchange: CSV files are plain-text files, making them easier for the developer to create Since they’re plain text, they’re easier to import into a spreadsheet or another storage database, regardless of the specific software you’re using To better organize large amounts of data 9.1.3 How do I save CSV files? Saving CSV files is relatively easy. You just need to know where to change the file type. With a normal spreadsheet application (e.g., MS Excel), under the “File” section in the “Save As” tab, you can select it and change default file extension to &quot;CSV (Comma delimited) (*.csv)&quot;. Although people mostly use the comma character to separate (or delimit) data, sometimes people use other characters like the tab, i.e., \\t. Therefore, sometimes people use the file extension TSV to indicate that the tabular data in the file are delimited by tab (indicating the column boundaries). Please also note that all these tabular files can be named with the extension .txt as well. However, a more intuitive file extension is definitely better for data management. 9.1.4 What about other types of data? In data analysis, we sometimes may need to deal with some other types of data files in addition to the plain-texts. For the import/export of other types of data, R also has specific packages designed for them: haven - SPSS, Stata, and SAS files readxl - excel files (.xls and .xlsx) DBI - databases jsonlite - json xml2 - XML httr - Web APIs rvest - HTML (Web Scraping) readtext - large text data (corpus) 9.2 Importing Data Figure 9.1: Data I/O 9.3 Character Encoding Before we move on to the functions for data I/O, I would like to talk about the issues of character encoding. For all characters in languages, computers use numbers like 1 and 0 to encode all these characters. The more characters a language has, the more numbers are needed in the encoding. For example, for an English text, it usualy consists of only Latin alphabets, and limited sets of essential numbers and punctuation marks. A 7-bit encoding scheme is enough to cover all the possible characters in English. The 7-bit encoding gives us the maximum of 128 (27 = 128) possible different characters to encode: each coding number corresponds to one unique character. The ASCII (American Standard Corde for Information Interchange) encoding, a 7-bit character encoding developed from telegraph code, is a well-known encoding for English texts. 9.3.1 Problems with ASCII Many languages have more characters German umlauts (über) Accents in Indo-European Languages (déjà) Asciification/Romanization ASCII equivalents were defined for foreign characters that have not been included in the original character set Indo-European languages developed extended verions of ASCII 9.3.2 From 7-bit to One-Byte Encoding Single byte (8-bit) encoding Reserve the first 128 characters for ASCII characters 8-bit allows at most 256 possibilities ISO-8859-1 Encoding 9.3.3 Problems with Single-Byte Encoding Inconsistency A large number of overlapping character sets for encoding characters in different languages Often more than one symbol maps to the same code point/number Compatibility Still can’t deal with writing systems with large character sets (CKJ) Two-byte character sets Represent up to 65,536 distinct characters (216 = 65536) Multiple byte encoding Big-5 encoding for traditional Chinese GB encoding for simplified Chinese 9.3.4 Problems with Multi-byte Encoding Different languages still use different encodings Some are single-byte, while some are multiple byte Digital texts usually have many writing systems single-byte texts, letters, spaces, punctuations, Arabic numerals Interspersed with 2-byte Chinese characters Problems Inconsistency in the byte-encoding number Compatibility across different languages 9.3.5 Unicode and UTF-8 Objective Seek to eliminate this character set ambiguity by specifying a Universal Character Set Including over 100,000 distinct coded characters Used in all the common writing systems today UTF-8 Each character is coded by a one to four byte encoding ASCII characters require 1 byte in UTF-8 (0-127) ISO-8859 characters require 2 bytes in UTF-8 (128-2,047) CKJ characters require 3 bytes in UTF-8 (2,048-65,535) Rare characters require 4 bytes in UTF-8 (65,536-1,112,064) Strengths Encodes text in any language Encodes characters in variable-length character encoding Encodes characters with no overlap or confusion between conflicting bytes ranges THE standard encoding now Web page, XML, JSON for data transmission 9.3.6 Suggestions Always use the UTF-8 when you create your dataset Always check the encoding of the dataset When loading the dataset, always specify the encoding of the file Be very careful of the default encoding used in the applications from which the dataset is created/collected/edited (e.g., MS-Word, MS-Excel, Praat, SPSS etc.) In Mac/Linux, the default encoding for files is UTF-8; in Windows, it is NOT. Be very careful if you are a Windows user. 9.4 Character, Code Point, and Hexadecimal Mode Character: A minimal unit of text that has semantic value in the language (cf. morpheme vs. grapheme) Code Point: Any legal numeric value in the character encoding set Hexadecimal: A positional system that represents numbers using a base of 16. In R, there are a few base functions that work with these concepts: Encoding(): Read or set the declared encodings for a character vector iconv(): Convert a character vector between encodings utf8ToInt(): Convert a UTF-8 encoded character to integers (code number in decimals) as.hexamode(): Convert numbers into Hexadecimals x1 &lt;- &quot;Q&quot; Encoding(x1) ## [1] &quot;unknown&quot; ## Convert the encoding to UTF-8 x2 &lt;- iconv(x1, to = &quot;UTF-8&quot;) Encoding(x2) # ASCII chars are never marked with a declared encoding ## [1] &quot;unknown&quot; x1_decimal &lt;- utf8ToInt(x1) x1_decimal # code point of `Q` ## [1] 81 x1_hex &lt;- as.hexmode(x1_decimal) x1_hex # code point in hexadecimal mode of `Q` ## [1] &quot;51&quot; We can represent characters in UTF-8 code point (hexadecimals) by using the escape &quot;\\u....&quot;: print(&quot;\\u51&quot;) ## [1] &quot;Q&quot; The following is an example of a Chinese character. y1 &lt;- &quot;臺&quot; Encoding(y1) # Non-ASCII char encoding in R. What&#39;s the output in Windows? ## [1] &quot;UTF-8&quot; y1_decimal&lt;- utf8ToInt(y1) y1_decimal ## [1] 33274 y1_hex&lt;-as.hexmode(y1_decimal) y1_hex ## [1] &quot;81fa&quot; print(&quot;\\u81fa&quot;) ## [1] &quot;臺&quot; Exercise 9.1 What is the character of the Unicode code point (hexadecimal) U+20AC? How do you find out the character in R? Exercise 9.2 What is the Unicode code point (hexadecimal) for the character 我 and 你? Which character is larger in terms of the code points? Hexadecimal numerals are widely used by computer system designers and programmers, as they provide a human-friendly representation of binary-coded values. One single byte can encode 256 different characters, whose values may range from 00000000 to 11111111 in binary form. These binary forms can be represented as 00 to FF in hexadecimal. 9.5 R Base Functions 9.5.1 readLines() As we are often dealing with text data, we may need to import text files in R for further data processsing. In R, there is a base function readLines(), which reads a txt file with the line breaks as the delimiter and returns the content of the file as a (character) vector. That is, each line in the text will be one element in the vector. alice &lt;- readLines(con = &quot;demo_data/corp-alice.txt&quot;) alice[1:10] ## [1] &quot;[Alice&#39;s Adventures in Wonderland by Lewis Carroll 1865]&quot; ## [2] &quot;&quot; ## [3] &quot;CHAPTER I. Down the Rabbit-Hole&quot; ## [4] &quot;&quot; ## [5] &quot;Alice was beginning to get very tired of sitting by her sister on the&quot; ## [6] &quot;bank, and of having nothing to do: once or twice she had peeped into the&quot; ## [7] &quot;book her sister was reading, but it had no pictures or conversations in&quot; ## [8] &quot;it, &#39;and what is the use of a book,&#39; thought Alice &#39;without pictures or&quot; ## [9] &quot;conversation?&#39;&quot; ## [10] &quot;&quot; class(alice) ## [1] &quot;character&quot; length(alice) ## [1] 3331 Depending on how you arrange the contents in the text file, you may sometimes get a vector of different types: If each paragraph in the text file is a word, you get a word-based vector. If each paragraph in the text file is a sentence, you get a sentence-based vector. If each paragraph in the text file is a paragraph, you get a paragraph-based vector. Exercise 9.3 Based on the inspection of the vector alice created above, what is the content of each line in the original txt file (demo_data/corp-alice.txt)? 9.5.2 writeLines() After processing the data in R, we often need to save our data in an external file for future reference. For text data, we can use the base function writeLines() to save a character vector. By default, each element will be delimited by a line break after it is exported to the file. output &lt;- sample(alice[nzchar(alice)],10) writeLines(output, con = &quot;corp-alice-2.txt&quot;) Exercise 9.4 Please describe the meaning of the data processing in the code chunk above: sample(alice[nzchar(alice)],10). What did it do with the vector alice? Exercise 9.5 The above code is repeated below. How do you re-write the code using the %&gt;% pipe-based syntax with a structure provided below? Your output should be exactly the same as the output produced by the original codes. library(tidyverse) alice %&gt;% ... %&gt;% ... ... %&gt;% ... %&gt;% writeLiens(con=&quot;corp-alice-2.txt&quot;) 9.6 readr Functions 9.6.1 readr::read_csv() Another common source of data is a spreadsheet-like file, which corresponds to the data.frame in R. Usually we save these tabular data in a csv file, i.e., a comma-separated file. Although R has its own base functions for csv-files reading (e.g., read.table(), read.csv() etc.), here we will use the more powerful version read_csv() provided in the library of readr: library(readr) nobel &lt;- read_csv(&quot;demo_data/data-nobel-laureates.csv&quot;) nobel The csv file is in fact a normal plain-text file. Each line consists of a row data, with the columns separated by commas. Sometimes we may receive a dataset with other self-defined characters as the delimiter. Another often-seen case is to use the tab as the delimiter. Files with tab as the delimiter are often with the extension tsv. In readr, we can use read_tsv() to read tsv files. gender_freq &lt;- read_tsv(file = &quot;demo_data/data-stats-f1-freq.tsv&quot;) gender_freq 9.6.2 readr::write_csv() In readr, we can also export our data frames to external files, using write_csv() or write_tsv(). Exercise 9.6 Load the plain-text csv file demo_data/data-bnc-bigram.csv into a data frame and print the top 20 bigrams in the R console arranged by their frequencies (i.e., bi.freq column). Exercise 9.7 Following Exercise 9.6, please export the data frame of the top 20 bigrams to an external file, named data-bnc-bigram-10.csv, and save it under your current working directory. 9.7 Directory Operations When we work with files, we often need to deal with directories as well. It should now be clear that we need to know very well both the paths and filenames of the external data in order to properly load/save the data in R. There are a few important directory operations that we often need when working with files (import/export): getwd(): check the working directory of the current R session setwd(): set the working directory for the current R session getwd() setwd() By default, R looks for the filename or the path under the working directory unless the absolute/relative path to the files/directories is particularly specified. dir(path=&quot;demo_data&quot;, full.names = FALSE, recursive = FALSE) file.exists(&quot;demo_data/data-bnc-bigram.csv&quot;) dir(path=&quot;../../&quot;) Exercise 9.8 Please make yourself familar with the following commands: file.create(), dir.create(), unlink(), basename(),file.info(), save(), and load(). Exercise 9.9 Please create a sub-directory in your working directory, named temp. Load the dataset demo_data/data-bnc-bigram.csv and subset bigrams whose bigram frequencies (bi.freq column) are larger than 200. Order the sub data frame according to the bigram frequencies in a descending order and save the sub data frame into a csv file named data-bnc-bigram-freq200.csv in the temp directory. bnc_bigram_freq200 &lt;- read_csv(&quot;temp/data-bnc-bigram-freq200.csv&quot;) bnc_bigram_freq200 "]
]
