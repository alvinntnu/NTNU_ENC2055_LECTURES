[["data-manipulation.html", "Chapter 8 Data Manipulation 8.1 Dataset 8.2 rename() 8.3 Pipe %&gt;% 8.4 mutate() 8.5 select() 8.6 filter() 8.7 arrange() 8.8 group_by() and summarize() 8.9 count() 8.10 Tidy Data 8.11 Exerceises", " Chapter 8 Data Manipulation In this chapter, we will be working with two powerful packages, dplyr and tidyr, which provide a consistent “grammar” for data manipulation and exploration by simplifying operations on data frames to a great deal. We first load the library: library(dplyr) library(tidyr) In the library dplyr, there are a list of key verbs: %&gt;%: the “pipe” operator is used to connect multiple verb actions together into a pipeline mutate(): add new variables/columns or transform existing variables select(): return a subset of the columns of a data frame, using a flexible notation filter(): extract a subset of rows from a data frame based on logical operators summarise(): generate summary statistics of different variables in the data frame, possibly within strata group_by(): group the data frame into sub-tables according to a grouping factor arrange(): reorder rows of a data frame (according to a particular variable) rename(): rename variables in a data frame Several useful functions for joining two data frames: inner_join() left_join() right_join() full_join() anti_join() Exercise 8.1 Please check the documentations of all the above functions of merging data frames and make sure you understand how two data frames are merged with each function. In the second library tidyr, we will focus on: pivot_longer(): to tidy the data from wide to long pivot_wider(): to tidy the data from long to wide 8.1 Dataset The dateaset we use in this chapter is a student performance dataset from kaggle. library(readr) student &lt;- read_csv(&quot;demo_data/data-students-performance.csv&quot;) student Usually we would start from an overview of the dataset, using summary() and str(): summary(student) gender race/ethnicity parental level of education Length:1000 Length:1000 Length:1000 Class :character Class :character Class :character Mode :character Mode :character Mode :character lunch test preparation course math score reading score Length:1000 Length:1000 Min. : 0.00 Min. : 17.00 Class :character Class :character 1st Qu.: 57.00 1st Qu.: 59.00 Mode :character Mode :character Median : 66.00 Median : 70.00 Mean : 66.09 Mean : 69.17 3rd Qu.: 77.00 3rd Qu.: 79.00 Max. :100.00 Max. :100.00 writing score Min. : 10.00 1st Qu.: 57.75 Median : 69.00 Mean : 68.05 3rd Qu.: 79.00 Max. :100.00 str(student) spec_tbl_df [1,000 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame) $ gender : chr [1:1000] &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;male&quot; ... $ race/ethnicity : chr [1:1000] &quot;group B&quot; &quot;group C&quot; &quot;group B&quot; &quot;group A&quot; ... $ parental level of education: chr [1:1000] &quot;bachelor&#39;s degree&quot; &quot;some college&quot; &quot;master&#39;s degree&quot; &quot;associate&#39;s degree&quot; ... $ lunch : chr [1:1000] &quot;standard&quot; &quot;standard&quot; &quot;standard&quot; &quot;free/reduced&quot; ... $ test preparation course : chr [1:1000] &quot;none&quot; &quot;completed&quot; &quot;none&quot; &quot;none&quot; ... $ math score : num [1:1000] 72 69 90 47 76 71 88 40 64 38 ... $ reading score : num [1:1000] 72 90 95 57 78 83 95 43 64 60 ... $ writing score : num [1:1000] 74 88 93 44 75 78 92 39 67 50 ... - attr(*, &quot;spec&quot;)= .. cols( .. gender = col_character(), .. `race/ethnicity` = col_character(), .. `parental level of education` = col_character(), .. lunch = col_character(), .. `test preparation course` = col_character(), .. `math score` = col_double(), .. `reading score` = col_double(), .. `writing score` = col_double() .. ) 8.2 rename() The column names in student are a mess. These names include spaces in them, which would be difficult to index these columns in R. This is however normal in the real world, where the dataset we get is often very messy. So, the first thing we can do with the dataset is to rename all the column names in a R-compatible way. rename(student, race = `race/ethnicity`, parent_edu = `parental level of education`, prep_course = `test preparation course`, math = `math score`, reading = `reading score`, writing = `writing score`) -&gt; student1 student1 Please note that in our earlier code, we save the output of rename() to a new object named student1. In other words, the object student1 should contain a new data frame with all column names fixed as above. Most importantly, the original data frame student is still available in the working memory. 8.3 Pipe %&gt;% Now let’s look at a fantastic syntax in R, the pipe operator %&gt;%, which is definitely one of my favorite R idioms! To start with, the following two expressions are the same, giving you the same results: sum(c(1:10)) [1] 55 c(1:10) %&gt;% sum() [1] 55 The pipe operator %&gt;% passes the object returned by the expression on its left to the function on its right. That is, the meaning of %&gt;% is that the object on the left of the pipe is passed on to the right side of the pipe for further processing. By default, the object is passed onto to be the first argument of the function on the right-hand side. This pipe-based syntax would render the script more reader-friendly. For example, it is difficult to conceptualize the following code with several layers of embedding structures. sqrt(sum(abs(c(-10:10)))) [1] 10.48809 But the above code can be re-written with the %&gt;% as follows: source_data &lt;- c(-10:10) # create a vector source_data %&gt;% abs() %&gt;% # take each element&#39;s absolute value sum() %&gt;% # sum all elements sqrt() # take the square root of the sum [1] 10.48809 The pipe operators make the entire codes more human-readable. Now we understand the idiomatic expression of %&gt;%, our earlier rename() can be re-written as follows as well (cf. student1 and student1a): student %&gt;% rename(race = `race/ethnicity`, parent_edu = `parental level of education`, prep_course = `test preparation course`, math = `math score`, reading = `reading score`, writing = `writing score`) -&gt; student1a student1a From now on, we will use the pipe-based syntax more often. The pipe operator %&gt;% is from the library magrittr, and now is predominantly used in the tidyverse packages. However, starting from R 4.1, there is a new built-in pipe operator in base R, i.e., |&gt;: c(-10:10) |&gt; # create a vector abs() |&gt; # take each element&#39;s absolute value sum() |&gt; # sum all elements sqrt() [1] 10.48809 For more detail, you can check this YouTube clip: 8.4 mutate() Now imagine that you would like to create a new variable called final_grade, which is a weighted average of the student’s academic performance. Let us assume that you have the following weights in mind: math (50%), reading (25%), writing (25%). You can use mutate() to create a new column (i.e., variable) in your data frame: student1 %&gt;% mutate(final_grade = math*0.5 + reading*0.25 + writing*0.25) We can create more than one new variables as well: student1 %&gt;% mutate(language = reading*0.5 + writing*0.5, final_grade = math + language) In the above practices of mutate(), we did not save the output of mutate() to a new object name. We only print the output directly to the console. In order words, the original data frame is still the same (i.e., student, student1); no new variables have been created with respect to these original data frames. 8.5 select() select() is to select particular columns of the data frame that you would like to focus on. You can select just one column student1 %&gt;% select(math) Or multiple columns: student1 %&gt;% select(math, reading, writing) student1 %&gt;% select(reading, writing, math) Or columns within a range: student1 %&gt;% select(math:writing) You can also omit variables using select() student1 %&gt;% select(-c(race:lunch)) 8.6 filter() While select() is for columns, filter() is for rows. You can extract subsets of rows from a data frame. Most importantly, you can extract rows according to self-defined conditions. one logical condition student1 %&gt;% filter(math &gt; 90) AND &amp; conditions: student1 %&gt;% filter(math &lt; 40 &amp; reading &lt; 40) OR | conditions: student1 %&gt;% filter(math &lt; 40 | reading &lt; 40) XOR xor conditions: student1 %&gt;% filter(xor(math &lt; 40, reading &lt; 40)) Exercise 8.2 Please check the row numbers of the above three filtered data frames. Any connection? Please check Chapter 4.1 Vector for more logical operations. 8.7 arrange() We can arrange the rows of the data frame according to a particular variable. student1 %&gt;% arrange(math) By default, R will arrange the rows in an ascending order. If you like to arrange your data in a descending order, put a desc() around your variable name: student1 %&gt;% arrange(desc(math)) 8.8 group_by() and summarize() The group_by() function is used to generate summary statistics from the data frame within strata defined by a grouping variable. For example, in this student1 dataset, you might want to know what the average math scores are for students of different genders. In conjunction with the group_by() function we often use the summarize() function to create the summarized statistics for each subgroup (i.e., male and female). Two important steps: Split the big data frame into smaller sub data frames according to a grouping factor/variable (group_by()) Summarize each sub data frame with respect to specific parameters (summarize()) student1 %&gt;% group_by(gender) %&gt;% summarize(math_average = mean(math), math_median = median(math), math_sd = sd(math)) 8.9 count() One of the most-often used feature when we have data frames is to tally the frequencies of the subjects according to some of the columns. The function count() is born for this. For example, we can create a frequency distribution of male and female students of different parental levels of education (i.e., parent_edu x gender contingency table): student1 %&gt;% count(parent_edu, gender) Exercise 8.3 Continuing the above example, how can you create another column, which includes the percentage of male and female students for those of the same parental level education (see below)? 8.10 Tidy Data Now I would like to talk about the idea of tidy dataset. Wickham and Grolemund (2017) suggests that a tidy dataset needs to satisfy the following three interrelated rules: Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. However, in real life, we often encounter datasets that are NOT tidy at all. Instead of expecting others to do the tidying work for you (which is very unlikely), we might as well learn how to deal with messy dataset. Wickham and Grolemund (2017) suggests two common strategies data scientists often apply to the untidy dataset: One variable might be spread across multiple columns (from long to wide) One observation might be scattered across multiple rows (from wide to long) 8.10.1 An Long-to-Wide Example Here I would like to illustrate the idea of tidy dataset and also ways of tidying with a simple dataset provided in Wickham and Grolemund (2017), Chapter 12. people &lt;- tribble( ~name, ~profile, ~values, #-----------------|--------|------ &quot;Phillip Woods&quot;, &quot;age&quot;, 45, &quot;Phillip Woods&quot;, &quot;height&quot;, 186, &quot;Jessica Cordero&quot;, &quot;age&quot;, 37, &quot;Jessica Cordero&quot;, &quot;height&quot;, 156 ) people The above dataset people is not tidy because the column profile contains more than one variable. An observation (e.g., Phillip Woods) is scattered across several rows. To tidy up people, we need strategy I: One variable might be spread across multiple columns The function tidyr::pivot_wider() is made for this. There are two important parameters in pivot_wider(): names_from = ...: The column to take variable names from. Here it’s profile. values_from = ...: The column to take values from. Here it’s values. Figure 8.1: From Long to Wide: pivot_wider() require(tidyr) people %&gt;% pivot_wider(names_from = profile, values_from = values) 8.10.2 A Wide-to-Long Example preg &lt;- tribble( ~pregnant, ~male, ~female, &quot;yes&quot;, NA, 10, &quot;no&quot;, 20, 12 ) preg The above dataset preg can be tidied up as follows: we can have a column sex we can have a column pregnant we can have a column count (representing the number of observations for the combinations of sex and pregnant) In other words, we need strategy II: One observation might be scattered across multiple rows (from wide to long) (Each level combination of pregnant and sex can be one observation.) And the function tidyr::pivot_longer() is made for this. There are three important parameters: cols = ...: The set of columns whose names are values, not variables. Here they are male and female. names_to = ...: The name of the variable to move the column names to. Here it is sex. values_to = ...: The name of the variable to move the values to. Here it is count. Figure 8.2: From Wide to Long: pivot_longer() preg %&gt;% pivot_longer(cols=c(&quot;male&quot;,&quot;female&quot;), names_to = &quot;sex&quot;, values_to = &quot;count&quot;) Exercise 8.4 Please get familiar with tidyr::separate() and tidyr::unite(), which are two important functions to manipulate the columns of the data frame. 8.11 Exerceises Exercise 8.5 In the dataset demo_data/data-students-performance.csv, please load the dataset in R and print out those students who are female and whose math scores are &lt; 40. In your output, please show the following columns only: gender, math. Exercise 8.6 With the same dataset, please compute the mean scores and standard deviations of math for different races. Also, please include the number of students for each race sub-group. Exercise 8.7 With the same dataset, please create a summary data frame, which includes the number of students, math mean scores, math standard deviations, for students of different genders and parental education levels. Exercise 8.8 In terms of Parental Education Levels (i.e., parent_edu), it would be better to be coded as an ordered factor. Can you tranform the variable parent_edu into a ordered factor and regenerate the outputs requested in Exercise 8.7. Let us assume that the factor parent_edu follows the following order: some high school &lt; high school &lt; some college &lt; associate's degree &lt; bachelor's degree &lt; master's degree Exercise 8.9 Have you any ideas how to generate the following graphs using ggplot2()? Your goal is to re-create graphs that look as similar to the following as possible. Exercise 8.10 In this exercise, please first download the dataset demo_data/data-word-freq.csv. You may use readr::read_csv() to load the dataset into R. This is a dataset including word frequencies in two different corpora. For example, the word the appears 346 times in perl corpus but 229 times in python corpus. In other words, each row in word_freq in fact represents the combination of (WORD, CORPUS) because the column FREQ contains the values for those variables. In addition, the same word appears twice in the dataset in the rows (e.g., the, a). Please transform word_freq into a wider format, where the word frequencies in each corpus can be independent columns (as shown in the second table). If the word appears in only one of the corpora, its frequency would be 0. require(readr) word_freq &lt;- read_csv(&quot;demo_data/data-word-freq.csv&quot;) word_freq References "]]
