[
["subsetting.html", "Chapter 4 Subsetting 4.1 Vector 4.2 Factor 4.3 List 4.4 Data Frame 4.5 Tibble", " Chapter 4 Subsetting Subsetting is very important. To subset is to select a particular subset of elements from a data structure (e.g., vecotr, matrix, data.frame, list). In Chapter 2, we discuss very briefly about data structures. Here we will look at each type of data structure in more detail and introduce ways of subsetting them. 4.1 Vector As we have shown in Chapter 2 R Fundamentals, there are three types of primitive vectors in R: character vectors numeric vectors boolean vectors You can assess a particular subset of a vector by using[ ] right after the object name. Within the [], you can make use of at least three types of indexes: numeric vector char.vec &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;) char.vec[1] ## [1] &quot;one&quot; You can also assess several elements of a vector by putting in several indices, c(), in the []: char.vec[c(1,4)] ## [1] &quot;one&quot; &quot;four&quot; boolean vector You can also use a boolean vector as the index: whether.to.extract &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) char.vec[whether.to.extract] ## [1] &quot;one&quot; &quot;three&quot; negative numeric vector If you use negative numbers in the index [], you will get a new vector printed on the console, with those indexed elements removed: char.vec[-2] ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; However, please note that the original vector is still the same in length: char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; If you want to save the shortened vector, you can either (a) assign the shortened vector to a new object name or (b) assign the shortened vector to the same object name: char.vec.short &lt;- char.vec[-2] char.vec.short ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec &lt;- char.vec[-2] char.vec ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; For the two alternatives, which one would be better? Why? 4.2 Factor In Chapter 2, we did not talk about this data structure–factor. There is an obvious reason for that. A factor works pretty much similarly to a vector in R. One of the key features for a factor is that its values are limited to a finite number of dinstinct categories. In many statistical experimental designs, a factor is usually a grouping factor, i.e., a factor that groups the subjects into sub-groups. We usually create a factor from a numeric or character vector. To create a factor, use factor(): sbj_gender_num &lt;- c(1, 0, 0, 1, 1, 0, 1) sbj_gender_num ## [1] 1 0 0 1 1 0 1 sbj_gender_char &lt;- c(&quot;female&quot;,&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;,&quot;male&quot;,&quot;female&quot;) sbj_gender_char ## [1] &quot;female&quot; &quot;male&quot; &quot;male&quot; &quot;female&quot; &quot;female&quot; &quot;male&quot; &quot;female&quot; sbj_gender_num_fac &lt;- factor(x = sbj_gender_num) sbj_gender_num_fac ## [1] 1 0 0 1 1 0 1 ## Levels: 0 1 sbj_gender_char_fac &lt;- factor(x = sbj_gender_char) sbj_gender_char_fac ## [1] female male male female female male female ## Levels: female male For a factor, the most important information is its levels, i.e., the limit set of all possible values this factor can take. We can extract the levels as a vector of character strings using levels(): levels(sbj_gender_num_fac) ## [1] &quot;0&quot; &quot;1&quot; levels(sbj_gender_char_fac) ## [1] &quot;female&quot; &quot;male&quot; When do we need a factor? Sometimes when we do the annotation of the data, we use arbitrary numbers as labels for certain categorical labels. For example, we may use arbitrary numbers from 1 to 4 to label learners of varying proficiency levels: 1 = beginners, 2 = low-intermediate, 3 = upper-intermediate, 4 = advanced. When we read the data into R, R may first treat the data as a numeric vector: sbj_prof_num&lt;- c(1, 2, 4, 4, 2, 3, 3, 1, 1) sbj_prof_num ## [1] 1 2 4 4 2 3 3 1 1 However, these numbers may be confusing to the extent that (a) R may even consider them really to be numbers, or (b) they are not intuitive at all as numbers do not have meanings. In this case, we can create a factor from this numeric vector and re-label these numeric values into categorical labels that are more intuitive. We can do this by setting more argments in factor(), such as levels=..., labels=.... sbj_prof_fac &lt;- factor(x = sbj_prof_num, levels = c(1:4), labels = c(&quot;beginner&quot;,&quot;low-inter&quot;,&quot;upper-inter&quot;,&quot;advanced&quot;)) sbj_prof_fac ## [1] beginner low-inter advanced advanced low-inter upper-inter ## [7] upper-inter beginner beginner ## Levels: beginner low-inter upper-inter advanced levels = ...: this argument specifies all possible values this factor can take labels = ...: this argument provides own intuitive labels for each level It should now therefore be clear that labels = ... is a good way for us to re-label any artitrary annotations into meaningful labels. What’s even more brilliant is that we can decide whether the ranking of the levels is meaningful. If the order of the levels of the factor is meaningful, we can set the argument ordered = TRUE: sbj_prof_fac_ordered &lt;- factor(x = sbj_prof_num, levels = c(1:4), labels = c(&quot;beginner&quot;,&quot;low-inter&quot;,&quot;upper-inter&quot;,&quot;advanced&quot;), ordered = T) sbj_prof_fac_ordered ## [1] beginner low-inter advanced advanced low-inter upper-inter ## [7] upper-inter beginner beginner ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced Now from the R console we can see not only the levels of the factor but also the signs &lt;, indicating their order. Using this ordered factor, we can perform relational comparison: sbj_prof_fac_ordered[1] ## [1] beginner ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced sbj_prof_fac_ordered[4] ## [1] advanced ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced sbj_prof_fac_ordered[1] &lt; sbj_prof_fac_ordered[4] ## [1] TRUE But we cannot do the comparison for unordered factors (characters neither): sbj_prof_fac[1] ## [1] beginner ## Levels: beginner low-inter upper-inter advanced sbj_prof_fac[4] ## [1] advanced ## Levels: beginner low-inter upper-inter advanced sbj_prof_fac[1] &lt; sbj_prof_fac[4] ## Warning in Ops.factor(sbj_prof_fac[1], sbj_prof_fac[4]): &#39;&lt;&#39; not meaningful for ## factors ## [1] NA The difference between vectors and factors may look trivial for the moment but they are statistically very crucial. The choice of whether to instruct R to treat a vector as a factor, or even an ordered factor, will have important consequences in the implementation of many statistical methods, such as regression or othe generalized linear modeling. Rule of thumb: Always pay attention to what kind of object class you are dealing with:) 4.3 List A List is like a vector, which is a one-dimensional data structure. However, the main difference is that a List can include a series of objects of different classes: # A list consists of (i) numeric vector, (ii) character vector, (iii) boolean vector list.example &lt;- list(&quot;one&quot; = c(1,2,3), &quot;two&quot; = c(&quot;Joe&quot;, &quot;Mary&quot;, &quot;John&quot;,&quot;Angela&quot;), &quot;three&quot; = c(TRUE, TRUE)) list.example ## $one ## [1] 1 2 3 ## ## $two ## [1] &quot;Joe&quot; &quot;Mary&quot; &quot;John&quot; &quot;Angela&quot; ## ## $three ## [1] TRUE TRUE Please note that not only the class of each object in the List does not have to be the same; the length of each list element may also vary. You can subset a List in two ways: [: This always returns a List back [[: This returns the object of the List element, which is NOT NECESSARILY a List list.example[1] ## $one ## [1] 1 2 3 list.example[[1]] ## [1] 1 2 3 list.example[[&quot;one&quot;]] ## [1] 1 2 3 Before you try the following codes on the R console, could you first predict the outputs? ind &lt;- c(&quot;one&quot;, &quot;three&quot;) list.example[ind] list.example[[ind]] Exercise 4.1 Create a list that contains, in this order: a sequence of 20 evenly spaced numbers between -4 and 4; a 3 x 3 matrix of the logical vector c(F,T,T,T,F,T,T,F,F) filled column-wise; a character vector with the two strings “don”, and “quixote”; a factor containing the observations `c(“LOW”,“MID”,“LOW”,“MID”,“MID”,“HIGH”. ## [[1]] ## [1] -4.0000000 -3.5789474 -3.1578947 -2.7368421 -2.3157895 -1.8947368 ## [7] -1.4736842 -1.0526316 -0.6315789 -0.2105263 0.2105263 0.6315789 ## [13] 1.0526316 1.4736842 1.8947368 2.3157895 2.7368421 3.1578947 ## [19] 3.5789474 4.0000000 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] FALSE TRUE TRUE ## [2,] TRUE FALSE FALSE ## [3,] TRUE TRUE FALSE ## ## [[3]] ## [1] &quot;don&quot; &quot;quixote&quot; ## ## [[4]] ## [1] LOW MID LOW MID MID HIGH ## Levels: HIGH LOW MID Exercise 4.2 Based on Exercise 4.1, extract row elements 2 and 1 of columns 2 and 3, in that order, of the logical matrix. ## [,1] [,2] ## [1,] FALSE FALSE ## [2,] TRUE TRUE Exercise 4.3 Based on Exercise 4.1, obtain all values from the sequence between -4 and 4 that are greater than 1. ## [1] 1.052632 1.473684 1.894737 2.315789 2.736842 3.157895 3.578947 4.000000 Exercise 4.4 Make yourself familar with the function which. Based on Exercise 4.1, using which, determine which indexes in the factor are assigned the “MID” level. ## [1] 2 4 5 4.4 Data Frame data.frame is the most frequently used object that you will work with in data analysis. This is a typical two-dimensional spreadsheet-like table. Normally, the rows are the subjects or tokens you are analyzing; the columns are the variables or factors you are interested in. You can also use [,] to subset a data frame. The indexes in [,] are Row-by-Column. ex_df &lt;- data.frame( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34) ) ex_df You can subset a particular row of the data frame: ex_df[1,] ex_df[c(1,3),] You can subset a particular column of the data frame: ex_df[,1] ## [1] the boy you him ## Levels: boy him the you ex_df[,c(1,3)] ex_df[,c(&quot;WORD&quot;,&quot;FREQ&quot;)] Please compare the following two ways of accessing a column from the data frame. Can you tell the differences in the returned results? ex_df[, c(&quot;FREQ&quot;)] ex_df[, c(&quot;FREQ&quot;), drop = FALSE] Exercise 4.5 Create and store the following data frame as dframe in your R workspace. person should be a character vector sex should be a factor with levels F and M funny should be a factor with levels Low, Mid, and High Exercise 4.6 Stan and Francine are 41 years old, Steve is 15, Hayley is 21, and Klaus is 60. Roger is extremely old–1,600 years. Following Exercise 4.5, append these data as a new numeric column variable in dframe called age. Exercise 4.7 Following Exercise 4.6, write a single line of code that will extract frome dframe just the names and ages of any records where the individual is male and has a level of funniness equal to Low OR Mid. 4.5 Tibble tibble is a new data structure with lots of advantages. For the moment, we treat tibble and data.frame as the same, with the former being an augmented version of the latter. All functions that work of a data.frame should be compatible with a tibble. Now the tibble is the major structure that R users work with under the tidy framework. If you are new to tibbles, the best place to start is the tibbles chapter in R for data science. require(tibble) ## Loading required package: tibble ## Warning: package &#39;tibble&#39; was built under R version 3.5.2 ex_tb &lt;- tibble( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34)) ex_tb You can subset a tibble in exactly the same ways as you work with a data.frame: ex_tb[1,] ex_tb[,1] ex_tb[,c(1:3)] Exercise 4.8 Please compare again the following codes and see if you can tell the major differences between tibble and data.frame? ex_tb[,c(&quot;FREQ&quot;)] # indexing tibble ex_df[,c(&quot;FREQ&quot;)] # indexing data.frame ## [1] 1104 35 104 34 There are three major advantages with tibble() when compared with data.frame(): tibble set strings to default to character vectors while data.frame converts all character vectors to factors by default When auto-printing the contents, tibble would only display the first ten rows, but data.frame would print out everything. This could be devestating! (Imagine that you have a table with hundreds of thousands rows.) The auto-printing of the tibble is a lot more informative, providing additional attributes of the tibble such as (a) row and column numbers and (b) data type of each column "]
]
