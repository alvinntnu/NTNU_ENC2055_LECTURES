[
["subsetting.html", "Chapter 4 Subsetting 4.1 Vector 4.2 Factor 4.3 List 4.4 Data Frame 4.5 Tibble", " Chapter 4 Subsetting Subsetting is very important. To subset is to select a particular subset of elements from a data structure (e.g., vecotr, matrix, data.frame, list). In Chapter 2, we discuss very briefly about data structures. Here we will look at each type of data structure in more detail and introduce ways of subsetting them. 4.1 Vector As we have shown in Chapter 2 R Fundamentals, there are three types of primitive vectors in R: character vectors numeric vectors boolean vectors You can assess a particular subset of a vector by using[ ] right after the object name. Within the [], you can make use of at least three types of indexes: numeric vector char.vec &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;) char.vec[1] ## [1] &quot;one&quot; You can also assess several elements of a vector by putting in several indices, c(), in the []: char.vec[c(1,4)] ## [1] &quot;one&quot; &quot;four&quot; boolean vector You can also use a boolean vector as the index: whether.to.extract &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) char.vec[whether.to.extract] ## [1] &quot;one&quot; &quot;three&quot; negative numeric vector If you use negative numbers in the index [], you will get a new vector printed on the console, with those indexed elements removed: char.vec[-2] ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; However, please note that the original vector is still the same in length: char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; If you want to save the shortened vector, you can either (a) assign the shortened vector to a new object name or (b) assign the shortened vector to the same object name: char.vec.short &lt;- char.vec[-2] char.vec.short ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec &lt;- char.vec[-2] char.vec ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; For the two alternatives, which one would be better? Why? 4.2 Factor In Chapter 2, we did not talk about this data structure–factor. There is an obvious reason for that. A factor works pretty much similarly to a vector in R. One of the key features for a factor is that its values are limited to a finite number of dinstinct categories. In many statistical experimental designs, a factor is usually a grouping factor, i.e., a factor that groups the subjects into sub-groups. We usually create a factor from a numeric or character vector. To create a factor, use factor(): sbj_gender_num &lt;- c(1, 0, 0, 1, 1, 0, 1) sbj_gender_num ## [1] 1 0 0 1 1 0 1 sbj_gender_char &lt;- c(&quot;female&quot;,&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;,&quot;male&quot;,&quot;female&quot;) sbj_gender_char ## [1] &quot;female&quot; &quot;male&quot; &quot;male&quot; &quot;female&quot; &quot;female&quot; &quot;male&quot; &quot;female&quot; sbj_gender_num_fac &lt;- factor(x = sbj_gender_num) sbj_gender_num_fac ## [1] 1 0 0 1 1 0 1 ## Levels: 0 1 sbj_gender_char_fac &lt;- factor(x = sbj_gender_char) sbj_gender_char_fac ## [1] female male male female female male female ## Levels: female male For a factor, the most important information is its levels, i.e., the limit set of all possible values this factor can take. We can extract the levels as a vector of character strings using levels(): levels(sbj_gender_num_fac) ## [1] &quot;0&quot; &quot;1&quot; levels(sbj_gender_char_fac) ## [1] &quot;female&quot; &quot;male&quot; When do we need a factor? Sometimes when we do the annotation of the data, we use arbitrary numbers as labels for certain categorical labels. For example, we may use arbitrary numbers from 1 to 4 to label learners of varying proficiency levels: 1 = beginners, 2 = low-intermediate, 3 = upper-intermediate, 4 = advanced. When we read the data into R, R may first treat the data as a numeric vector: sbj_prof_num&lt;- c(1, 2, 4, 4, 2, 3, 3, 1, 1) sbj_prof_num ## [1] 1 2 4 4 2 3 3 1 1 However, these numbers may be confusing to the extent that (a) R may even consider them really to be numbers, or (b) they are not intuitive at all as numbers do not have meanings. In this case, we can create a factor from this numeric vector and re-label these numeric values into categorical labels that are more intuitive. We can do this by setting more argments in factor(), such as levels=..., labels=.... sbj_prof_fac &lt;- factor(x = sbj_prof_num, levels = c(1:4), labels = c(&quot;beginner&quot;,&quot;low-inter&quot;,&quot;upper-inter&quot;,&quot;advanced&quot;)) sbj_prof_fac ## [1] beginner low-inter advanced advanced low-inter upper-inter ## [7] upper-inter beginner beginner ## Levels: beginner low-inter upper-inter advanced levels = ...: this argument specifies all possible values this factor can take labels = ...: this argument provides own intuitive labels for each level It should now therefore be clear that labels = ... is a good way for us to re-label any artitrary annotation into meaningful labels. What’s even more brilliant is that we can decide whether the ranking of the levels is meaning. If the order of the levels of the factor is meaning, we can set the argument ordered = TRUE: sbj_prof_fac_ordered &lt;- factor(x = sbj_prof_num, levels = c(1:4), labels = c(&quot;beginner&quot;,&quot;low-inter&quot;,&quot;upper-inter&quot;,&quot;advanced&quot;), ordered = T) sbj_prof_fac_ordered ## [1] beginner low-inter advanced advanced low-inter upper-inter ## [7] upper-inter beginner beginner ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced Now from the R console we can see not only the levels of the factor but also the signs &lt;, indicating their order. Using this ordered factor, we can perform relational comparison: sbj_prof_fac_ordered[1] ## [1] beginner ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced sbj_prof_fac_ordered[4] ## [1] advanced ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced sbj_prof_fac_ordered[1] &lt; sbj_prof_fac_ordered[4] ## [1] TRUE But we cannot do the comparison for unordered factors (characters neither): sbj_prof_fac[1] ## [1] beginner ## Levels: beginner low-inter upper-inter advanced sbj_prof_fac[4] ## [1] advanced ## Levels: beginner low-inter upper-inter advanced sbj_prof_fac[1] &lt; sbj_prof_fac[4] ## Warning in Ops.factor(sbj_prof_fac[1], sbj_prof_fac[4]): &#39;&lt;&#39; not meaningful for ## factors ## [1] NA The difference between vectors and factors may look trivial for the moment but they are statistically very crucial. The choice of whether to instruct R to treat a vector as a factor, or even an ordered factor, will have important consequences in the implementation of many statistical methods, such as regression or othe generalized linear modeling. Rule of thumb: Always pay attention to what kind of object class you are dealing with:) 4.3 List A List is like a vector, which is a one-dimensional data structure. However, the main difference is that a List cna include a series of objects of different classess: # A list consists of (i) numeric vector, (ii) character vector, (iii) boolean vector list.example &lt;- list(&quot;one&quot; = c(1,2,3), &quot;two&quot; = c(&quot;Joe&quot;, &quot;Mary&quot;, &quot;John&quot;,&quot;Angela&quot;), &quot;three&quot; = c(TRUE, TRUE)) list.example ## $one ## [1] 1 2 3 ## ## $two ## [1] &quot;Joe&quot; &quot;Mary&quot; &quot;John&quot; &quot;Angela&quot; ## ## $three ## [1] TRUE TRUE Please note that not only the class of each object in the List does not have to be the same; the length of each object may also vary. You can subset a List in two ways: [: This always returns a List back [[: This returns the object of the List element, which is NOT NECESSARILY a List list.example[1] ## $one ## [1] 1 2 3 list.example[[1]] ## [1] 1 2 3 list.example[[&quot;one&quot;]] ## [1] 1 2 3 Please try the following codes but before you try them on the R console, could you first predict the outputs? ind &lt;- c(&quot;one&quot;, &quot;three&quot;) list.example[ind] list.example[[ind]] 4.4 Data Frame data.frame is the most frequently used object that you will work with in data analysis. This is a typical two-dimensional spreadsheet-like table. Normally, the rows are the subjects or tokens you are analyzing; the columns are the variables or factors you are interested in. You can also use [,] to subset a data frame. The indexes in [,] are Row-by-Column. ex_df &lt;- data.frame( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34) ) ex_df WORD POS FREQ the ART 1104 boy N 35 you PRO 104 him PRO 34 You can subset a particular row of the data frame: ex_df[1,] ex_df[c(1,3),] You can subset a particular column of the data frame: ex_df[,1] ## [1] the boy you him ## Levels: boy him the you ex_df[,c(1,3)] ex_df[,c(&quot;WORD&quot;,&quot;FREQ&quot;)] Please compare the following two ways of accessing a column from the data frame. Can you tell the differences in the returned results? ex_df[, c(&quot;FREQ&quot;)] ex_df[, c(&quot;FREQ&quot;), drop = FALSE] 4.5 Tibble tibble is a new data structure with lots of advantages. For the moment, we treat tibble and data.frame as the same, with the former being an augmented version of the latter. All functions that work of a data.frame should be compatible with a tibble. Now the tibble is the major structure that R users work with under the tidy framework. If you are new to tibbles, the best place to start is the tibbles chapter in R for data science. require(tibble) ## Loading required package: tibble ## Warning: package &#39;tibble&#39; was built under R version 3.5.2 ex_tb &lt;- tibble::tibble( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34)) ex_tb You can subset a tibble in exactly the same ways as you work with a data.frame: ex_tb[1,] ex_tb[,1] ex_tb[,c(1:3)] Exercise 4.1 Please compare again the following codes and see if you can tell the major differences between tibble and data.frame? ex_tb[,c(&quot;FREQ&quot;)] ex_df[,c(&quot;FREQ&quot;)] ## [1] 1104 35 104 34 There are three major advantages with tibble() when compared with data.frame(): tibbles default to character vectors while data.frames convert all character vectors to factors by default the auto-printing the content of the tibble would only display the first ten rows; with a data.frame, the object name prints out everything. This could be devestating! (Imagine that you have a table with hundreds of thousands rows.) the auto-printing of the tibble is a lot more informative, providing additional attributes of the tibble such as (a) row and column numbers and (b) data type of each column "]
]
