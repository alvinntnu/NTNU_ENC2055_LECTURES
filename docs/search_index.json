[
["index.html", "ENC2055: Introduction to Programming Languages for Linguistic Analysis Preface Course Objective Textbook Course Website Course Demo Data", " ENC2055: Introduction to Programming Languages for Linguistic Analysis Alvin Chen 2019-12-06 Preface Welcome to ENC2055. This is a grad-level course tailored to those who are interested in computational text analytics and data science in general. Have you decided to embark upon a digital journey to your future career, there are a series of courses provided in the Department of English, NTNU, Taiwan, offerring necessary skills and knowledge in important disciplines. This introductory course in basic computational coding would be a prerequisite course for many other advance-level courses. Also, our Linguistics group is dedicated to linguistics in particular. Course Objective The objective of this course is to provide a comprehensive introduction to programming languages with a special focus on its application in linguistic analyses. This course is especially tailored to those who do not have any background or experiences in coding. We will start from the very basic concepts, such as data types, variable assignments, control structures, to more complex procedures such as routines, functions, and project-based tasks. The course will consist of a series of theme-based hands-on tutorials, which demonstrate how the flexibility of the programming language can help you become a more efficient and productive data scientist. Specifically, this course will use the language R as our featuring programming language and introduce you to R, Rstudio, and a collection of R packages designed to work together to make linguistic analyses fast, fluent, and fun.By the end of the course, students should have a working knowledge of coding and an ability to read another programmer’s code. In this course, we will not be dealing with complex maths like: \\[ f(x)=\\frac{1}{\\sqrt{2 \\pi}} e^{-\\frac{1}{2} x^{2}} \\] \\[ P(A) = \\sum P(\\{ (e_1,\\dotsc,e_N) \\}) = \\binom{N}{k} \\cdot p^kq^{N-k} \\] Intead, we will have more experiences with coding: library(tidyverse) summary_monthly_temp &lt;- weather %&gt;% group_by(month) %&gt;% summarize(mean = mean(temp), std_dev = sd(temp)) Textbook We will not use a particular textbook for the course. However, I do like to recommend Wickham and Grolemund (2017) for its simplicity. Also, another great book for R lovers, by Davies (2016): Course Website We have a course website. You may need a password to get access to the course materials. If you are an officially enrolled student, please ask the instructor for the access code. Course Demo Data Dropbox Demo Data Directory References "],
["intro-ds.html", "Chapter 1 Data Science and R 1.1 What is Data Science? 1.2 Working Pipeline for Data Science 1.3 Why R? 1.4 tidyverse 1.5 More Skills", " Chapter 1 Data Science and R 1.1 What is Data Science? Data Science is an interdisciplinary subject, which integrates knowledge of statistics, computer science and other domina-specific areas. A graph by Drew Conway may summarize the essense of Data Science: 1.2 Working Pipeline for Data Science Hadley Wickham’s R for Data Science describes six important steps for data analysis: 1.3 Why R? According to a report by KDnuggets, among all the languages used by data scientists, python and R are the most popular two languages: It is true that Python now seems much more popular among developers. That being said, you may consult this article, &lt;&lt; Why R is the Best Data Science Language to Learn Today? &gt;&gt;, for a more comprehensive review of the strengths of R. The general tendency is that: if you want to go into the industry and take developers or programmers as your future career, you can choose python; if you are going to locate yourself in the academia, I would definitely recommend R. Here are a list of strengths for R language: powerful statistical analysis data visualization exploratory analysis re-usable reports tidyverse consistent grammar/syntax high readability of the codes, similar to human languages ( %&gt;% is a unique R feature!) In this course, our main objective is to introduce you to the world of coding. A high-level programming language like R would be a very friendly start, especially for those who have no background of computing. So, let us enjoy the journey of a simple yet powerful language learning! 1.4 tidyverse In this course, we will be working on a collection of packages included in tidyverse. This is a unique package in R, which can help you deal with data in a massively convenient way. It is hoped that the user can easily call particular functions and make use of the pipe operator %&gt;% to concatenate all your procedures serially, just like our natural languages. In particular, we will work on the following major libraries included in tidyverse: ggplot2: Data visualization dplyr: Data wrangling tidyr: Data wrangling stringr: String manipulation readr: Data importing purrr: Functional programming to avoid loops tibble: Powerful data structure 1.5 More Skills Data scientists are now becoming more and more popular. To know more about this job, one thing you may want to know is what kinds of skills are needed? The following two graphs were taken from &lt;The Most in Demand Skills for Data Scientists&gt;: "],
["r-fundamentals.html", "Chapter 2 R Fundamentals 2.1 Installing R 2.2 Installing RStudio 2.3 The Interface of Rstudio 2.4 Assignment 2.5 Data Structure 2.6 Function 2.7 Script 2.8 Library 2.9 Setting 2.10 Seeking Help 2.11 Language Learning Ain’t Easy! 2.12 Keyboard Shortcuts", " Chapter 2 R Fundamentals Download R: R-Project IDE: RStudio Tutorials: Online Learning 2.1 Installing R Download the install file: http://cran.r-project.org 2.2 Installing RStudio After you install R, you may install RStudio. RStudio is an editor which can help you write R codes. A good analogy is that R is the engine and Rstudio is the dashboard of the car. Please download the right version that is compatible with your PC operating system. https://www.rstudio.com/download Choose RStudio Desktop Important notes: Do not have Chinese characters in your directory names or on the path to the files Do not have spaces and weird symbols in your file path: D:/R D:/Rstudio /User/Alvinchen/ 2.3 The Interface of Rstudio When you start Rstudio, you will see an interface as follows: Rstudio Interface: Editor: You creat and edit our R-related files here (e.g., *.r, *.Rmd etc.) Console: This is the R engine, which runs the codes we send out either from the file or directly from the console input Output: You can view graphic outputs here The R console is like a calculator. You can type any R code in the console after the prompt &gt; and run the code line by line by pressing enter. All the above examples ask R to run lines of codes and print the results directly in the console. 1 + 1 ## [1] 2 log(10) ## [1] 2.302585 1:5 ## [1] 1 2 3 4 5 2.4 Assignment You can assign any object created in R to a variable using &lt;-: x &lt;- 5 y &lt;- &quot;wonderful&quot; Now the objects are stored in the variables. You can print out the varialbes by either making use of the auto-printing (i.e., the variable itself auto-prints its content) or print(): x ## [1] 5 print(x) ## [1] 5 y ## [1] &quot;wonderful&quot; print(y) ## [1] &quot;wonderful&quot; 2.5 Data Structure In R, the most primitive object is a vector. There are two types of primitive vectors: (a) numeric and (b) character vectors. In our previous examples, x is a numeric vector of one element; y is a character vector of one element. All elements in the factor have to be of the same data type. You use c() to create a vector of multiple elments. Within the parenthesis, you concatenate each element of the vector by ,: x2 &lt;- c(1, 2, 3, 4, 5, 6) x2 ## [1] 1 2 3 4 5 6 y2 &lt;- c(&quot;wonderful&quot;, &quot;excellent&quot;, &quot;brilliant&quot;) y2 ## [1] &quot;wonderful&quot; &quot;excellent&quot; &quot;brilliant&quot; Data structures that you often work with include: List: Data Frame: Matrix ex_list &lt;- list(&quot;First element&quot;, 5:10, TRUE) print(ex_list) ## [[1]] ## [1] &quot;First element&quot; ## ## [[2]] ## [1] 5 6 7 8 9 10 ## ## [[3]] ## [1] TRUE ex_array &lt;- matrix(c(1,5,6,3,8,19),byrow = T, nrow = 2) ex_array ## [,1] [,2] [,3] ## [1,] 1 5 6 ## [2,] 3 8 19 ex_df &lt;- data.frame( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34) ) ex_df 2.6 Function 2.7 Script Earlier you run R codes by entering each procedure line by line. You can also include all our R codes in one script file, which usually has the file extension of .R. And then you can run the whole script all at once in the Rstudio. First you open the *.R script file in Rstudio, which should appear in the Editor frame of the Rstudio. To run the whole script from start to the end, select all lines in the script file and press ctrl/cmd + shift + enter. To run a particular line of the script, put your mouse in the line and press ctrl/cmd + enter. 2.8 Library R, like other programming languages, comes with a huge database of packages and extensions, allowing us to do many different tasks without worrying about writing the codes all from the scratch. In CRAN Task Views, you can find relevant packages relevant to a specific topic or task. To install a package (i.e., library): install.packages(&quot;tidyverse&quot;) install.packages(c(&quot;ggplot2&quot;, &quot;devtools&quot;, &quot;dplyr&quot;)) 2.9 Setting Always set your default encoding of the files to UTF-8: 2.10 Seeking Help In the process of (learning) programming, one thing you will never be able to dodge is a strong desire for help. Here are the sources you may seek help. Within Rstudio, in the R console, you can always use ? to check the documentation of a particular function. When you run the command, you will see the documentation popping up in the output frame of the Rstudio. ?log ?read.table Figure 2.1: Help 1 If you need help from others, the first step is to create a reproducible example. The goal of a reproducible example is to package your problematic code in such a way that other people can run it and feel your pain. Then, hopefully, they can provide a solution and put you out of your misery. Figure 2.2: Help 2 So before you seek help from others (or before you yell at others for help, cf. Figure 2.2) : First, you need to make your code reproducible. This means that you need to capture everything, i.e., include any library() calls and create all necessary objects (e.g., files). The easiest way is to check the objects listed in the Environment tab of the Rstudio and identify objects that are relevant to your problematic code chunk. Second, you need to make it minimal. Strip away everything that is not directly related to your problem. This usually involves creating a much smaller and simpler R object than the one you’re facing in real life or even using built-in data. That sounds like a lot of work! And it can be, but it has a great payoff: 80% of the time creating an excellent reprex reveals the source of your problem. It’s amazing how often the process of writing up a self-contained and minimal example allows you to answer your own question. The other 20% of time you will have captured the essence of your problem in a way that is easy for others to play with. This substantially improves your chances of getting help! The following is a list of resources where people usually get external assistance quickly: http://www.r-project.org/mail.html http://stackoverflow.com/ Quick R: http://www.statmethods.net/ R CRAN Task Views: https://cran.r-project.org/web/views/ R for Data Science Text Mining with R R communities: R-Bloggers: https://www.r-bloggers.com/ kaggle: https://www.kaggle.com/ stackoverflow: https://stackoverflow.com/questions/tagged/r rstudio: https://community.rstudio.com/ 2.11 Language Learning Ain’t Easy! Learning R is like learning another foreign language. It should be a long journey. You can’t expect yourself to learn all the vocabuary of the new language in one day. Also, you will forget things you learn all the time. Everyone’s been there. When your script does not work as expected, don’t be frustrated. Take a break and resume later. What I can say is that: it is always NORMAL to debug a script for hours or even days via endless searches on Google. That being said, here I would like to share with you some of the most common problems R may usually run int: You created an R script file (*.r) and opened it in the Rstudio, but the script didn’t work simply because you didn’t execute the script in R console (i.e., you didn’t send the script to R console.) If you get an error message, saying &quot;object not found&quot;, check the object name again and see if you have mistyped the name of the object. If not, check your current environment and see if you have fotgot to execute some assignment commands in the previous parts of the script (i.e., the object has NOT even been created yet). If you get an error message, saying &quot;function not found&quot;, check the function and see if you have the correct name. Or more ofte, check if you have **loaded&quot; the necessary libraries where the function is defined. To understand the meaning of the error messages is crucial to your development of R proficiency. To achieve this, you have to know very well every object name you have created in your script (as well as your environment). For example: What type of object is it? (i.e., the class of the object, e.g., vector, list, data.frame?) For primitive vectors, what type of vector is it? (e.g., numeric, character, boolean,factor?) What is the dimensionality of the object? (nrows, ncols?) Sometimes the script fails due to the syntactic errors. Pay attention to all the punctuations in every R command. They are far more important (or lethal) than you think. They include: ,: commas between arguments inside a function &quot;: quotes for strings/characters (): parentheses for functions {}: curly brackets for control structures From my experiences, about 80 percent of the errors may in the end boil down to a simple typo. No kidding. Copy-and-paste helps. DO NOT assume that your R script always works as intended! Always keep two questions in mind: Did R produce the intended result? What is included in the R object? 2.12 Keyboard Shortcuts The best way to talk to a computer is via the keyboard. Scripting requires a lot of typing. Keyboard shortcuts may save you a lot of time. Here are some of the handy shortcuts: Crtl/Command + Enter: run the current line (send from the script to the console) Crtl/Command + A: select all Crtl/Command + C: copy Ctrl/Command + X: cut Ctrl/Command + V: paste Ctrl/Command + Z: undo (Mac) Alt/Option + Left/Right: move cursor by a word (Windows) Ctrl + Left/Right: move cursor by a word (Mac) Command + Left/Right: move cursor to the beginning/end of line (Windows) Home/End: move cursor to the beginning/end of line (Mac) Command + Tab: switch in-between different working windows/apps Ctrl/Command + S: save file Command + Shift + C: comment/uncomment selected lines "],
["subsetting.html", "Chapter 3 Subsetting 3.1 Vecotr 3.2 List 3.3 Data Frame 3.4 Tibble", " Chapter 3 Subsetting Subsetting is very important. To subset is to select a particular subset of elements from a data structure (e.g., vecotr, matrix, data.frame, list). 3.1 Vecotr As we have shown in Chapter 2 R Fundamentals, there are three types of primitive vectors in R: character vectors numeric vectors boolean vectors You can assess a particular subset of a vector by using[ ] right after the object name. Within the [], you can make use of at least three types of indexes: numeric vector char.vec &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;) char.vec[1] ## [1] &quot;one&quot; You can also assess several elements of a vector by putting in several indices, c(), in the []: char.vec[c(1,4)] ## [1] &quot;one&quot; &quot;four&quot; boolean vector You can also use a boolean vector as the index: whether.to.extract &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) char.vec[whether.to.extract] ## [1] &quot;one&quot; &quot;three&quot; negative numeric vector If you use negative numbers in the index [], you will get a new vector printed on the console, with those indexed elements removed: char.vec[-2] ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; However, please note that the original vector is still the same in length: char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; If you want to save the shortened vector, you can either (a) assign the shortened vector to a new object name or (b) assign the shortened vector to the same object name: char.vec.short &lt;- char.vec[-2] char.vec.short ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec &lt;- char.vec[-2] char.vec ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; For the two alternatives, which one would be better? Why? 3.2 List A List is like a vector, which is a one-dimensional data structure. However, the main difference is that a List cna include a series of objects of different classess: # A list consists of (i) numeric vector, (ii) character vector, (iii) boolean vector list.example &lt;- list(&quot;one&quot; = c(1,2,3), &quot;two&quot; = c(&quot;Joe&quot;, &quot;Mary&quot;, &quot;John&quot;,&quot;Angela&quot;), &quot;three&quot; = c(TRUE, TRUE)) list.example ## $one ## [1] 1 2 3 ## ## $two ## [1] &quot;Joe&quot; &quot;Mary&quot; &quot;John&quot; &quot;Angela&quot; ## ## $three ## [1] TRUE TRUE Please note that not only the class of each object in the List does not have to be the same; the length of each object may also vary. You can subset a List in two ways: [: This always returns a List back [[: This returns the object of the List element, which is NOT NECESSARILY a List list.example[1] ## $one ## [1] 1 2 3 list.example[[1]] ## [1] 1 2 3 list.example[[&quot;one&quot;]] ## [1] 1 2 3 Please try the following codes but before you try them on the R console, could you first predict the outputs? ind &lt;- c(&quot;one&quot;, &quot;three&quot;) list.example[ind] list.example[[ind]] 3.3 Data Frame data.frame is the most frequently used object that you will work with in data analysis. This is a typical two-dimensional spreadsheet-like table. Normally, the rows are the subjects or tokens you are analyzing; the columns are the variables or factors you are interested in. You can also use [,] to subset a data frame. The indexes in [,] are Row-by-Column. ex_df &lt;- data.frame( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34) ) ex_df WORD POS FREQ the ART 1104 boy N 35 you PRO 104 him PRO 34 You can subset a particular row of the data frame: ex_df[1,] ex_df[c(1,3),] You can subset a particular column of the data frame: ex_df[,1] ## [1] the boy you him ## Levels: boy him the you ex_df[,c(1,3)] ex_df[,c(&quot;WORD&quot;,&quot;FREQ&quot;)] Please compare the following two ways of accessing a column from the data frame. Can you tell the differences in the returned results? ex_df[, c(&quot;FREQ&quot;)] ex_df[, c(&quot;FREQ&quot;), drop = FALSE] 3.4 Tibble tibble is a new data structure with lots of advantages. For the moment, we treat tibble and data.frame as the same, with the former being an augmented version of the latter. All functions that work of a data.frame should be compatible with a tibble. Now the tibble is the major structure that R users work with all the time. If you are new to tibbles, the best place to start is the tibbles chapter in R for data science. require(tibble) ## Loading required package: tibble ## Warning: package &#39;tibble&#39; was built under R version 3.5.2 ex_tb &lt;- tibble::tibble( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34)) ex_tb You can subset a tibble in exactly the same ways as you work with a data.frame: ex_tb[1,] ex_tb[,1] ex_tb[,c(1:3)] Please compare again the following codes and see if you can tell the major differences between tibble and data.frame? ex_tb[,c(&quot;FREQ&quot;)] ex_df[,c(&quot;FREQ&quot;)] "],
["data-visualization.html", "Chapter 4 Data Visualization 4.1 Why Visualization? 4.2 ggplot2 4.3 One-variable Graph 4.4 Two-variable Graph 4.5 Adding Other Aesthetic Features 4.6 Saving Plots", " Chapter 4 Data Visualization 4.1 Why Visualization? Data visualization is very important. I would like to illustrate this point with two interesting examples. First, let us take a look at an interesting dataset datasaurus.csv: Table 4.1: An Interesting Dataset group x y dino 95.38460 36.794900 dino 98.20510 33.718000 away 91.63996 79.406603 away 82.11056 1.210552 h_lines 98.28812 30.603919 h_lines 95.24923 30.459454 v_lines 89.50485 48.423408 v_lines 89.50162 45.815179 x_shape 84.84824 95.424804 x_shape 85.44619 83.078294 star 82.54024 56.541052 star 86.43590 59.792762 high_lines 92.24840 32.377154 high_lines 96.08052 28.053601 dots 77.92604 50.318660 dots 77.95444 50.475579 circle 85.66476 45.542753 circle 85.62249 45.024166 bullseye 91.72601 52.623353 bullseye 91.73554 48.970211 slant_up 92.54879 42.901908 slant_up 95.26053 46.008830 slant_down 95.44349 36.189702 slant_down 95.59342 33.234129 wide_lines 77.06711 51.486918 wide_lines 77.91587 45.926843 We group the dataset by group and for each group we computate the mean scores and standard deviations of x and y. According to the summary statistics of each group, they look indeed similar: Table 4.2: An Interesting Dataset - Summary group x_fn1 y_fn1 x_fn2 y_fn2 away 54.266 47.835 16.770 26.940 bullseye 54.269 47.831 16.769 26.936 circle 54.267 47.838 16.760 26.930 dino 54.263 47.832 16.765 26.935 dots 54.260 47.840 16.768 26.930 h_lines 54.261 47.830 16.766 26.940 high_lines 54.269 47.835 16.767 26.940 slant_down 54.268 47.836 16.767 26.936 slant_up 54.266 47.831 16.769 26.939 star 54.267 47.840 16.769 26.930 v_lines 54.270 47.837 16.770 26.938 wide_lines 54.267 47.832 16.770 26.938 x_shape 54.260 47.840 16.770 26.930 So you may conclude that all groups show similar behaviors in x and y measures. But what if we plot all subjects by groups? See? What you see is sometimes NOT what you believe. Another example is Simpson’s Paradox, which occurs when trends that appear when a dataset is separated into groups reverse when the data are aggregated. Based on the above graph, you would probably conclude that when x increases, y decreases. However, if you plot the scatter plots by groups, you may get the opposite conclusions. All correlations between x and y in all groups are now positive. 4.2 ggplot2 R is famous for its power in data visualization. So why don’t we delve right into this beauty in R? In this chapter, we will introduce you a very powerful graphic library in R, ggplot2. For any data visualization, there are three basic elements: Data: The raw material of your visualization, i.e., a data frame. Aesthetics: The mapping of your data to aesthetic attributes, such as x, y, color, linetype, fill. Geometric Objects: The layers of geometric objects you would like to see on the plots, e.g., lines, points etc. I will demonstrate some basic functions of ggplot2, with the pre-loaded dataset mpg: library(tidyverse) mpg model: manufacturer model name displ: engine displacement, in litres (排氣量) hwy: highway miles per gallon cty: city miles per gallon cyl: number of cylinders (汽缸數目) class: car type We can look at the relation between displ and hwy: ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() ggplot() initializes the basic frame of the graph, with data = mpg specifying the data frame on which the plot is built aes() further specifies the mapping of axises and the factors in the data frame. aes(x = displ, y = hwy) indicates that displ is mapped as the x axis and hwy as y axis + means that you want to add one layer of the graph to the template. geom_point() means that you want to add a layer of point graph. 4.3 One-variable Graph Continuous variable ggplot(data = mpg, aes(hwy)) + geom_density(kernel=&quot;gaussian&quot;) ggplot(data = mpg, aes(hwy)) + geom_histogram() Categorical variable ggplot(data = mpg, aes(x = class)) + geom_bar() 4.4 Two-variable Graph Continuous X, Continuous Y ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() Discrete X, Continuous Y ggplot(data = mpg, aes(x = class, y = hwy)) + geom_boxplot() Discrete X, Discrete Y ggplot(data = mpg, aes(x = manufacturer, y = class)) + geom_count() + theme(axis.text.x = element_text(angle=-90)) 4.5 Adding Other Aesthetic Features Now I would like to demonstrate how we can add additional aesthetic mappings to your graphs. You can add color = ... in the aes() to creat the graphs on the basis of a grouping factor We can introduce a third variable into the plot by modifying the color of the points based on the value of that third variable. Color is an aesthetic and the color of each point can be mapped to a variable. Note that the x-coordinates and y-coordinates are aesthetics too, and they got mapped to the displ and hwy variables, respectively. In this case we will map the color to the drv variable which indicates whether a car is front wheel drive, rear wheel drive, or 4-wheel drive. ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() We can also add another geom object, such as a smooth line: ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth() Could you predict what kind of graph you would get with the following code? ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + geom_smooth() We can add texts and labels as well ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + labs(x = &quot;Engine Displacement (litres)&quot;, y = &quot;Highway Miles per Gallon&quot;, title = &quot;Scatter Plot -- DISPL by HWY&quot;) 4.6 Saving Plots Saving a ggplot can be easily done by ggsave(). You can first save a ggplot object to a variable and then use ggsave() to output the ggplot object to an external file. It is recommended to use common image formats for publications, e.g., png, jpg. my_first_graph &lt;- ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + labs(x = &quot;Engine Displacement (litres)&quot;, y = &quot;Highway Miles per Gallon&quot;, title = &quot;Scatter Plot -- DISPL by HWY&quot;) class(my_first_graph) # check the class ## [1] &quot;gg&quot; &quot;ggplot&quot; my_first_graph # auto-print the ggplot ggsave(filename = &quot;my_first_plot.png&quot;,plot = my_first_graph, width = 6, height = 6) "],
["data-manipulation.html", "Chapter 5 Data Manipulation 5.1 Dataset 5.2 rename() 5.3 Pipe %&gt;% 5.4 mutate() 5.5 select() 5.6 filter() 5.7 arrange() 5.8 group_by() and summarize() 5.9 left_join() 5.10 Exerceises", " Chapter 5 Data Manipulation In this chapter, we will be working with a powerful package, dplyr, which provides a consistent “grammar” for data manipulation and exploration by simplifying operations on data frames to a great deal. We first load the library: library(dplyr) In this library, there are a list of key verbs: mutate(): add new variables/columns or transform existing variables %&gt;%: the “pipe” operator is used to connect multiple verb actions together into a pipeline select(): return a subset of the columns of a data frame, using a flexible notation filter(): extract a subset of rows from a data frame based on logical conditions summarise(): generate summary statistics of different variables in the data frame, possibly within strata group_by(): group the data frame into sub-tables according to a grouping factor arrange(): reorder rows of a data frame rename(): rename variables in a data frame left_join(): merge the data frame with another data frame 5.1 Dataset The dateaset we use in this chapter is a student performance dataset from kaggle. library(readr) student &lt;- read_csv(&quot;demo_data/StudentsPerformance.csv&quot;) student Usually we would start from an overview of the dataset: summary(student) ## gender race/ethnicity parental level of education ## Length:1000 Length:1000 Length:1000 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## lunch test preparation course math score reading score ## Length:1000 Length:1000 Min. : 0.00 Min. : 17.00 ## Class :character Class :character 1st Qu.: 57.00 1st Qu.: 59.00 ## Mode :character Mode :character Median : 66.00 Median : 70.00 ## Mean : 66.09 Mean : 69.17 ## 3rd Qu.: 77.00 3rd Qu.: 79.00 ## Max. :100.00 Max. :100.00 ## writing score ## Min. : 10.00 ## 1st Qu.: 57.75 ## Median : 69.00 ## Mean : 68.05 ## 3rd Qu.: 79.00 ## Max. :100.00 5.2 rename() The column names in student are a mess. These names include spaces in them, which would be difficult to index these columns in R. This is however normal in the real world, where the dataset we get is often very messy. So, the first thing we can do with the dataset is the rename all the column names in a R-compatible way. rename(student, race = `race/ethnicity`, parent_edu = `parental level of education`, prep_course = `test preparation course`, math = `math score`, reading = `reading score`, writing = `writing score`) -&gt; student1 student1 Please note that in our earlier code, we save the output of rename() to a new object named student1. In other words, the object student1 should contain a new data frame with all column names fixed as above. 5.3 Pipe %&gt;% Now let’s look at a fantastic syntax in R, the pipe %&gt;%, which is definitely one of my favorite R idioms! To start with, the following two expressions are the same, giving you the same results: sum(c(1:10)) ## [1] 55 c(1:10) %&gt;% sum ## [1] 55 The meaning of %&gt;% is that the object on the left of the pipe is passed on to the right side of the pipe for further processing. By default, the object is passed onto to be the first argument of the function on the right-hand side. This pipe-based syntax would render the script more reader-friendly. For example, is it easy to guess the output of the following code? sqrt(sum(abs(c(-10:10)))) ## [1] 10.48809 But the above code can be re-written with the %&gt;% as follows: c(-10:10) %&gt;% abs %&gt;% sum %&gt;% sqrt ## [1] 10.48809 Now we understand the idiomatic expression of %&gt;%, our earlier rename() can be re-written as follows as well (cf. student1 and student): student %&gt;% rename(race = `race/ethnicity`, parent_edu = `parental level of education`, prep_course = `test preparation course`, math = `math score`, reading = `reading score`, writing = `writing score`) -&gt; student1a student1a From now on, we will use the pipe-based syntax more often. 5.4 mutate() Now imagine that you would like to create a new variable called final_grade, which is a weighted average of the student’s academic performance. Let us assume that you have the following weights in mind: math (50%), reading (25%), writing (25%). You can use mutate() to create a new column (i.e., variable) in your data frame: student1 %&gt;% mutate(final_grade = math*0.5 + reading*0.25 + writing*0.25) We can create more than one new variables as well: student1 %&gt;% mutate(language = reading*0.5 + writing*0.5, final_grade = math + language) In the above practices of mutate(), we did not save the output of mutate() to a new object. We only print the output directly to the console. In order words, the original data frame is still the same (i.e., student, student1); no new variables have been created wrt to these original data frames. 5.5 select() select() is to select particular columns of the data frame that you would like to focus on. You can select just one column student1 %&gt;% select(math) Or multiple columns: student1 %&gt;% select(math, reading, writing) Or columns within a range: student1 %&gt;% select(math:writing) You can also omit variables using select() student1 %&gt;% select(-c(race:lunch)) 5.6 filter() While select() is for columns, filter() is for rows. You can extract subsets of rows from a data frame. Most importantly, you can extract rows according to self-defined conditions. one logical condition student1 %&gt;% filter(math &gt; 90) AND &amp; conditions: student1 %&gt;% filter(math &lt; 40 &amp; reading &lt; 40) OR | conditions: student1 %&gt;% filter(math &lt; 40 | reading &lt; 40) XOR xor conditions: student1 %&gt;% filter(xor(math &lt; 40, reading &lt; 40)) Please check the row numbers of the above three filtered data frames. Any connection? 5.7 arrange() We can arrange the rows of the data frame according to a particular variable. student1 %&gt;% arrange(math) By default, R will arrange the rows in an ascending order. If you like to arrange your data in a descending order, put a desc() around your variable name: student1 %&gt;% arrange(desc(math)) 5.8 group_by() and summarize() The group_by() function is used to generate summary statistics from the data frame within strata defined by a grouping variable. For example, in this student1 dataset, you might want to know what the average math scores are for students of different genders. In conjunction with the group_by() function we often use the summarize() function to create the summarized statistics. The general operation here is a combination of splitting a data frame into separate pieces defined by a variable or group of variables (group_by()), and then applying a summary function across those subsets (summarize()). student1 %&gt;% group_by(gender) %&gt;% summarize(math_average = mean(math), math_median = median(math), math_sd = sd(math)) 5.9 left_join() 5.10 Exerceises Exercise 5.1 In the dataset demo_data/StudentsPerformance.csv, please read in the dataset and print out those students who are female and whose math scores are &lt; 40. In your output, please show the following columns only: gender, math. Exercise 5.2 With the same dataset, please compute the mean scores and standard deviations of math for different races. Also, please include the number of students for each race sub-group. Exercise 5.3 With the same dataset, please create a summary, which includes the number of students, math mean scores, math standard deviations, for students of different genders and parental education levels. Exercise 5.4 (Bonus) Have you any ideas how to generate the following graphs using ggplot2()? "],
["data-import.html", "Chapter 6 Data Import 6.1 readLines() 6.2 read_csv() 6.3 Structured Data: XML", " Chapter 6 Data Import 6.1 readLines() 6.2 read_csv() 6.3 Structured Data: XML "],
["string-manipulation.html", "Chapter 7 String Manipulation 7.1 What is Regular Expression? 7.2 String Basics 7.3 Regular Expression Grammar 7.4 Pattern Matching 7.5 Advanced Pattern Matching: Look Ahead and Behind 7.6 Practical Cases", " Chapter 7 String Manipulation In this chapter, we will introduce some techniques relating to string manipulation. library(tidyverse) library(stringr) 7.1 What is Regular Expression? In text processing, we often do “find” and “replace” in our documents. I am sure that you do this very often in MS-Word or MS-Excel. Regular expression is a language, which allows us to create a textual pattern and use this pattern to match other strings with the same pattern for later processing. This idea of one-pattern-for-multiple-matches is the beauty of regular expression. Several advantages of regular expressions are self-evident: Complicated pattern matching e-mail format checking, phone number checking reduplicated strings date format control Information extraction and text mining extract texts according to a particular format Proper names, e-mails, phone numbers, etc. 7.2 String Basics There are three basic functions: str_length(): get the length of the string (i.e., number of characters) word_string &lt;- c(&quot;the&quot;, &quot;word&quot;, &quot;string&quot;) word_string %&gt;% str_length ## [1] 3 4 6 str_c(): combine strings into a longer one str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;) ## [1] &quot;thewordstring&quot; str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;,sep = &quot;_&quot;) ## [1] &quot;the_word_string&quot; Please note that the following code will generate a different result from the above. Can you tell the differences? How can you generate exactly the same results by using str_c(word_string,…)? Please check ?str_c. str_c(word_string, sep = &quot;_&quot;) ## [1] &quot;the&quot; &quot;word&quot; &quot;string&quot; str_sub(): substract part of the string str_sub(string = &quot;international&quot;, start = 1, end = 5) ## [1] &quot;inter&quot; 7.3 Regular Expression Grammar Now let’s look at the grammar of regular expressions in more detail. In stringr, there is a very useful function, str_view(STRING, PATTERN), which can show us the match of the pattern in the string in a visually intuitive way: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;an&quot;) 7.3.1 Metacharacters In REGEX, . is a special character, referring to any character: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;.a.&quot;) But what if you really want to match a period . sign in your string? x &lt;- c(&quot;apple&quot;, &quot;banana&quot;,&quot;pear&quot;, &quot;orange. And&quot;) str_view(string = x, pattern = &quot;.&quot;) str_view(string = x, pattern = &quot;\\\\.&quot;) This leads us to the notion of escaping character \\. In R, \\ is used if you want to tell R that the character after \\ should be treated literally, not metaphorically as a meta character. But why two slashes \\\\? It’s simple: because \\ itself is a meta character in R as well. We use it to escape quotes like &quot; and '. Therefore, the first backslash is needed to tell R that the second backslash is matched literally (because we need it to serve as an escape character in the regular expression). 7.3.2 Anchors We can find a match anchored in a particular position. ^: The start of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) $: The end of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;^apple$&quot;) 7.3.3 Character Set \\\\d: matches any digit. \\\\s: matches any whitespace (e.g. space, tab, newline). \\\\w: matches any alphanumeric characters x&lt;-c(&quot;apple&quot;,&quot;apple123&quot;,&quot;banana1&quot;) str_view(string = x , pattern = &quot;\\\\d&quot;) x &lt;- c(&quot;aeiouAEIOU1234_ .\\\\$%-*()&quot;) str_view_all(string = x, pattern = &quot;\\\\w&quot;) #compare str_view_all(string = x, pattern = &quot;.&quot;) 7.3.4 Alternatives [abc]: matches a, b, or c. [^abc]: matches anything except a, b, or c. x &lt;- c(&quot;grey&quot;, &quot;gray&quot;) str_view(string = x, pattern = &quot;gr[ea]y&quot;) 7.3.5 Quantifiers We can use quantifiers to quantifier the degrees of repetition of the quantified character (i.e., the char preceding the quantifier): ?: 0 or 1 +: 1 or more *: 0 or more x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) str_view(x, &quot;X+&quot;) Specify exactly the number of repetition: {n}: exactly n {n,}: n or more {,m}: at most m {n,m}: between n and m x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;C{2}&quot;) str_view(x, &quot;C{2,}&quot;) str_view(x, &quot;C{2,3}&quot;) 7.3.6 Greedy vs. Non-greedy match x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CLX+&quot;) str_view(x, &quot;CLX+?&quot;) 7.3.7 Group and Back-reference x &lt;- fruit %&gt;% head(10) x ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; ## [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; Now if you want to extract English fruit words which has two same letter repeating twice in a row (e.g, apple, bell pepper). How would you create your regular expression pattern? str_view(x, &quot;.{2}&quot;) The results are not what you have expected. The trick is that when you use . to match any character, the quantifier does not help much as any character that repeats would fit the pattern. We need a new strategy to ask the regex engine to remember the matched character and quantify the number of occurrences of the remembered character: str_view(x, &quot;(.)\\\\1&quot;) .: matches any character (.): the parenthesis would label the matched as a group. Internally, the regex engine numbers all groups serially from left to right \\\\1: back-reference the first group. The same logic applies to the second group of the regular expression (i.e., \\\\2) So (.)\\\\1 means that when the engine matches a character (which can be any character), there has to be another same character following the former. Exercise 7.1 How do you match abab pattern, such as “banana”? Exercise 7.2 How do you match abba pattern, such as “pepper”? 7.4 Pattern Matching This section will show you examples of how we can make use of regular expresions to process strings. In stringr, there are a list of verbs that we use with regular expressions: str_detect(STRING, PATTERN): Determine which strings in STRING has a match of the PATTERN (binary) x &lt;- fruit %&gt;% head(10) str_detect(x, &quot;e$&quot;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE str_subset(STRING, PATTERN): Subset the full strings in STRING that have either a full or partial match of the PATTERN (character) str_subset(x, &quot;e$&quot;) ## [1] &quot;apple&quot; &quot;blood orange&quot; str_extract(STRING, PATTERN): Extract the content of the matches of the strings in STRING (character) str_extract(x, &quot;e$&quot;) ## [1] &quot;e&quot; NA NA NA NA NA NA NA &quot;e&quot; NA str_replace(STRING, PATTERN, REPLACEMENT): Replace matches of the PATTERN with REPLACEMENT in STRING (character): str_replace() str_replace(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) ## [1] &quot;Vpple&quot; &quot;Vpricot&quot; &quot;Vvocado&quot; &quot;bVnana&quot; &quot;bVll pepper&quot; ## [6] &quot;bVlberry&quot; &quot;blVckberry&quot; &quot;blVckcurrant&quot; &quot;blVod orange&quot; &quot;blVeberry&quot; It should be noted that str_replace() only replaces the first match of each string. str_replace_all(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) ## [1] &quot;VpplV&quot; &quot;VprVcVt&quot; &quot;VvVcVdV&quot; &quot;bVnVnV&quot; &quot;bVll pVppVr&quot; ## [6] &quot;bVlbVrry&quot; &quot;blVckbVrry&quot; &quot;blVckcVrrVnt&quot; &quot;blVVd VrVngV&quot; &quot;blVVbVrry&quot; str_split(STRING, PATTERN): Split a string in STRING based on a PATTERN (character) x &lt;- sentences %&gt;% head(5) x ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; str_split(string = x, pattern = &quot;\\\\s&quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; ## ## [[4]] ## [1] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; ## [8] &quot;rare&quot; &quot;dish.&quot; ## ## [[5]] ## [1] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; Please note that the return of str_split() is a list. fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;: &quot;) ## [[1]] ## [1] &quot;Name&quot; &quot;Hadley&quot; ## ## [[2]] ## [1] &quot;Country&quot; &quot;NZ&quot; ## ## [[3]] ## [1] &quot;Age&quot; &quot;35&quot; fields %&gt;% str_split(&quot;: &quot;, simplify = T) ## [,1] [,2] ## [1,] &quot;Name&quot; &quot;Hadley&quot; ## [2,] &quot;Country&quot; &quot;NZ&quot; ## [3,] &quot;Age&quot; &quot;35&quot; Exercise 7.3 Convert American dates to British dates. Exercise 7.4 Split filenames of ICNALE 7.5 Advanced Pattern Matching: Look Ahead and Behind If you want to find Windows, but only when it is followed by &quot;95, 98, NT, 2000&quot;: win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;Windows3.1&quot;) str_view(win, &quot;Windows(?=95|98|NT|2000)&quot;) Or the other way around: win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;Windows3.1&quot;) str_view(win, &quot;Windows(?!95|98|NT|2000)&quot;) In the regular expression, the () after Windows is a condition for matching. There are four alternatives to specify your conditions: Look-ahead conditions: (?=pattern): The target match has to be followed by the pattern in the condition (?!pattern): The target match cannot be followed by the pattern in the condition Look-behind conditions: (?&lt;=pattern): The target match has to be preceded by the pattern in the condition (?&lt;!pattern): The target match cannot be preceded by the pattern in the condition win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;3.1Windows&quot;) str_view(win, &quot;(?&lt;=95|98|NT|2000)Windows&quot;) win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;3.1Windows&quot;) str_view(win, &quot;(?&lt;!95|98|NT|2000)Windows&quot;) Exercise 7.5 Please use the first ten words in the fruit vector for this exercise. Based on the fruit vocabulary, can you give us all the a's that are followed by STOP_SOUNDS? STOP_SOUNDS refer to p, t, k, b, d, g. Exercise 7.6 Similar to the previous example, Exercise 7.5, also based on the first ten words in fruit, please identify all the vowels that are both followed and preceded by STOP_SOUNDS. 7.6 Practical Cases 7.6.1 Case 1 How to extract only the number of the week from the y column, and add this information to a new column, z? dt &lt;- tibble( x = 1:4, y = c(&quot;wk 3&quot;, &quot;week-1&quot;, &quot;7&quot;, &quot;w#9&quot;) ) dt 7.6.2 Case 2 How to extract all the vowels from the first ten words in fruit? dt &lt;- tibble( WORD = fruit[1:10] ) dt 7.6.3 Case 3 How to separate the English and Chinese and create two new columns, EN, CH? tb &lt;- tibble(x = c(&quot;I我&quot;, &quot;love愛&quot;, &quot;you你&quot;)) tb 7.6.4 Case 4 How to extract the numbers and split the numbers into START and END? df &lt;- tibble(x = c(&quot;1-12周&quot;, &quot;1-10周&quot;, &quot;5-12周&quot;)) df 7.6.5 Case 5 How to extract numbers of each token and compute the sum of the number and save the results in a new column SUM? df &lt;- tibble( x = c(&quot;1234&quot;, &quot;B246&quot;, &quot;217C&quot;, &quot;2357f&quot;, &quot;21WD4&quot;) ) df 7.6.6 Case 6 How to extract all the numbers that follow a upper-casing letter? For example, 34 after W; 217 after B? df &lt;- tibble( x = c(&quot;12W34&quot;, &quot;AB2C46&quot;, &quot;B217C&quot;, &quot;akTs6df&quot;, &quot;21WD4&quot;) ) df 7.6.7 Case 7 Relating to Section 7.6.6, can you add another column to the resulting data frame, which records the upper-casing letter that the numbers follow for each token? "],
["iteration.html", "Chapter 8 Iteration 8.1 Code Duplication 8.2 vector vs. list in R 8.3 Iteration 8.4 purr 8.5 Writing Own Functions", " Chapter 8 Iteration 8.1 Code Duplication Code duplication is tedious and hard to maintain and debug. Plus, there are obvious advantages for reducing code duplications. According to Wickham and Grolemund (2017) Chapter 21 Iteration, there are three main advantages of doing so: It’s easier to see the intent of your code, because your eyes are drawn to what’s different, not what stays the same. It’s easier to respond to changes in requirements. As your needs change, you only need to make changes in one place, rather than remembering to change every place that you copied-and-pasted the code. You’re likely to have fewer bugs because each line of code is used in more places. There are in general two major ways to reduce duplication in coding: wrap the duplicate procedures into a function use iteration This chapter would focus on the second strategy.In this chapter, we talk about code efficiency. In particular we will work on the library purr. 8.2 vector vs. list in R Most of the R-internal functions are vectorized. By default, if we apply a function to a multi-element vector, R will automatically apply the same procedure to each element of the vector, and return the results of the same length. a.vec &lt;- c(1:10) sqrt(a.vec) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 But this is NOT something we can do with a list: a.list &lt;- list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) sqrt(a.list) ## Error in sqrt(a.list): non-numeric argument to mathematical function 8.3 Iteration As we work with list and data.frame very often, it would great if we can have a easy way to apply the same procedure to: - each element in the list - each row in the data.frame - each column in the data.frame Let’s start with a scenario. We first create a pseudo data set, with students’ grades from five different classes. exams.list &lt;- list( class1 = round(runif(30, 0, 100)), # 30 tokens of random numbers in the range &lt;0, 100&gt; class2 = round(runif(30, 0, 100)), class3 = round(runif(30, 0, 100)), class4 = round(runif(30, 0, 100)), class5 = round(runif(30, 0, 100)) ) exams.list ## $class1 ## [1] 13 53 71 19 6 29 16 80 41 32 78 54 64 70 61 30 45 82 14 34 48 69 50 90 89 ## [26] 17 83 53 76 55 ## ## $class2 ## [1] 80 91 76 19 7 96 75 1 15 48 7 53 9 24 79 20 53 12 71 84 19 12 60 64 66 ## [26] 34 96 96 84 27 ## ## $class3 ## [1] 63 42 23 12 47 77 43 8 99 37 8 15 45 26 52 52 85 71 93 87 65 21 4 29 21 ## [26] 30 31 26 79 22 ## ## $class4 ## [1] 79 62 98 30 41 35 39 63 74 60 90 15 68 71 94 58 85 84 2 14 85 27 23 29 92 ## [26] 95 73 82 94 36 ## ## $class5 ## [1] 34 82 81 64 1 98 83 88 22 88 12 72 20 14 41 40 68 20 40 96 12 62 47 96 73 ## [26] 69 80 77 62 69 If we like to compute the mean scores of each cluster, you probably want to use mean(): mean(exams.list) ## [1] NA It should be clear now that mean() expects a numeric vector, on which the mean score is computed. So you may think that why don’t we use the dumb way: set.seed(123) # Make sure we get the same results exams.list.means &lt;- list( class1mean = mean(exams.list$class1), class2mean = mean(exams.list$class2), class3mean = mean(exams.list$class3), class4mean = mean(exams.list$class4), class5mean = mean(exams.list$class5) ) exams.list.means ## $class1mean ## [1] 50.73333 ## ## $class2mean ## [1] 49.26667 ## ## $class3mean ## [1] 43.76667 ## ## $class4mean ## [1] 59.93333 ## ## $class5mean ## [1] 57.03333 The advantage is obvious: (a) what if you have 10 classes? 100 classes? (b) what if now you decide to compute standard deviation? 8.4 purr library(tidyverse) exams.list %&gt;% map(mean) ## $class1 ## [1] 50.73333 ## ## $class2 ## [1] 49.26667 ## ## $class3 ## [1] 43.76667 ## ## $class4 ## [1] 59.93333 ## ## $class5 ## [1] 57.03333 With only one-line code, you have achieved your goal. map() is a very powerful function to do iteration. Its usage is as follows: To conceptualize this code map(exams.list, mean): For each element in the exams.list, apply the function mean Do the first element, and save the result in the first elemenet of the new list Do the second element, and save the result in the second elemvent of the new list … After finishing all elements in the exams.list, return the new list result In purrr, by default map() returns results in a list format. You can specify a particular data structure you like by using other variants of the mapping function: exams.list %&gt;% map_df(mean) exams.list %&gt;% map_dbl(mean) ## class1 class2 class3 class4 class5 ## 50.73333 49.26667 43.76667 59.93333 57.03333 Exercise 8.1 Use the same dataset, exam.list, and compute the median and standard deviation for each class. Median ## class1 class2 class3 class4 class5 ## 53.0 53.0 39.5 65.5 66.0 Standard Deviation ## class1 class2 class3 class4 class5 ## 25.25311 32.46105 27.71117 28.74973 29.30280 8.5 Writing Own Functions With the power and flexibility of purrr::map(), we can basically do everything iteratively. More attractively, we can apply a self-defined function as well! First we create own self-defined function my_center: - This function takes a vector object x - Substract each element of x by the mean score of x - return the resulting vector as the output of the function my_center &lt;- function(x) { x - mean(x) } Now we can apply our my_center function to each class in exams.list: exams.list %&gt;% map_df(my_center) Exercise 8.2 Use the built-in the mtcars dataset (?mtcars for more detail). How to get the class type of each column in the mtcars? Exercise 8.3 Create a self-defined function to convert each number of a numeric vector to a “z” score. y &lt;- c(1, 4, 6, 10, 20) my_z(y) ## [1] -7.2000000 -2.1000000 -0.8981462 0.5692100 2.6385602 Exercise 8.4 Use the dataset exams.list in this chapter. For each class, please convert the student’s score to a z-score. exams.list %&gt;% map_df(my_z) References "],
["data-scientist-first-step.html", "Chapter 9 Data Scientist First Step 9.1 Nobel Laureates Dataset 9.2 Before we start 9.3 Data Completeness NA 9.4 Hypotheses 9.5 At what age did these people receive the prizes?", " Chapter 9 Data Scientist First Step Finally this chapter will demonstrate how you can make use of what you have learned from the previous chapters to perform a exploratory data analysis on the dataset you are interested in. Here we will look at a dataset of Nobel Laureates. library(tidyverse) 9.1 Nobel Laureates Dataset df &lt;- read_csv(&quot;demo_data/nobel-laureates.csv&quot;) df 9.2 Before we start Before we start, it is clear to see that the column names are full of spaces, which we would like to get rid off. So first, we remove all the spaces in the columns and replace them with _: names(df) &lt;- str_replace_all(names(df), &quot;\\\\s&quot;,&quot;_&quot;) df 9.3 Data Completeness NA It is always important to check if the information of each row is complete. check_num_NA &lt;- function(x){ x %&gt;% is.na %&gt;% sum } df %&gt;% map_df(check_num_NA) You can check rows with NA’s: df %&gt;% filter(is.na(Sex)) 9.4 Hypotheses When given a dataset, before you explore your data, you may first have some hypotheses in mind: 9.4.1 How many laureates were there in different discplines? df %&gt;% count(Category) df %&gt;% count(Category) %&gt;% ggplot(aes(x = Category, y = n, fill = Category)) + geom_col() + geom_text(aes(label = n), vjust = -0.25) + labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) df %&gt;% count(Category) %&gt;% ggplot(aes(x = fct_reorder(Category, n), y = n, fill = Category)) + geom_col() + geom_text(aes(label = n), vjust = -0.25) + labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) An even more dynamic graph: library(gganimate) #install.packages(&quot;gganimate&quot;, dependencies = T) df %&gt;% count(Category) %&gt;% mutate(Category = fct_reorder(Category, n)) %&gt;% ggplot(aes(x = Category, y = n, fill = Category)) + geom_text(aes(label = n), vjust = -0.25) + geom_col()+ labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) + transition_states(Category) + shadow_mark(past = TRUE) 9.4.2 Chinese Laureates df %&gt;% filter(Birth_Country == &quot;China&quot;) There are duplicate tokens in our dataset. nobel_winners &lt;- df %&gt;% mutate_if(is.character, tolower) %&gt;% # lower all character vectors distinct_at(vars(Full_Name, Year, Category), .keep_all = TRUE) %&gt;% mutate(Decade = 10 * (Year %/% 10), Prize_Age = Year - lubridate::year(Birth_Date)) nobel_winners Check Chinese laureates again: nobel_winners %&gt;% filter(Birth_Country == &quot;china&quot;) %&gt;% select(Full_Name, Year, Category) Create a subset of `nobel_winners`, which includes only winners who won the prizes more than once and in more than one category. 9.5 At what age did these people receive the prizes? nobel_winners %&gt;% ggplot(aes(x = Prize_Age)) + geom_histogram(color=&quot;white&quot;) nobel_winners %&gt;% filter(!is.na(Prize_Age)) %&gt;% ggplot(aes(x = Prize_Age, fill = Category, color = Category)) + geom_density() + facet_wrap(~Category) + theme(legend.position = &quot;none&quot;) Exercise 9.1 Please create data frame that shows us the average agae of the winners in different categories, as shown below. Exercise 9.2 Please create data frame that shows us the distributions of male and female winners in different categories. Please show the number of males and females as well as the proportions. (i.e., frequencies and normalizaed frequencies) Exercise 9.3 Please show us the states distribution of the US Nobel Winners. This would give us an idea from which states in the United States there were the most Nobel winners. Exercise 9.4 Following Exercise 9.3, can you include the full names of states in the above table by adding another column? In the demo-data directory, you can find a csv with the mapping between states abbreviations and their full names. The US-states.csv dataset US_states &lt;- read_csv(&quot;demo_data/US-states.csv&quot;) US_states "],
["references.html", "References", " References "]
]
