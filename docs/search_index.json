[
["string-manipulation.html", "Chapter 8 String Manipulation 8.1 What is Regular Expression? 8.2 String Basics 8.3 A Good Tool: RegExplain 8.4 Regular Expression Grammar 8.5 Pattern Matching 8.6 Advanced Pattern Matching: Look Ahead and Behind 8.7 More Practices 8.8 Case Study: Chinese Four-Character Idioms", " Chapter 8 String Manipulation In data analysis, most of the time we are dealing with texts/strings. In other words, when wrangling with the data, we need all kinds of techniques in string manipulations, such as finding/replacing a particular string, removing unnecessary strings, combining shorter strings into a longer one, or splitting a long string into smaller tokens. My experience tells me that a competent data scientist often needs a certain level of skills on string processing. Most importantly, an effective use of regular expressions plays the most important role. In this chapter, I would like to introduce some frequently-used techniques relating to string manipulation, with a special focus on regular expression. Also, I will use the package stringr, which is part of the tidyverse framework as well. library(tidyverse) library(stringr) 8.1 What is Regular Expression? In text processing, we often do “find-and-replace” in our documents. I am sure that you do this very often in MS-Word or MS-Excel. The routines reflect the fact that we often need to locate particular sets of strings and perform specific processing on these strings (e.g., replacing, removing, modifying them etc.). This is the exact niche where regular expression can really help a lot. Regular expression is a language, which allows us to create a schematic textual pattern and use this pattern to match other strings that may fall into this schematic pattern. This idea of one-pattern-for-multiple-matches is the beauty of regular expression. Several advantages of regular expressions are self-evident: Effective/Efficient pattern matching e-mail format checking, phone number checking reduplicated strings date format control Information extraction and text mining extract texts according to a particular format Proper names, e-mails, phone numbers, etc. Therefore, the nature of one-to-many mapping for regular expressions allows us to effectively retrieve strings of similar properties in a much simpler way. 8.2 String Basics Before we introduce regular expressions, let’s look at some of the basic string-related functions. There are three basic functions: str_length(): get the length of the string (i.e., number of characters) word_string &lt;- c(&quot;the&quot;, &quot;word&quot;, &quot;string&quot;) word_string %&gt;% str_length ## [1] 3 4 6 str_c(): combine strings into a longer one str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;) ## [1] &quot;thewordstring&quot; str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;,sep = &quot;_&quot;) ## [1] &quot;the_word_string&quot; From the above output, can you tell what is the default value for the argument str_c(..., sep = ...)? Please note that the following code generates a different result from the above. Can you tell the differences? How can you create exactly the same results by using str_c(word_string,…)? Please check ?str_c. str_c(word_string, sep = &quot;_&quot;) ## [1] &quot;the&quot; &quot;word&quot; &quot;string&quot; When you have several objects in the str_c(), please use the argument str_c(…, sep = …) to combine them into a long string; when you have only one object (but it is a multiple-element character vector), please use the argument str_c(…, collpase = …) to collapse a vector into a long string. str_sub(): substract part of the string by positions str_sub(string = &quot;international&quot;, start = 1, end = 5) ## [1] &quot;inter&quot; 8.3 A Good Tool: RegExplain There is a very useful tool for the use of regular expressions–RegExplain, which is an RStudio addin. It allows you to: interactively build your regexp and check the output of common string matching functions Figure 8.1: Taken from RegExplain Github Page use the included resources to learn regular expressions Figure 8.2: Taken from RegExplain Github Page consult the interactive help pages Figure 8.3: Taken from RegExplain Github Page This is very useful because we can prepare our regular expressions and use them in the code chunk after we have made sure that they work properly in the RegExplain. You can install the addin using devtools: ## Please install `devtools` if you haven&#39;t # install.packages(&quot;devtools&quot;) # library(devtools) # install_github(&quot;gadenbuie/regexplain&quot;) 8.4 Regular Expression Grammar Now let’s look at the grammar of regular expressions in more detail. In this section, we will discuss the standard Perl-compatible regular expression syntax. This is by now the most widely used version of regular expressions in most programming languages. To start with, in stringr, there is a very useful function, str_view(STRING, PATTERN), which can show us the match of the pattern in the string in a visually intuitive way: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;an&quot;) For basic syntax of regular expressions, I will use this str_view() to show you how the regular pattern works in string-matching. You can also use RegExplain addin to test your regular expressions. 8.4.1 Metacharacters To implement the idea of one-to-many mapping, RegEx defines several metacharacters, which are of special use in regular expressions. Their meanings are NOT the same as their literal counterparts. In RegEx, . is a special character, referring to any character: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;.a.&quot;) But what if you really want to match a period . symbol literally in your string? x &lt;- c(&quot;apple&quot;, &quot;banana&quot;,&quot;pear&quot;, &quot;orange. And&quot;) str_view(string = x, pattern = &quot;.&quot;) str_view(string = x, pattern = &quot;\\\\.&quot;) This leads us to the notion of escaping character \\. In R, \\ is used if you want to tell R that the metacharacter after \\ should be treated literally, not metaphorically as a metacharacter. But why two slashes \\\\? It’s simple: because \\ itself is a metacharacter in R as well. We use it to escape quotes like &quot; and '. Therefore, the first backslash is needed in order to tell R engine that the following character (i.e., the second slash) should be taken literally; the second backslash is needed in order to tell RegEx engine that the following character (i.e., .) should be taken literally. 8.4.2 Anchors RegEx defines a few metacharacters, which serve as anchors in pattern matching. These ancharing metacharacters allow us to find a match in a particular position of the string (e.g., at the beginning/ending of the string). ^: The start of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) $: The end of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;^apple$&quot;) The anchors are evaluated according to the base unit you are matching. In our previous examples, the RegEx pattern is applied to find a match in each element of the vector. The vector includes words. Therefore, the ^ indicates a word-initial position; $ indicates a word-final position. If you have a vector of sentences, the ^ would indicate a sentence-initial position; $ would indicate a sentence-final position. (See below) x &lt;- c(&quot;apple is good&quot;, &quot;banana is better than apple&quot;, &quot;an apple a day keeps the doctor away&quot;) str_view(x, &quot;^apple&quot;) str_view(x, &quot;apple$&quot;) 8.4.3 Character Set RegEx also defines a few character sets because in our patten-matching, the characters included in a set often show similar behaviors. Common predefined character sets include: \\\\d: matches any digit. \\\\s: matches any whitespace (e.g. space, tab, newline). \\\\w: matches any alphanumeric characters x&lt;-c(&quot;apple&quot;,&quot;apple123&quot;,&quot;banana1&quot;) str_view(string = x , pattern = &quot;\\\\d&quot;) In pattern-matching, very often you will have cases where one base unit may have more than one match. In the previous example, str_view() identifies only the first match of each base unit from x. If you need to identify all the matches from each base unit, you need to use str_view_all(). x &lt;- c(&quot;aeiouAEIOU1234_ .\\\\$%-*()&quot;) str_view_all(string = x, pattern = &quot;\\\\w&quot;) #compare str_view_all(string = x, pattern = &quot;.&quot;) The difference of finding-the-first-match (str_view()) vs. finding-all-the-matches (str_view_all()) will turn out to be very important in practical tasks. Please bear this in mind. In the above comparison of the two meta-character sets, . and \\w, it is clear that the \\w includes alphanumetic characters plus the underscore _. It does NOT include the hyphen -, which however can be a word-internal component. 8.4.4 Alternatives Section 8.4.3 describes a few prefined character sets in RegEx. We can also define our own character set using the square brackets [ ]. And we can use [^...] to define a complementary character set. (Please note that ^ has a different RegEx meaning within [].) [abc]: matches a, b, or c. [^abc]: matches anything except a, b, or c. x &lt;- c(&quot;grey&quot;, &quot;gray&quot;) str_view(string = x, pattern = &quot;gr[ea]y&quot;) If you know very well which characters you are to match/find, use inclusive character sets, i.e., […]. If you know very well which characters you do NOT like to match/find, use exclusive character sets, i.e., [^...]. For example, what if we would like to find all non-vowel letters in the words? Instead of coming up with an inclusive character set [...], which include all possible consonant letters, it would be more efficient if you create an exclusive character set, [^aeiou], which suggests that you need any characters that do not belong to vowels. x &lt;- c(&quot;grey&quot;, &quot;gray&quot;) str_view_all(string = x, pattern = &quot;[^aeiou]&quot;) 8.4.5 Quantifiers We can use quantifiers to specify the number of occurrences of a particular pattern (e.g., the character preceding the quantifier): ?: 0 or 1 +: 1 or more *: 0 or more x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) str_view(x, &quot;X+&quot;) We can specify an exact range of number of ocurrences using the curly brackets { , }: {n}: exactly n occurrences {n,}: n or more occurrences {,m}: at most m occurrences {n,m}: between n and m occurrences x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;C{2}&quot;) str_view(x, &quot;C{2,}&quot;) str_view(x, &quot;C{2,3}&quot;) When we use the quantifiers, be very careful about the scope of the quantifier. By default, the quantifier takes only its preceding character as the scope. If you need to specify the number of occurrences for a group of characters or a specific pattern, you need to put the pattern in a group (…) and then put your quantifier right after the group. x &lt;- &quot;aaabbbababcdf&quot; str_view(x, &quot;ab{2}&quot;) # the scope of the quantifier is `b` str_view(x, &quot;(ab){2}&quot;) # the scope of the quantifier is `ab` 8.4.6 Greedy vs. Non-greedy match The above two examples show you that when the RegEx locates the pattern in the string, it prefers to find a longest match that satisfies the pattern. In the above examples, the substring CC should satisfy the RegEx C{2,} already but the RegEx returns CCC as the match. This is the idea of greedy match. In other words, by default, when we apply quantifiers in our regular expressions, the RegEx engine assumes a greedy match (i.e., to find a longest possible match). To cancel this default greedy match, we can add ? after the quantifiers. x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CLX+&quot;) # find longest match str_view(x, &quot;CLX+?&quot;) # find minial match 8.4.7 Group and Back-reference # `fruit` is a preloaded vector from `stringr` x &lt;- fruit %&gt;% head(10) x ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; ## [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; Now if we want to extract English fruit words which has two same letter repeating twice in a row (e.g, apple, bell pepper). But the problem is: we don’t know which letters are going to be repeated in the words. How should we define our regular expressions? str_view(x, &quot;.{2}&quot;) The results are not what you have expected. The above pattern would only give you the first two characters of each word. The trick is that when you use . to match any character, the quantifier does not help much as any character that repeats would fit the pattern. We need a new strategy to ask the RegEx engine to remember the previously matched character and quantify the number of occurrences of the remembered character: str_view(x, &quot;(.)\\\\1&quot;) The regular expression can be conceptualized as follows: .: matches any character (.): the parenthesis would label the matched as a group. Internally, the RegEx engine numbers all groups serially from left to right \\\\1: back-reference the first group. The same logic applies to the second group of the regular expression (i.e., \\\\2) So (.)\\\\1 means that when the engine matches a character (which can be any character), there has to be another same character following the former. Exercise 8.1 With the same set of fruit names in x, how do we match fruits with a abab pattern, such as “banana”? Exercise 8.2 With the same set of fruit names in x, how do we match fruits with a abba pattern, such as “pepper”? Exercise 8.3 With the same set of fruit names in x, please find fruit names which has at least one letter that is the same as their initial letters 8.5 Pattern Matching This section will show you examples of how we can make use of regular expresions to process strings. In stringr, there are a list of verbs that we use with regular expressions: 8.5.1 str_detect() str_detect(STRING, PATTERN): Determine which strings in STRING has a match of the PATTERN (binary) str_detect(x, &quot;e$&quot;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE 8.5.2 str_subset() str_subset(STRING, PATTERN): Subset the full strings in STRING that have either a full or partial match of the PATTERN (character) str_subset(x, &quot;e$&quot;) ## [1] &quot;apple&quot; &quot;blood orange&quot; 8.5.3 str_extract() str_extract(STRING, PATTERN): Extract the content of the matches of the strings in STRING (character) str_extract(x, &quot;e$&quot;) ## [1] &quot;e&quot; NA NA NA NA NA NA NA &quot;e&quot; NA Also, please note that str_extract() only extract the first match of the string. To extract all matches from the strings: str_extract(x, &quot;[aeiou]&quot;) # find only the first match ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;a&quot; &quot;a&quot; &quot;o&quot; &quot;u&quot; str_extract_all(x, &quot;[aeiou]&quot;) # find all matches in each string ## [[1]] ## [1] &quot;a&quot; &quot;e&quot; ## ## [[2]] ## [1] &quot;a&quot; &quot;i&quot; &quot;o&quot; ## ## [[3]] ## [1] &quot;a&quot; &quot;o&quot; &quot;a&quot; &quot;o&quot; ## ## [[4]] ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; ## ## [[5]] ## [1] &quot;e&quot; &quot;e&quot; &quot;e&quot; ## ## [[6]] ## [1] &quot;i&quot; &quot;e&quot; ## ## [[7]] ## [1] &quot;a&quot; &quot;e&quot; ## ## [[8]] ## [1] &quot;a&quot; &quot;u&quot; &quot;a&quot; ## ## [[9]] ## [1] &quot;o&quot; &quot;o&quot; &quot;o&quot; &quot;a&quot; &quot;e&quot; ## ## [[10]] ## [1] &quot;u&quot; &quot;e&quot; &quot;e&quot; 8.5.4 str_match() str_match(STRING, PATTERN): Extract the content of the matches of the strings in STRING as well as each capture groups (character) str_match(x, &quot;(bl)([aeiou]+)&quot;) ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA ## [3,] NA NA NA ## [4,] NA NA NA ## [5,] NA NA NA ## [6,] NA NA NA ## [7,] &quot;bla&quot; &quot;bl&quot; &quot;a&quot; ## [8,] &quot;bla&quot; &quot;bl&quot; &quot;a&quot; ## [9,] &quot;bloo&quot; &quot;bl&quot; &quot;oo&quot; ## [10,] &quot;blue&quot; &quot;bl&quot; &quot;ue&quot; For each match, we will get not only the full match, but also the capture groups substrings specified in the regular expression. Each group (i.e., parenthesis) in your regular expression will have a partial match in the results. Exercise 8.4 How do you use str_match() to find out all the c+Vowel structures, and at the same time identify which vowels follow the letter c? ## [,1] [,2] ## [1,] NA NA ## [2,] &quot;co&quot; &quot;o&quot; ## [3,] &quot;ca&quot; &quot;a&quot; ## [4,] NA NA ## [5,] NA NA ## [6,] NA NA ## [7,] NA NA ## [8,] &quot;cu&quot; &quot;u&quot; ## [9,] NA NA ## [10,] NA NA 8.5.5 str_replace() str_replace(STRING, PATTERN, REPLACEMENT): Replace matches of the PATTERN with REPLACEMENT in STRING (character) str_replace(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) ## [1] &quot;Vpple&quot; &quot;Vpricot&quot; &quot;Vvocado&quot; &quot;bVnana&quot; &quot;bVll pepper&quot; ## [6] &quot;bVlberry&quot; &quot;blVckberry&quot; &quot;blVckcurrant&quot; &quot;blVod orange&quot; &quot;blVeberry&quot; It should be noted that str_replace() only replaces the first match of each string. str_replace_all(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) ## [1] &quot;VpplV&quot; &quot;VprVcVt&quot; &quot;VvVcVdV&quot; &quot;bVnVnV&quot; &quot;bVll pVppVr&quot; ## [6] &quot;bVlbVrry&quot; &quot;blVckbVrry&quot; &quot;blVckcVrrVnt&quot; &quot;blVVd VrVngV&quot; &quot;blVVbVrry&quot; 8.5.6 str_split() str_split(STRING, PATTERN): Split a string in STRING based on a PATTERN (character) x &lt;- sentences %&gt;% head(5) x ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; str_split(string = x, pattern = &quot;\\\\s&quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; ## ## [[4]] ## [1] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; ## [8] &quot;rare&quot; &quot;dish.&quot; ## ## [[5]] ## [1] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; Please note that the return of str_split() is a list. fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;: &quot;) ## [[1]] ## [1] &quot;Name&quot; &quot;Hadley&quot; ## ## [[2]] ## [1] &quot;Country&quot; &quot;NZ&quot; ## ## [[3]] ## [1] &quot;Age&quot; &quot;35&quot; # To get a simpler structure in return: fields %&gt;% str_split(&quot;: &quot;, simplify = T) ## [,1] [,2] ## [1,] &quot;Name&quot; &quot;Hadley&quot; ## [2,] &quot;Country&quot; &quot;NZ&quot; ## [3,] &quot;Age&quot; &quot;35&quot; Exercise 8.5 Convert American dates American.dates to British dates using str_replace_all(). Please note that in your output, you need to preserve the original delimiters for each date. American.dates &lt;- c(&quot;7/31/1976&quot;, &quot;02.15.1970&quot;, &quot;11-31-1986&quot;, &quot;04/01.2020&quot;) ## [1] &quot;31/7/1976&quot; &quot;15.02.1970&quot; &quot;31-11-1986&quot; &quot;01/04.2020&quot; Exercise 8.6 Please use the default sentences vector as your input and find all patterns of “any BE verbs + words ending with ‘en’ or ‘ed’”. Please extract these matches from the sentences and your result should be a vector of these matches, as shown below. Hint: Check unlist() and nzchar() sentences[1:5] ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; length(sentences) ## [1] 720 ## [1] &quot;is often&quot; &quot;were fed&quot; &quot;is used&quot; &quot;was cooked&quot; ## [5] &quot;was seized&quot; &quot;is used&quot; &quot;was spattered&quot; &quot;is red&quot; ## [9] &quot;was fired&quot; &quot;is ten&quot; &quot;is used&quot; &quot;are pushed&quot; ## [13] &quot;are men&quot; &quot;are used&quot; &quot;were hired&quot; &quot;was covered&quot; ## [17] &quot;were lined&quot; &quot;was ten&quot; &quot;is used&quot; &quot;are paved&quot; ## [21] &quot;is carved&quot; &quot;were led&quot; &quot;is needed&quot; &quot;were painted&quot; ## [25] &quot;were mailed&quot; &quot;was pressed&quot; &quot;is seen&quot; &quot;was packed&quot; ## [29] &quot;was barred&quot; &quot;was crowded&quot; &quot;was carved&quot; &quot;was drilled&quot; ## [33] &quot;was hidden&quot; &quot;was seen&quot; &quot;were pierced&quot; &quot;are jangled&quot; ## [37] &quot;is tinged&quot; &quot;were stamped&quot; &quot;was jammed&quot; &quot;was robbed&quot; 8.6 Advanced Pattern Matching: Look Ahead and Behind The regular expressions we have introduced so far will consume the input strings when doing the pattern matching. I would like to illustrate this idea with the following simple example. If we want to find Windows, but only when it is followed by &quot;95, 98, NT, 2000&quot;, how should we write our RegEx pattern? win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;WindowsNT&quot;, &quot;Windows7&quot;, &quot;Windows10&quot;) str_view(win, &quot;Windows((95)|(98)|(NT)|(2000))&quot;) The pattern seems OK because we did find the Windows2000 that satisfies our RegEx. But what if you would like to replace the word “Windows” with “OldSystem” but only when “Windows” is followed by &quot;95, 98, NT, 2000&quot;? str_replace(win, pattern = &quot;Windows((95)|(98)|(NT)|(2000))&quot;, replacement = &quot;OldSystem&quot;) ## [1] &quot;OldSystem&quot; &quot;Windows&quot; &quot;OldSystem&quot; &quot;Windows7&quot; &quot;Windows10&quot; Now you see the problem? Not only “Windows” was replaced, but also the entire string. This is not what we expect to get. Instead, we would expect something like: ## [1] &quot;OldSystem2000&quot; &quot;Windows&quot; &quot;OldSystemNT&quot; &quot;Windows7&quot; ## [5] &quot;Windows10&quot; That is why we need lookahead function in RegEx. (?=...): positive lookahead—extract a match only when … is on the right (?!...): negative lookahead—extract a match only when … is NOT on the right str_view(win, &quot;Windows(?=95|98|NT|2000)&quot;) In the above regular expression, the () after Windows is a lookahead condition for matching. The strings of “2000” and “NT” in the condition are NOT consumed. The RegEx engine looks ahead the following few characters first to check the patterns but after it finds a match, the lookahead characters will still be the input of the next pattern-matching. We can make use of this lookahead to do the string replacement: str_replace(string = win, pattern = &quot;Windows(?=95|98|NT|2000)&quot;, replacement = &quot;OldSystem&quot;) ## [1] &quot;OldSystem2000&quot; &quot;Windows&quot; &quot;OldSystemNT&quot; &quot;Windows7&quot; ## [5] &quot;Windows10&quot; Moreover, we can create a negative lookahead as well: str_view(win, &quot;Windows(?!7|10)&quot;) str_replace(string = win, pattern = &quot;Windows(?!7|10)&quot;, replacement = &quot;NewSystem&quot;) ## [1] &quot;NewSystem2000&quot; &quot;NewSystem&quot; &quot;NewSystemNT&quot; &quot;Windows7&quot; ## [5] &quot;Windows10&quot; In addition to lookahead, we can also specify look-behind conditions: Look-behind conditions: (?&lt;=pattern): The target match has to be preceded by the pattern defined in the condition (?&lt;!pattern): The target match cannot be preceded by the pattern defined in the condition win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;NTWindowsNT&quot;, &quot;7Windows&quot;, &quot;10Windows&quot;) str_view(win, &quot;(?&lt;=95|98|NT|2000)Windows&quot;) win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;NTWindowsNT&quot;, &quot;7Windows&quot;, &quot;10Windows&quot;) str_view(win, &quot;(?&lt;!95|98|NT|2000)Windows&quot;) Exercise 8.7 Please use the first ten words in the fruit vector for this exercise. Based on the fruit vocabulary, can you identify all the a that is followed by STOP_SOUNDS and replace them with “V”? STOP_SOUNDS refer to p, t, k, b, d, g Hint: str_replace_all() dataset fruit[1:10] ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; ## [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; target matches your result ## [1] &quot;Vpple&quot; &quot;Vpricot&quot; &quot;avocVdo&quot; &quot;banana&quot; &quot;bell pepper&quot; ## [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; Exercise 8.8 Similar to the previous example, Exercise 8.7, also based on the first ten words in fruit, please identify all the vowels that are both followed and preceded by STOP_SOUNDS and replace them with “V”. Vowels are defined as letters including a, e, i, o,and u, dataset fruit[1:10] ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; ## [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; target matches your result ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pVpper&quot; ## [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; 8.7 More Practices This section will show you more examples of the RegEx applications. Most importantly, I will specifically point out the capacities and potentials of regular expressions in helping us manipulating the datasets. In Chapter 6, we have talked about important ways in which we can manipulate our data as a data.frame/tibble. Please refer to the Chapter 6 for a review of the important verbs in dplyr. 8.7.1 Case 1 If we have a data frame like dt below, how do we extract only the numbers of the weeks from the y column, and add this information to a new column, z? dt &lt;- tibble( x = 1:4, y = c(&quot;wk 3&quot;, &quot;week-1&quot;, &quot;7&quot;, &quot;w#9&quot;) ) dt Exercise 8.9 If we have a data frame like dt below, how do we extract all the vowels of the words in the WORD column and create two additional columns: Because a word may have several vowels, create a new column, which shows all the vowels in the word by combining them into a long string with the delimiter &quot;_&quot; Create another column for the number of vowels for each word Vowels are defined as [aeiou]. dt &lt;- tibble( WORD = fruit[1:10] ) dt 8.7.2 Case 2 How to separate the English and Chinese strings in x column and create two new columns, EN, CH? tb &lt;- tibble(x = c(&quot;I我&quot;, &quot;love愛&quot;, &quot;you你&quot;)) tb Exercise 8.10 How to extract the numbers and split the numbers into START and END? df &lt;- tibble(x = c(&quot;1-12周&quot;, &quot;1-10周&quot;, &quot;5-12周&quot;)) df 8.7.3 Case 3 How to extract numbers of each token and compute the sum of the number and save the results in a new column SUM? df &lt;- tibble( x = c(&quot;1234&quot;, &quot;B246&quot;, &quot;217C&quot;, &quot;2357f&quot;, &quot;21WD4&quot;) ) df Exercise 8.11 How to extract all the numbers that follow a upper-casing letter? For example, 34 after W; 217 after B? df &lt;- tibble( x = c(&quot;12W34&quot;, &quot;AB2C46&quot;, &quot;B217C&quot;, &quot;akTs6df&quot;, &quot;21WD4&quot;) ) df Exercise 8.12 Based on Exercise 8.11, can you add another column to the resulting data frame, which records the upper-casing letter that the numbers follow for each row? Hint: Check str_match_all() and tidyr::unnest() 8.8 Case Study: Chinese Four-Character Idioms Many studies have shown that Chinese makes use of large proportion of four-character idioms in the discourse. Let’s have an exploratory analysis of four-character idioms in Chinese. 8.8.1 Dictionary Entries In our demo_data directory, there is a file demo_data/dict-ch-idiom.txt, which includes a list of four-character idioms in Chinese. These idioms are collected from 搜狗輸入法詞庫 and the original file formats (.scel) have been combined, removed of duplicate cases, and converted to a more machine-readable format, i.e., .txt. Let’s first load the idioms dataset in R. all_idioms &lt;- readLines(con = &quot;demo_data/dict-ch-idiom.txt&quot;,encoding = &quot;UTF-8&quot;) head(all_idioms) ## [1] &quot;阿保之功&quot; &quot;阿保之勞&quot; &quot;阿鼻地獄&quot; &quot;阿鼻叫喚&quot; &quot;阿斗太子&quot; &quot;阿芙蓉膏&quot; tail(all_idioms) ## [1] &quot;罪無可逭&quot; &quot;罪人不帑&quot; &quot;作纛旗兒&quot; &quot;坐纛旂兒&quot; &quot;作姦犯科&quot; &quot;作育英才&quot; length(all_idioms) ## [1] 56536 In order to make use of the tidy structure in R, we convert the data into a tibble: idiom &lt;- tibble(string = all_idioms) 8.8.2 Case Study: X來Y去 We can create a regular expression pattern to extract all idioms with the format of X來X去: idiom %&gt;% filter(str_detect(string, &quot;.來.去&quot;)) To analyze the meaning of this constructional schema, we may need to extract the X and Y in the schema: idiom_laiqu &lt;-idiom %&gt;% filter(str_detect(string, &quot;.來.去&quot;)) %&gt;% mutate(pattern = str_replace(string, &quot;(.)來(.)去&quot;, &quot;\\\\1_\\\\2&quot;)) %&gt;% separate(pattern, into = c(&quot;w1&quot;, &quot;w2&quot;), sep = &quot;_&quot;) idiom_laiqu # # version 2 # require(tidyr) # idiom %&gt;% # filter(str_detect(string, &quot;.來.去&quot;)) %&gt;% # mutate(string2 = string) %&gt;% # tidyr::extract(col=&quot;string2&quot;, # into=c(&quot;w1&quot;,&quot;w2&quot;), # regex = &quot;(.)來(.)去&quot;) One empirical question is how many of these idioms are of the pattern W1 = W2 (e.g., 想來想去, 直來直去) and how many are of the pattern W1 != W2 (e.g., 說來道去, 朝來暮去): idiom_laiqu %&gt;% mutate(structure = ifelse(w1==w2, &quot;XX&quot;,&quot;XY&quot;)) %&gt;% count(structure) idiom_laiqu %&gt;% mutate(structure = ifelse(w1==w2, &quot;XX&quot;,&quot;XY&quot;)) %&gt;% count(structure) %&gt;% ggplot(aes(structure, n, fill = structure)) + geom_col() Exercise 8.13 Please use same dataset idiom (loaded from demo_data/dict-ch-idiom.txt) and extract all the idioms that fall into the schema of 一X一Y. idiom &lt;- tibble(string = readLines(&quot;demo_data/dict-ch-idiom.txt&quot;)) Exercise 8.14 Also with the idiom as our data source, now if we are interested in all idioms that have duplicated characters in them, with schemas like either _A_A or A_A_, where A is a fixed character. How can we extract all idioms of these two types from idiom? Also, please visualize the distribution of the two idiom types using a bar plot. Sample answers have been provided below. Idioms with duplicate characters in them Type Distribution Exercise 8.15 Following Exercise 8.14, for each type of the idioms (i.e., “A_A_” or &quot;_A_A&quot;), please provide their respective proportions of W1 = W2 vs. W1 != W2, where W1 and W2 refer to the words filled in the variable slots of the idiomatic templates. The following table is a random sample of aech idiom type (5 tokens for each type) (Not sure if you can get the exact sample results with set.seed(123)): "]
]
