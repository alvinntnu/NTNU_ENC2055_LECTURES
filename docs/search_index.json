[
["index.html", "ENC2055: Introduction to Programming Languages for Linguistic Analysis Preface Course Objective Textbook Course Website Course Demo Data Questions?", " ENC2055: Introduction to Programming Languages for Linguistic Analysis Alvin Chen 2020-03-14 Preface Welcome to ENC2055 Introduction to Programming Languages for Linguistic Analysis. This is a graduate-level course tailored to those who are interested in computational text analytics and data science in general. Have you decided to embark upon a digital journey to your future career, there are a series of courses provided in the Department of English, NTNU, Taiwan, offerring necessary skills and knowledge in important disciplines. This introductory course in basic computational coding would be a prerequisite course for many other advance-level courses. In particular, our faculty in the Linguistics track is dedicated to research on both theoretical and applied linguistics. Along with courses offered by other faculty members, this course provides a necessary foundation for the burgeoning discipline of computational linguistics. Course Objective The objective of this course is to provide a comprehensive introduction to programming languages with a special focus on its application in linguistic analyses. This course is especially tailored to those who do not have any background or experiences in coding. We will start from the very basic concepts, such as data types, variable assignments, control structures, to more complex procedures such as routines, functions, and other exploratory project-based tasks. The course consists of a series of theme-based hands-on tutorials, which demonstrate how the flexibility of the programming language can help you become a more efficient and productive data scientist. Specifically, this course will use the language R as our featuring programming language and introduce you to R, Rstudio, and a collection of R packages designed to work together to make linguistic analyses fast, fluent, and fun. By the end of the course, students should have a working knowledge of coding and an initial ability to advance a project independently as a data scientist. In this course, we will not be dealing with complex maths like: \\[ f(x)=\\frac{1}{\\sqrt{2 \\pi}} e^{-\\frac{1}{2} x^{2}} \\] \\[ P(A) = \\sum P(\\{ (e_1,\\dotsc,e_N) \\}) = \\binom{N}{k} \\cdot p^kq^{N-k} \\] We will not be dealing with lingusitic theories as well. No transformations. No movements. No bindings. This course is all about computational coding. library(tidyverse) summary_monthly_temp &lt;- weather %&gt;% group_by(month) %&gt;% summarize(mean = mean(temp), std_dev = sd(temp)) Textbook Throughout the semester, we will follow the materials provided on our course website (see below). We will not use a particular textbook for the course. However, I do like to recommend Wickham and Grolemund (2017) for its simplicity. Also, another great book for R lovers, by Davies (2016): Course Website We have a course website. You may need a password to get access to the course materials. If you are an officially enrolled student, please ask the instructor for the access code. Course Demo Data Dropbox Demo Data Directory Questions? For more information related to this course, please see the FAQ on our course website or write me at any time at: alvinchen@ntnu.edu.tw References "],
["intro-ds.html", "Chapter 1 Data Science and R 1.1 What is Data Science? 1.2 Working Pipeline for Data Science 1.3 Why R? 1.4 tidyverse 1.5 More Skills", " Chapter 1 Data Science and R 1.1 What is Data Science? Data Science is an interdisciplinary subject, which integrates knowledge of statistics, computer science and other domina-specific areas. A graph by Drew Conway may summarize the essense of Data Science: 1.2 Working Pipeline for Data Science Hadley Wickham’s R for Data Science describes six important steps for data analysis: 1.3 Why R? According to a report by KDnuggets, among all the languages used by data scientists, python and R are the most popular two languages: It is true that Python now seems much more popular among developers. That being said, you may consult this article, &lt;&lt; Why R is the Best Data Science Language to Learn Today? &gt;&gt;, for a more comprehensive review of the strengths of R. The general tendency is that: if you want to go into the industry and take developers or programmers as your future career, you can choose python; if you are planning to settle yourself in the academia, I would definitely recommend R. Here are a list of strengths for R language: powerful statistical analysis data visualization exploratory analysis re-usable reports tidyverse consistent grammar/syntax high readability of the codes, similar to human languages ( %&gt;% is a unique R feature!) In this course, our main objective is to introduce you to the world of coding. A high-level programming language like R would be a very friendly start, especially for those who have no background of computing. So, let us enjoy the journey of a simple yet powerful language learning! 1.4 tidyverse In this course, we will be working on a collection of packages included in tidyverse. This is a unique package in R, which can help you deal with data in a massively convenient way. It is hoped that the user can easily call particular functions and make use of the pipe operator %&gt;% to concatenate all your procedures serially, just like our natural languages. In particular, we will work on the following major libraries included in tidyverse: ggplot2: Data visualization dplyr: Data wrangling tidyr: Data wrangling stringr: String manipulation readr: Data importing purrr: Functional programming to avoid loops tibble: Powerful data structure 1.5 More Skills Data scientists are now becoming more and more popular. To know more about this job, one thing you may want to know is what kinds of skills are needed? The following two graphs were taken from &lt;The Most in Demand Skills for Data Scientists&gt;: While people still have various definitions regarding what data science encompasses, there are indeed several practical fields that have been commonly regarded as part of the definitions of Data Science. According to Mason and Wiggins (2010) A Taxonomy of Data Science, data science can be defined according to five crucial steps: Obtain: pointing and clicking does not scale. Scrub: the world is a messy place Explore: You can see a lot by looking Models: always bad, sometimes ugly iNterpret: “The purpose of computing is insight, not numbers.” This OSEMN (awesome!!) model should give you a much clearer picture of what you need to become a proficient data scientist. What we do here in this course is just a start….Take a deep breath:) "],
["r-fundamentals.html", "Chapter 2 R Fundamentals 2.1 Installing R 2.2 Installing RStudio 2.3 The Interface of Rstudio 2.4 Assignment 2.5 Data Structure 2.6 Function 2.7 Vectorization 2.8 Script 2.9 Library 2.10 Setting 2.11 Seeking Help 2.12 Language Learning Ain’t Easy! 2.13 Keyboard Shortcuts", " Chapter 2 R Fundamentals Download R: R-Project IDE: RStudio 2.1 Installing R Download the installation file: http://cran.r-project.org 2.2 Installing RStudio After you install R, you may install RStudio. RStudio is an editor which can help you write R codes. A good analogy is that R is the engine and Rstudio is the dashboard of the car. Please download the right version that is compatible with your PC operating system. https://www.rstudio.com/download Choose RStudio Desktop Important notes: Do not have Chinese characters in your directory names or on the path to the files Do not have spaces and weird symbols in your file path: D:/R D:/Rstudio /User/Alvinchen/ 2.3 The Interface of Rstudio When you start Rstudio, you will see an interface as follows: Figure 2.1: Rstudio Interface Rstudio Interface: Editor: You creat and edit R-related files here (e.g., *.r, *.Rmd etc.) Console: This is the R engine, which runs the codes we send out either from the R-script file or directly from the console input Output: You can view graphic outputs here The R console is like a calculator. You can type any R code in the console after the prompt &gt; and run the code line by line by pressing enter. 1 + 1 ## [1] 2 log(10) ## [1] 2.302585 1:5 ## [1] 1 2 3 4 5 Or alternatively, we can create an R script in Rstudio and write down lines of R codes to be passed to the R console. This way, we can run the whole script all at once. This is the idea of writing a program. In the above example (Figure 2.1), I wrote a few lines of codes in a R script file (cf. the Editor frame) and asked R to run these lines of codes in the R Console. And the graphic output of the R script was printed in the Output frame. Exercise 2.1 Please create a new R script in Rstudio. You may name the script as “ch2.R”. Please write the following codes in the script and pass the whole script to the R Console. scores &lt;- rnorm(1000, mean = 75, sd = 5.8) plot(density(scores)) hist(scores) boxplot(scores) Exercise 2.2 Find the answer to the following mathematical calculation in R. \\(2^{2+1}-4+64^{(-2)^{2.25-\\frac{1}{4}}}\\) = 16777220 2.4 Assignment R works with objects of many different classes, some of which are defined in the base R while others are defined by specific libaries/environments/users. You can assign any object created in R to a variable name using &lt;-: x &lt;- 5 y &lt;- &quot;wonderful&quot; Now the objects are stored in the variables. You can print out the variables by either making use of the auto-printing (i.e., the variable name itself auto-prints its content) or print(): x ## [1] 5 print(x) ## [1] 5 y ## [1] &quot;wonderful&quot; print(y) ## [1] &quot;wonderful&quot; 2.5 Data Structure In R, the most primitive object is a vector. There are two types of primitive vectors: (a) numeric and (b) character vectors. In our previous examples, x is a numeric vector of one element; y is a character vector of one element. All elements in the vector have to be of the same data type. You use c() to create a vector of multiple elments. Within the parenthesis, you concatenate each element of the vector by ,: x2 &lt;- c(1, 2, 3, 4, 5, 6) x2 ## [1] 1 2 3 4 5 6 y2 &lt;- c(&quot;wonderful&quot;, &quot;excellent&quot;, &quot;brilliant&quot;) y2 ## [1] &quot;wonderful&quot; &quot;excellent&quot; &quot;brilliant&quot; Other data structures that we often work with include: List: a vector-like structure, but can consist of elements of different data types Matrix: a two-dimensional vector, where all elements have to be of the same data type Data Frame: a spreadsheet-like table, where columns can be of different data types ex_list &lt;- list(&quot;First element&quot;, 5:10, TRUE) print(ex_list) ## [[1]] ## [1] &quot;First element&quot; ## ## [[2]] ## [1] 5 6 7 8 9 10 ## ## [[3]] ## [1] TRUE ex_array &lt;- matrix(c(1,5,6,3,8,19),byrow = T, nrow = 2) ex_array ## [,1] [,2] [,3] ## [1,] 1 5 6 ## [2,] 3 8 19 ex_df &lt;- data.frame( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34) ) ex_df The following graph shows you an intuitive understanding of the data structures in R. We will discuss more on data structures in Chapter 4. 2.6 Function Function is also an object class. There are many functions pre-defined in the R-base libraries. class(c) ## [1] &quot;function&quot; class(vector) ## [1] &quot;function&quot; class(print) ## [1] &quot;function&quot; To instruct R to do things more precisely, a function call usually has many parameters to specify. Take the earlier function matrix() for example. It is a pre-defined function in the R base library. ex_array &lt;- matrix(c(1,5,6,3,8,19),byrow = T, nrow = 2) ex_array ## [,1] [,2] [,3] ## [1,] 1 5 6 ## [2,] 3 8 19 When creating a matrix, we specify the values for the parameters, byrow = and nrow =. These specifications tell R to create a matrix with N rows and arrange the numbers by rows. The actual values of the parameters that we use, i.e., T and 2, are referred to as arguments. Parameter is a variable in the declaration of function. Argument is the actual value of this variable that gets passed to function. Most importantly, we can define our own function, which is tailored to perform specific tasks. All self-created functions need to be defined first in the R environment before you can call them. Define own functions: print_out_user_name &lt;- function(name = &quot;&quot;){ cat(&quot;The current username is: &quot;, name, &quot;\\n&quot;) } Call own functions: print_out_user_name(name = &quot;Alvin Cheng-Hsien Chen&quot;) ## The current username is: Alvin Cheng-Hsien Chen print_out_user_name(name = &quot;Ada Lovelace&quot;) ## The current username is: Ada Lovelace Exercise 2.3 Please define a function called make_students_happy(), which takes a multi-element numeric vector, and returns also a numeric vector, with the value of each element to be the square root of the original value multiplied by 10. student_current_scores &lt;- c(20, 34, 60, 87, 100) make_students_happy(old_scores = student_current_scores) ## [1] 44.72136 58.30952 77.45967 93.27379 100.00000 2.7 Vectorization Many operations in R are vectorized, meaning that operations occur in parallel in certain R objects. This allows you to write code that is efficient, concise, and easier to read than in non-vectorized languages. The simplest example of vectorized functions is when adding two vectors together. x &lt;- 1:4 y &lt;- 6:9 z &lt;- x + y z ## [1] 7 9 11 13 Without vectorization, you mean need to do the vector adding as follows: z &lt;- numeric(length = length(x)) for(i in 1:length(x)){ z[i] &lt;- x[i]+y[i] } # endfor z ## [1] 7 9 11 13 Other common vectorized functions include: x &gt;= 5 ## [1] FALSE FALSE FALSE FALSE x &lt; 2 ## [1] TRUE FALSE FALSE FALSE y == 8 ## [1] FALSE FALSE TRUE FALSE For more information on vectorization, please watch the following youtube clip from Roger Peng. 2.8 Script In our earlier demonstrations, we ran R codes by entering each procedure line by line. We can create one script file with the Editor of Rstudio and include all our R codes in the file, which usually has the file extension of .R. And then we can run the whole script in the R script all at once in the Rstudio. First you open the *.R script file in Rstudio, which should appear in the Editor frame of the Rstudio. To run the whole script from start to the end, select all lines in the script file and press ctrl/cmd + shift + enter. To run a particular line of the script, put your mouse in the line and press ctrl/cmd + enter. 2.9 Library R, like other programming languages, comes with a huge database of packages and extensions, allowing us to do many different tasks without worrying about writing the codes all from the scratch. In CRAN Task Views, you can find specific packages that you need for particular topics/tasks. To install a package (i.e., library): install.packages(&quot;tidyverse&quot;) install.packages(c(&quot;ggplot2&quot;, &quot;devtools&quot;, &quot;dplyr&quot;)) 2.10 Setting Always set your default encoding of the files to UTF-8: 2.11 Seeking Help In the process of (learning) programming, one thing you will never be able to dodge is a strong desire for help. Here are the sources from which you may get additional assistance. Within Rstudio, in the R console, you can always use ? to check the documentation of a particular function (cf. Figure 2.2). When you run the command, you will see the documentation popping up in the output frame of the Rstudio. ?log ?read.table Figure 2.2: Help 1 If you need help from others, the first step is to create a reproducible example. The goal of a reproducible example is to package your problematic code in such a way that other people can run it and feel your pain. Then, hopefully, they can provide a solution and put you out of your misery. Figure 2.3: Help 2 So before you seek help from others (or before you yell at others for help, cf. Figure 2.3) : First, you need to make your code reproducible. This means that you need to capture everything, i.e., include any library() calls and create all necessary objects (e.g., files). The easiest way is to check the objects listed in the Environment tab of the Rstudio and identify objects that are relevant to your problematic code chunk. Second, you need to make it minimal. Strip away everything that is not directly related to your problem. This usually involves creating a much smaller and simpler R object than the one you’re facing in real life or even using built-in data. That sounds like a lot of work! And it can be, but it has a great payoff: 80% of the time creating an excellent reproducible example reveals the source of your problem. It’s amazing how often the process of writing up a self-contained and minimal example allows you to answer your own question. The other 20% of time you will have captured the essence of your problem in a way that is easy for others to play with. This substantially improves your chances of getting help! The following is a list of resources where people usually get external assistance quickly: http://www.r-project.org/mail.html http://stackoverflow.com/ Quick R: http://www.statmethods.net/ R CRAN Task Views: https://cran.r-project.org/web/views/ R for Data Science Text Mining with R R communities: R-Bloggers: https://www.r-bloggers.com/ kaggle: https://www.kaggle.com/ stackoverflow: https://stackoverflow.com/questions/tagged/r rstudio: https://community.rstudio.com/ 2.12 Language Learning Ain’t Easy! Learning R is like learning another foreign language. It should be a long journey. You can’t expect yourself to learn all the vocabuary of the new language in one day. Also, you will forget things you learn all the time. Everyone’s been there. When your script does not work as expected, don’t be frustrated. Take a break and resume later. What I can say is that: it is always NORMAL to debug a script for hours or even days via endless searches on Google. That being said, here I would like to share with you some of the most common problems we may run into: You created an R script file (*.r) and opened it in the Rstudio, but the script didn’t work simply because you didn’t execute the script in R console (i.e., you didn’t send the script to R console.) If you get an error message, saying &quot;object not found&quot;, check the object name again and see if you have mistyped the name of the object. If not, check your current environment and see if you have forgot to execute some assignment commands in the previous parts of the script (i.e., the object has NOT even been created yet). If you get an error message, saying &quot;function not found&quot;, check the function and see if you have the correct name. Or more often, check if you have properly loaded the necessary libraries where the function is defined. To understand the meaning of the error messages is crucial to your development of R proficiency. To achieve this, you have to know very well every object name you have created in your script (as well as in your environment). For example: What type of object is it? (i.e., the class of the object, e.g., vector, list, data.frame?) For primitive vectors, what data type does the vector belong to? (e.g., numeric, character, boolean,factor?) What is the dimensionality of the object? (nrows, ncols?) Sometimes the script fails simply because of the obvious syntactic errors. Pay attention to all the punctuations in every R command. They are far more important (or lethal) than you think. They include: ,: commas between arguments inside a function &quot;: quotes for strings/characters (): parentheses for functions {}: curly brackets for control structures From my experiences, about 80 percent of the errors may in the end boil down to a simple typo. No kidding. Copy-and-paste helps. DO NOT assume that your R script always works as intended! Always keep two questions in mind: Did R produce the intended result? What is included in the R object name? 2.13 Keyboard Shortcuts The best way to talk to a computer is via the keyboard. Scripting requires a lot of typing. Keyboard shortcuts may save you a lot of time. Here are some of the handy shortcuts: Crtl/Command + Enter: run the current line (send from the script to the console) Crtl/Command + A: select all Crtl/Command + C: copy Ctrl/Command + X: cut Ctrl/Command + V: paste Ctrl/Command + Z: undo (Mac) Alt/Option + Left/Right: move cursor by a word (Windows) Ctrl + Left/Right: move cursor by a word (Mac) Command + Left/Right: move cursor to the beginning/end of line (Windows) Home/End: move cursor to the beginning/end of line (Mac) Command + Tab: switch in-between different working windows/apps Ctrl/Command + S: save file Command + Shift + C: comment/uncomment selected lines Exercise 2.4 Make yourself familiar with the iris data set, which is included in R. Exercise 2.5 Use ? to make youself familiar with the following commands: str,summary, dim, colnames, names, nrow, ncol, head, and tail. What information can you get with all these commands? Exercise 2.6 Write a function to compute the factorial of a non-negative integer, x, expressed as x!. The factorial of x refers to x multiplied by the product of all integers less than x, down to 1. For example, 3! = 3 x 2 x 1 = 6. The special case, zero factorial is always defined as 1. Confirm that your function produce the same results as below: (i) 5! = 120; (ii) 120! = 479,001,600; (iii) 0! = 1. # A Sample Format for your Function myfac &lt;- function(x){ } ##(i) myfac(5) ## [1] 120 ##(ii) myfac(12) ## [1] 479001600 ##(iii) myfac(0) ## [1] 1 "],
["code-format-convetion.html", "Chapter 3 Code Format Convention 3.1 Assignment &lt;- 3.2 Comment # 3.3 Script Naming 3.4 Object Naming 3.5 Whitespace 3.6 Indention and Linebreaks 3.7 More References 3.8 Template for Script Assignments", " Chapter 3 Code Format Convention Like the first time we learn English writing, we need to know the conventional writing styles and formats in coding as well. This is very important because scripts of good formats would increase their readability. This would save us a lot of time in case of future debugging and maintenace. This chapter will discuss common practices among most R users. 3.1 Assignment &lt;- In R, people normally use &lt;- to assign values to object names. In other languages such as Python, people often use =. Although R still understands the value-assignment when you use =, I would still suggest to use &lt;- just to avoid the chance of confusing your R. x1 &lt;- &quot;This is a sentence.&quot; x2 = &quot;This is a sentence.&quot; x1 ## [1] &quot;This is a sentence.&quot; x2 ## [1] &quot;This is a sentence.&quot; 3.2 Comment # When you write codes, you would need to commit your code extensively. This is very important because we often forget why and how we write it this way. In your R script, any strings after the # will be treated as comments, which will NOT be processed by R. We can often add additional - and = after the # to separate different code chunks. # ==================== # Variable Assignment # ==================== x &lt;- &quot;This is a sentence&quot; # ==================== # Variable Printing # ==================== x ## [1] &quot;This is a sentence&quot; 3.3 Script Naming When you name your R script files, don’t be TOO creative. Use meaningul strings. Most importantly, use alphanumeric characters ONLY. Never use Chinese characters. For multiword names, it is suggested to connect words with -. # Recommended my-first-script.R my-first-assignment.R # NOT Recommended my first script.R 語料庫assingment1.R 3.4 Object Naming In your script, you will create lots of objects. Spend some time thinking about how to name all these objects. Choose names that are intuitive and meaningful. It is often the case that you want to keep the names simple (as typing is really annoying) but easy to understand as well. There are some principles: Use nouns for the object names (e.g., PTT_corpus) Use verbs for the function names (e.g., generate_ngrams()) Connect multiword names with _ (e.g., PTT_corpus_segmented) Avoid using characters/strings that have been used by R (e.g., vector, c, mean, sum, T etc.) 3.5 Whitespace For operators (i.e., =, +, -, &lt;-), they are usually embraced by whitespaces, which would make your script easier to read: # Recommended grade_average &lt;- mean(midterm * 0.5 + final * 0.5) # NOT Recommended grade_average&lt;-mean(midterm*0.5+final*0.5) For : and ::, usually we do not put whitespaces around them: # Recommended x &lt;- c(1:10) tidyr::separate() # NOT Recommended x &lt;- c(1 : 10) tidyr :: separate() : is an expression in R to create a sequence of numbers. For example, c(1:10) is the same as c(1,2,3,4,5,6,7,8,9,10). :: is an expression to access a particular object/function from a library without having the entire library loaded in your current R environment. For example, tidyr::separate() calls the function separate() from the library tidyr but the other objects in tidyr are still NOT included. You cannot use the other objects defined in tidyr. For parentheses (, if it is in the control structure, we usually put a whitespace before the initial (: for (i in 1:10) if ( x == 1) But if the parenthesis is in the function call (i.e., where we specify the arguments of the parameters), we don’t put a whitespace before the initial (: mean(x) ggplot(aes(x = money, y = achievement)) For curely brackets, we usually put a linebreak after the initial { and the ending } should be one single line. Also, as sometimes you would embed many different control structures at the same time, leading to many ending } lines, it is always good to commit properly which ending } goes with which control structure. for (i in 1:10) { if (i &lt; 5){ print(i) } else { print(i+10) } #endif } #endfor ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 15 ## [1] 16 ## [1] 17 ## [1] 18 ## [1] 19 ## [1] 20 3.6 Indention and Linebreaks R does not care about line breaks, whitespaces, or tabs in your R script. But these formating characters are important because you need all these characters to help you quickly keep track of the script’s structure. Make good use of the indention to increase the readability of your script. long_function_name &lt;- function(a = &quot;a long argument&quot;, b = &quot;another argument&quot;, c = &quot;another long argument&quot;) { # As usual code is indented by two spaces. } 3.7 More References Readability of your code is an art. Please consult the following recommended readings if you are interested in more principles of clean code. 3.8 Template for Script Assignments When you submit your R scripts, please follow the format specified below. Important notes include: Please include the practice codes discussed in each chapter. Please specify the start and end of each of your exercise solution. Please indicate very clearly the chapter number and title as well as the exercise number in your script. Please name your R script as follows: ch2-alvin.R, ch3-alvin.R "],
["subsetting.html", "Chapter 4 Subsetting 4.1 Vector 4.2 Factor 4.3 List 4.4 Data Frame 4.5 Tibble", " Chapter 4 Subsetting Subsetting is very important. To subset is to select a particular subset of elements from a data structure (e.g., vecotr, matrix, data.frame, list). In Chapter 2, we discuss very briefly about data structures. Here we will look at each type of data structure in more detail and introduce ways of subsetting them. 4.1 Vector As we have shown in Chapter 2 R Fundamentals, there are three types of primitive vectors in R: character vectors numeric vectors boolean vectors You can assess a particular subset of a vector by using[ ] right after the object name. Within the [], you can make use of at least three types of indexes: Subsetting with numeric index char.vec &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;) char.vec[1] ## [1] &quot;one&quot; You can also assess several elements of a vector by putting in several indices, c(), in the []: char.vec[c(1,4)] ## [1] &quot;one&quot; &quot;four&quot; Subsetting with boolean index You can also use a boolean vector as the index: whether.to.extract &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) char.vec[whether.to.extract] ## [1] &quot;one&quot; &quot;three&quot; You may use different logical operators to check each element of the vector according to some criteria. R will decide whether elements of the vector satisfy the condition given in the logical expression and return a boolean vector of the same length. Common logical operators include: ==: equal to &amp;: and |: or &gt;: greater than &gt;=: greater than or equal to &lt;: less than &lt;=: less than or equal to !=: not equal This can be very useful for vector subsetting: num.vec &lt;- c(1:20) num.vec &gt; 10 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE num.vec[num.vec &gt; 10] ## [1] 11 12 13 14 15 16 17 18 19 20 num.vec[num.vec != 10] ## [1] 1 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 20 num.vec[num.vec &gt; 18 | num.vec &lt; 2] ## [1] 1 19 20 Subsetting with negative numeric index If you use negative numbers in the index [], you will get a new vector printed on the console, with those indexed elements removed: char.vec[-2] ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; However, please note that the original vector is still the same in length: char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; If you want to save the shortened vector, you can either (a) assign the shortened vector to a new object name or (b) assign the shortened vector to the same object name: char.vec.short &lt;- char.vec[-2] char.vec.short ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; char.vec &lt;- char.vec[-2] char.vec ## [1] &quot;one&quot; &quot;three&quot; &quot;four&quot; &quot;five&quot; For the two alternatives, which one would be better? Why? Exercise 4.1 Create a vector m with the small letters from a to j (in alphabetical order). hint: check letters m ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; Exercise 4.2 Create a vector n with the samll letters from a to j (in random order). hint: check sample() n ## [1] &quot;g&quot; &quot;i&quot; &quot;c&quot; &quot;h&quot; &quot;e&quot; &quot;f&quot; &quot;d&quot; &quot;j&quot; &quot;b&quot; &quot;a&quot; Exercise 4.3 Determine whether letters in n are at the same positions as in m. How many such cases do you find? Which letters are these? hint: check table() ## ## FALSE TRUE ## 7 3 ## [1] &quot;c&quot; &quot;e&quot; &quot;f&quot; 4.2 Factor In Chapter 2, we did not talk about this data structure–factor. There is an obvious reason for that. A factor works pretty much similarly to a vector in R. One of the key features for a factor is that its values are limited to a finite number of dinstinct categories. In many statistical experimental designs, a factor is usually a grouping factor, i.e., a factor that groups the subjects into sub-groups. We usually create a factor from a numeric or character vector. To create a factor, use factor(): sbj_gender_num &lt;- c(1, 0, 0, 1, 1, 0, 1) sbj_gender_num ## [1] 1 0 0 1 1 0 1 sbj_gender_char &lt;- c(&quot;female&quot;,&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;,&quot;male&quot;,&quot;female&quot;) sbj_gender_char ## [1] &quot;female&quot; &quot;male&quot; &quot;male&quot; &quot;female&quot; &quot;female&quot; &quot;male&quot; &quot;female&quot; sbj_gender_num_fac &lt;- factor(x = sbj_gender_num) sbj_gender_num_fac ## [1] 1 0 0 1 1 0 1 ## Levels: 0 1 sbj_gender_char_fac &lt;- factor(x = sbj_gender_char) sbj_gender_char_fac ## [1] female male male female female male female ## Levels: female male For a factor, the most important information is its levels, i.e., the limit set of all possible values this factor can take. We can extract the levels as a vector of character strings using levels(): levels(sbj_gender_num_fac) ## [1] &quot;0&quot; &quot;1&quot; levels(sbj_gender_char_fac) ## [1] &quot;female&quot; &quot;male&quot; When do we need a factor? Sometimes when we do the annotation of the data, we use arbitrary numbers as labels for certain categorical labels. For example, we may use arbitrary numbers from 1 to 4 to label learners of varying proficiency levels: 1 = beginners, 2 = low-intermediate, 3 = upper-intermediate, 4 = advanced. When we read the data into R, R may first treat the data as a numeric vector: sbj_prof_num&lt;- c(1, 2, 4, 4, 2, 3, 3, 1, 1) sbj_prof_num ## [1] 1 2 4 4 2 3 3 1 1 However, these numbers may be confusing to the extent that (a) R may even consider them really to be numbers, or (b) they are not intuitive at all as numbers do not have meanings. In this case, we can create a factor from this numeric vector and re-label these numeric values into categorical labels that are more intuitive. We can do this by setting more argments in factor(), such as levels=..., labels=.... sbj_prof_fac &lt;- factor(x = sbj_prof_num, levels = c(1:4), labels = c(&quot;beginner&quot;,&quot;low-inter&quot;,&quot;upper-inter&quot;,&quot;advanced&quot;)) sbj_prof_fac ## [1] beginner low-inter advanced advanced low-inter upper-inter ## [7] upper-inter beginner beginner ## Levels: beginner low-inter upper-inter advanced levels = ...: this argument specifies all possible values this factor can take labels = ...: this argument provides own intuitive labels for each level It should now therefore be clear that labels = ... is a good way for us to re-label any artitrary annotations into meaningful labels. What’s even more brilliant is that we can decide whether the ranking of the levels is meaningful. If the order of the levels of the factor is meaningful, we can set the argument ordered = TRUE: sbj_prof_fac_ordered &lt;- factor(x = sbj_prof_num, levels = c(1:4), labels = c(&quot;beginner&quot;,&quot;low-inter&quot;,&quot;upper-inter&quot;,&quot;advanced&quot;), ordered = T) sbj_prof_fac_ordered ## [1] beginner low-inter advanced advanced low-inter upper-inter ## [7] upper-inter beginner beginner ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced Now from the R console we can see not only the levels of the factor but also the signs &lt;, indicating their order. Using this ordered factor, we can perform relational comparison: sbj_prof_fac_ordered[1] ## [1] beginner ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced sbj_prof_fac_ordered[4] ## [1] advanced ## Levels: beginner &lt; low-inter &lt; upper-inter &lt; advanced sbj_prof_fac_ordered[1] &lt; sbj_prof_fac_ordered[4] ## [1] TRUE But we cannot do the comparison for unordered factors (characters neither): sbj_prof_fac[1] ## [1] beginner ## Levels: beginner low-inter upper-inter advanced sbj_prof_fac[4] ## [1] advanced ## Levels: beginner low-inter upper-inter advanced sbj_prof_fac[1] &lt; sbj_prof_fac[4] ## Warning in Ops.factor(sbj_prof_fac[1], sbj_prof_fac[4]): &#39;&lt;&#39; not meaningful for ## factors ## [1] NA The difference between vector and factor may look trivial for the moment but they are statistically very crucial. The choice of whether to instruct R to treat a vector as a factor, or even an ordered factor, will have important consequences in the implementation of many statistical methods, such as regression or othe generalized linear modeling. Rule of thumb: Always pay attention to what kind of object class you are dealing with:) 4.3 List A List is like a vector, which is a one-dimensional data structure. However, the main difference is that a List can include a series of objects of different classes: # A list consists of (i) numeric vector, (ii) character vector, (iii) boolean vector list.example &lt;- list(&quot;one&quot; = c(1,2,3), &quot;two&quot; = c(&quot;Joe&quot;, &quot;Mary&quot;, &quot;John&quot;,&quot;Angela&quot;), &quot;three&quot; = c(TRUE, TRUE)) list.example ## $one ## [1] 1 2 3 ## ## $two ## [1] &quot;Joe&quot; &quot;Mary&quot; &quot;John&quot; &quot;Angela&quot; ## ## $three ## [1] TRUE TRUE Please note that not only the class of each object in the List does not have to be the same; the length of each list element may also vary. You can subset a List in two ways: [: This always returns a List back [[: This returns the object of the List element, which is NOT NECESSARILY a List list.example[1] ## $one ## [1] 1 2 3 list.example[[1]] ## [1] 1 2 3 list.example[[&quot;one&quot;]] ## [1] 1 2 3 Before you try the following codes on the R console, could you first predict the outputs? ind &lt;- c(&quot;one&quot;, &quot;three&quot;) list.example[ind] list.example[[ind]] Exercise 4.4 Create a list that contains, in this order: a sequence of 20 evenly spaced numbers between -4 and 4; (hint: check seq()) a 3 x 3 matrix of the logical vector c(F,T,T,T,F,T,T,F,F) filled column-wise; a character vector with the two strings “don”, and “quixote”; a factor containing the observations `c(“LOW”,“MID”,“LOW”,“MID”,“MID”,“HIGH”. ## [[1]] ## [1] -4.0000000 -3.5789474 -3.1578947 -2.7368421 -2.3157895 -1.8947368 ## [7] -1.4736842 -1.0526316 -0.6315789 -0.2105263 0.2105263 0.6315789 ## [13] 1.0526316 1.4736842 1.8947368 2.3157895 2.7368421 3.1578947 ## [19] 3.5789474 4.0000000 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] FALSE TRUE TRUE ## [2,] TRUE FALSE FALSE ## [3,] TRUE TRUE FALSE ## ## [[3]] ## [1] &quot;don&quot; &quot;quixote&quot; ## ## [[4]] ## [1] LOW MID LOW MID MID HIGH ## Levels: HIGH LOW MID Exercise 4.5 Based on Exercise 4.4, extract row elements 2 and 1 of columns 2 and 3, in that order, of the logical matrix. ## [,1] [,2] ## [1,] FALSE FALSE ## [2,] TRUE TRUE Exercise 4.6 Based on Exercise 4.4, obtain all values from the sequence between -4 and 4 that are greater than 1. ## [1] 1.052632 1.473684 1.894737 2.315789 2.736842 3.157895 3.578947 4.000000 Exercise 4.7 Make yourself familar with the function which(). Based on Exercise 4.4, using which(), determine which indexes in the factor are assigned the “MID” level. ## [1] 2 4 5 4.4 Data Frame data.frame is the most frequently used object that we will work with in data analysis. It is a typical two-dimensional spreadsheet-like table. Normally, the rows are the subjects or tokens we are analyzing; the columns are the variables or factors we are interested in. We can also use [ , ] to subset a data frame. The indexes in [ , ] are Row-by-Column. ex_df &lt;- data.frame( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34) ) ex_df You can subset a particular row of the data frame: ex_df[1,] ex_df[c(1,3),] You can subset a particular column of the data frame: ex_df[,1] ## [1] the boy you him ## Levels: boy him the you ex_df[,c(1,3)] ex_df[,c(&quot;WORD&quot;,&quot;FREQ&quot;)] Please compare the following two ways of accessing a column from the data frame. Can you tell the differences in the returned results? ex_df[, c(&quot;FREQ&quot;)] ex_df[, c(&quot;FREQ&quot;), drop = FALSE] Exercise 4.8 Create and store the following data frame as dframe in your R workspace. person should be a character vector sex should be a factor with levels F and M funny should be a factor with levels Low, Mid, and High Exercise 4.9 Stan and Francine are 41 years old, Steve is 15, Hayley is 21, and Klaus is 60. Roger is extremely old–1,600 years. Following Exercise 4.8, append these data as a new numeric column variable in dframe called age. Exercise 4.10 Following Exercise 4.9, write a single line of code that will extract frome dframe just the names and ages of any records where the individual is male and has a level of funniness equal to Low OR Mid. 4.5 Tibble tibble is a new data structure with lots of advantages. For the moment, we treat tibble and data.frame as the same, with the former being an augmented version of the latter. All functions that work of a data.frame should be compatible with a tibble. Now the tibble is the major structure that R users work with under the tidy framework. If you are new to tibbles, the best place to start is the tibbles chapter in R for data science. require(tibble) ## Loading required package: tibble ## Warning: package &#39;tibble&#39; was built under R version 3.5.2 ex_tb &lt;- tibble( WORD = c(&quot;the&quot;, &quot;boy&quot;, &quot;you&quot;,&quot;him&quot;), POS = c(&quot;ART&quot;,&quot;N&quot;,&quot;PRO&quot;,&quot;PRO&quot;), FREQ = c(1104,35, 104, 34)) ex_tb You can subset a tibble in exactly the same ways as you work with a data.frame: ex_tb[1,] ex_tb[,1] ex_tb[,c(1:3)] Exercise 4.11 Please compare again the following codes and see if you can tell the major differences between tibble and data.frame? ex_tb[,c(&quot;FREQ&quot;)] # indexing tibble ex_df[,c(&quot;FREQ&quot;)] # indexing data.frame ## [1] 1104 35 104 34 There are three major advantages with tibble() when compared with data.frame(): tibble set strings to default to character vectors while data.frame converts all character vectors to factors by default When auto-printing the contents, tibble would only display the first ten rows, but data.frame would print out everything. This could be devestating! (Imagine that you have a table with hundreds of thousands rows.) The auto-printing of the tibble is a lot more informative, providing additional attributes of the tibble such as (a) row and column numbers and (b) data type of each column "],
["data-visualization.html", "Chapter 5 Data Visualization 5.1 Why Visualization? 5.2 ggplot2 5.3 One-variable Graph 5.4 Two-variable Graph 5.5 Adding Other Aesthetic Features 5.6 Saving Plots 5.7 Exercises on COVID-19", " Chapter 5 Data Visualization 5.1 Why Visualization? Data visualization is very important. I would like to illustrate this point with two interesting examples. First, let us take a look at an interesting dataset demo_data/data-datasaurus.csv: Table 5.1: An Interesting Dataset group x y dino 95.38460 36.794900 dino 98.20510 33.718000 away 91.63996 79.406603 away 82.11056 1.210552 h_lines 98.28812 30.603919 h_lines 95.24923 30.459454 v_lines 89.50485 48.423408 v_lines 89.50162 45.815179 x_shape 84.84824 95.424804 x_shape 85.44619 83.078294 star 82.54024 56.541052 star 86.43590 59.792762 high_lines 92.24840 32.377154 high_lines 96.08052 28.053601 dots 77.92604 50.318660 dots 77.95444 50.475579 circle 85.66476 45.542753 circle 85.62249 45.024166 bullseye 91.72601 52.623353 bullseye 91.73554 48.970211 slant_up 92.54879 42.901908 slant_up 95.26053 46.008830 slant_down 95.44349 36.189702 slant_down 95.59342 33.234129 wide_lines 77.06711 51.486918 wide_lines 77.91587 45.926843 We group the dataset by group and for each group we compute their respective mean scores and standard deviations of x and y. According to the summary statistics of each group, they look indeed similar: Table 5.2: An Interesting Dataset - Summary group x_fn1 y_fn1 x_fn2 y_fn2 away 54.266 47.835 16.770 26.940 bullseye 54.269 47.831 16.769 26.936 circle 54.267 47.838 16.760 26.930 dino 54.263 47.832 16.765 26.935 dots 54.260 47.840 16.768 26.930 h_lines 54.261 47.830 16.766 26.940 high_lines 54.269 47.835 16.767 26.940 slant_down 54.268 47.836 16.767 26.936 slant_up 54.266 47.831 16.769 26.939 star 54.267 47.840 16.769 26.930 v_lines 54.270 47.837 16.770 26.938 wide_lines 54.267 47.832 16.770 26.938 x_shape 54.260 47.840 16.770 26.930 So we may naively conclude that all groups show similar behaviors in x and y measures. But what if we plot all subjects by groups? See? What you see is sometimes NOT what you believe. Another example is Simpson’s Paradox, which occurs when trends that appear when a dataset is separated into groups reverse when the data are aggregated. Based on the above graph, you would probably conclude that when x increases, y decreases. However, if you plot the scatter plots by groups, you may get the opposite conclusions. All correlations between x and y in all groups are now positive. 5.2 ggplot2 R is famous for its power in data visualization. So why don’t we delve right into this beauty in R? In this chapter, we will introduce you a very powerful graphic library in R, ggplot2. For any data visualization, there are three basic elements: Data: The raw material of your visualization, i.e., a data frame. Aesthetics: The mapping of your data to aesthetic attributes, such as x, y, color, linetype, fill. Geometric Objects: The layers of geometric objects you would like to see on the plots, e.g., lines, points etc. I will demonstrate some basic functions of ggplot2, with the pre-loaded dataset mpg: library(tidyverse) mpg model: manufacturer model name displ: engine displacement, in litres (排氣量) hwy: highway miles per gallon cty: city miles per gallon cyl: number of cylinders (汽缸數目) class: car type We can look at the relation between displ and hwy: ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() ggplot() initializes the basic frame of the graph, with data = mpg specifying the data frame on which the plot is built aes() further specifies the mapping of axises and the factors in the data frame. aes(x = displ, y = hwy) indicates that displ is mapped as the x axis and hwy as y axis + means that you want to add one layer of the graph to the template. geom_point() means that you want to add a layer of point graph. 5.3 One-variable Graph Continuous variable ggplot(data = mpg, aes(hwy)) + geom_density(kernel=&quot;gaussian&quot;) ggplot(data = mpg, aes(hwy)) + geom_histogram() Categorical variable ggplot(data = mpg, aes(x = class)) + geom_bar() Exercise 5.1 How can we create a bar plot as above but with the bars arranged according to the counts in a descending order from left to right? (see below) 5.4 Two-variable Graph Continuous X, Continuous Y Scatter Plot ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() We can add a regression line to the scatter plot: ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(method=&#39;lm&#39;, formula= y~x) Discrete X, Continuous Y Boxplot ggplot(data = mpg, aes(x = class, y = hwy)) + geom_boxplot() Error Plot ggplot(data = mpg, aes(x = class, y = hwy)) + stat_summary(fun.data = mean_cl_boot, geom = &quot;pointrange&quot;) Discrete X, Discrete Y Bubble Plot ggplot(data = mpg, aes(x = manufacturer, y = class)) + geom_count() + theme(axis.text.x = element_text(angle=-90)) 5.5 Adding Other Aesthetic Features Now I would like to demonstrate how we can add additional aesthetic mappings to your graphs. You can add color = ... in the aes() to creat the graphs on the basis of a grouping factor We can introduce a third variable into the plot by modifying the color of the points based on the value of that third variable. Color is an aesthetic and the color of each point can be mapped to a variable. Note that the x-coordinates and y-coordinates are aesthetics too, and they got mapped to the displ and hwy variables, respectively. In this case we will map the color to the drv variable which indicates whether a car is front wheel drive, rear wheel drive, or 4-wheel drive. ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() We can also add another geom object, such as a smooth line: ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth() Could you predict what kind of graph you would get with the following code? ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + geom_smooth() We can add self-defined labels of the x and y axes and main titles to the graphs using labs(). ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(method=&#39;lm&#39;, formula= y~x) + labs(title = &quot;Correlation between Displacement and Highway Miles per Gallon&quot;, x = &quot;Displacement&quot;, y = &quot;Miles/Per Gallon&quot;) ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + labs(x = &quot;Engine Displacement (litres)&quot;, y = &quot;Highway Miles per Gallon&quot;, title = &quot;Scatter Plot -- DISPL by HWY&quot;) For bar plots or histograms, we can fill the bars with different colors by adding fill = ... in the aes(). ggplot(data = mpg, aes(x = class)) + geom_bar(aes(fill = class)) ggplot(data = mpg, aes(x = class, y = hwy)) + geom_boxplot(aes(fill = class)) Here are a list of common asethemic parameters we often use in aes(): size = ... color = ... fill = ... alpha = ... 5.6 Saving Plots Saving a ggplot can be easily done by ggsave(). You can first save a ggplot object to a variable and then use ggsave() to output the ggplot object to an external file. It is recommended to use common image formats for publications, e.g., png, jpg. my_first_graph &lt;- ggplot(data = mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + labs(x = &quot;Engine Displacement (litres)&quot;, y = &quot;Highway Miles per Gallon&quot;, title = &quot;Scatter Plot -- DISPL by HWY&quot;) class(my_first_graph) # check the class ## [1] &quot;gg&quot; &quot;ggplot&quot; my_first_graph # auto-print the ggplot ggsave(filename = &quot;my_first_plot.png&quot;,plot = my_first_graph, width = 6, height = 6) 5.7 Exercises on COVID-19 The following exercises are based on a dataset downloaded from Kaggle. The dataset is also available in demo_data/data-covid19.csv. Exercise 5.2 Load the dataset in demo_data/data-covid19.csv into R as a data frame named covid19. Exercise 5.3 Use ggplot2 to reate a line plot showing the number of confirmed cases by days for the following countries: Taiwan, Japan, South Korea, Iran, Italy, Mainland China. A sample graph is shown below. Exercise 5.4 Create a bar plot showing the top 10 countries ranked according to their number of confirmed cases of the COVID19. Exercise 5.5 Create a bar plot showing the top 10 countries ranked according to their death rates of the COVID19. (Death rates are defined as the number of deaths divided by the number of confirmed cases.) Exercise 5.6 (optional) Create a world map showing the current outbreak of covid19. Hint: Please check the library(maps). This exercise is made to see if you know how to find resources online for more complex tasks like this. Please note that the country names may not match. "],
["data-manipulation.html", "Chapter 6 Data Manipulation 6.1 Dataset 6.2 rename() 6.3 Pipe %&gt;% 6.4 mutate() 6.5 select() 6.6 filter() 6.7 arrange() 6.8 group_by() and summarize() 6.9 count() 6.10 Exerceises", " Chapter 6 Data Manipulation In this chapter, we will be working with a powerful package, dplyr, which provides a consistent “grammar” for data manipulation and exploration by simplifying operations on data frames to a great deal. We first load the library: library(dplyr) In this library, there are a list of key verbs: %&gt;%: the “pipe” operator is used to connect multiple verb actions together into a pipeline mutate(): add new variables/columns or transform existing variables select(): return a subset of the columns of a data frame, using a flexible notation filter(): extract a subset of rows from a data frame based on logical conditions summarise(): generate summary statistics of different variables in the data frame, possibly within strata group_by(): group the data frame into sub-tables according to a grouping factor arrange(): reorder rows of a data frame (according to a particular variable) rename(): rename variables in a data frame Several usueful functions for joining two data frames: inner_join() left_join() right_join() full_join() anti_join() Exercise 6.1 Please check the documentations of all the above functions of merging data frames and make sure you understand how two data frames are merged for each function. 6.1 Dataset The dateaset we use in this chapter is a student performance dataset from kaggle. library(readr) student &lt;- read_csv(&quot;demo_data/data-students-performance.csv&quot;) student Usually we would start from an overview of the dataset, using summary(): summary(student) ## gender race/ethnicity parental level of education ## Length:1000 Length:1000 Length:1000 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## lunch test preparation course math score reading score ## Length:1000 Length:1000 Min. : 0.00 Min. : 17.00 ## Class :character Class :character 1st Qu.: 57.00 1st Qu.: 59.00 ## Mode :character Mode :character Median : 66.00 Median : 70.00 ## Mean : 66.09 Mean : 69.17 ## 3rd Qu.: 77.00 3rd Qu.: 79.00 ## Max. :100.00 Max. :100.00 ## writing score ## Min. : 10.00 ## 1st Qu.: 57.75 ## Median : 69.00 ## Mean : 68.05 ## 3rd Qu.: 79.00 ## Max. :100.00 6.2 rename() The column names in student are a mess. These names include spaces in them, which would be difficult to index these columns in R. This is however normal in the real world, where the dataset we get is often very messy. So, the first thing we can do with the dataset is the rename all the column names in a R-compatible way. rename(student, race = `race/ethnicity`, parent_edu = `parental level of education`, prep_course = `test preparation course`, math = `math score`, reading = `reading score`, writing = `writing score`) -&gt; student1 student1 Please note that in our earlier code, we save the output of rename() to a new object named student1. In other words, the object student1 should contain a new data frame with all column names fixed as above. 6.3 Pipe %&gt;% Now let’s look at a fantastic syntax in R, the pipe %&gt;%, which is definitely one of my favorite R idioms! To start with, the following two expressions are the same, giving you the same results: sum(c(1:10)) ## [1] 55 c(1:10) %&gt;% sum ## [1] 55 The meaning of %&gt;% is that the object on the left of the pipe is passed on to the right side of the pipe for further processing. By default, the object is passed onto to be the first argument of the function on the right-hand side. This pipe-based syntax would render the script more reader-friendly. For example, it is difficult to conceptualize the following code with several layers of embedding structures. sqrt(sum(abs(c(-10:10)))) ## [1] 10.48809 But the above code can be re-written with the %&gt;% as follows: c(-10:10) %&gt;% # create a vector abs %&gt;% # take each element&#39;s absolute value sum %&gt;% # sum all elements sqrt # take the square root of the sum ## [1] 10.48809 Now we understand the idiomatic expression of %&gt;%, our earlier rename() can be re-written as follows as well (cf. student1 and student1a): student %&gt;% rename(race = `race/ethnicity`, parent_edu = `parental level of education`, prep_course = `test preparation course`, math = `math score`, reading = `reading score`, writing = `writing score`) -&gt; student1a student1a From now on, we will use the pipe-based syntax more often. 6.4 mutate() Now imagine that you would like to create a new variable called final_grade, which is a weighted average of the student’s academic performance. Let us assume that you have the following weights in mind: math (50%), reading (25%), writing (25%). You can use mutate() to create a new column (i.e., variable) in your data frame: student1 %&gt;% mutate(final_grade = math*0.5 + reading*0.25 + writing*0.25) We can create more than one new variables as well: student1 %&gt;% mutate(language = reading*0.5 + writing*0.5, final_grade = math + language) In the above practices of mutate(), we did not save the output of mutate() to a new object name. We only print the output directly to the console. In order words, the original data frame is still the same (i.e., student, student1); no new variables have been created with respect to these original data frames. 6.5 select() select() is to select particular columns of the data frame that you would like to focus on. You can select just one column student1 %&gt;% select(math) Or multiple columns: student1 %&gt;% select(math, reading, writing) Or columns within a range: student1 %&gt;% select(math:writing) You can also omit variables using select() student1 %&gt;% select(-c(race:lunch)) 6.6 filter() While select() is for columns, filter() is for rows. You can extract subsets of rows from a data frame. Most importantly, you can extract rows according to self-defined conditions. one logical condition student1 %&gt;% filter(math &gt; 90) AND &amp; conditions: student1 %&gt;% filter(math &lt; 40 &amp; reading &lt; 40) OR | conditions: student1 %&gt;% filter(math &lt; 40 | reading &lt; 40) XOR xor conditions: student1 %&gt;% filter(xor(math &lt; 40, reading &lt; 40)) Exercise 6.2 Please check the row numbers of the above three filtered data frames. Any connection? Please check Chapter 4.1 Vector for more logical operations. 6.7 arrange() We can arrange the rows of the data frame according to a particular variable. student1 %&gt;% arrange(math) By default, R will arrange the rows in an ascending order. If you like to arrange your data in a descending order, put a desc() around your variable name: student1 %&gt;% arrange(desc(math)) 6.8 group_by() and summarize() The group_by() function is used to generate summary statistics from the data frame within strata defined by a grouping variable. For example, in this student1 dataset, you might want to know what the average math scores are for students of different genders. In conjunction with the group_by() function we often use the summarize() function to create the summarized statistics for each subgroup (i.e., male and female). Two important steps: Split the big data frame into smaller sub data frames according to a grouping factor/variable (group_by()) Summarize each sub data frame with respect to specific parameters (summarize()) student1 %&gt;% group_by(gender) %&gt;% summarize(math_average = mean(math), math_median = median(math), math_sd = sd(math)) 6.9 count() One of the most-often used feature when we have data frames is to tally the frequencies of the subjects according to some of the columns. The function count() is born for this. For example, we can create a frequency distribution of male and female students of different parental levels of education (i.e., parent_edu x gender contingency table): student1 %&gt;% count(parent_edu, gender) Exercise 6.3 Continuing the above example, how can you create another column, which includes the percentage of male and female students for those of the same parental level education (see below)? 6.10 Exerceises Exercise 6.4 In the dataset demo_data/data-students-performance.csv, please load the dataset in R and print out those students who are female and whose math scores are &lt; 40. In your output, please show the following columns only: gender, math. Exercise 6.5 With the same dataset, please compute the mean scores and standard deviations of math for different races. Also, please include the number of students for each race sub-group. Exercise 6.6 With the same dataset, please create a summary data frame, which includes the number of students, math mean scores, math standard deviations, for students of different genders and parental education levels. Exercise 6.7 In terms of Parental Education Levels (i.e., parent_edu), it would be better to be coded as an ordered factor. Can you tranform the variable parent_edu into a ordered factor and regenerate the outputs requested in Exercise 6.6. Let us assume that the factor parent_edu follow the following order: some high school &lt; high school &lt; some college &lt; associate's degree &lt; bachelor's degree &lt; master's degree Exercise 6.8 Have you any ideas how to generate the following graphs using ggplot2()? "],
["data-import.html", "Chapter 7 Data Import 7.1 readLines() 7.2 writeLines() 7.3 read_csv() 7.4 write_csv() 7.5 Directory Operations", " Chapter 7 Data Import Most of the time, we need to work with our own data. In this chapter, we will learn how to read plain-text files. There are two major types that data anlaytists often work with: txt and csv files. 7.1 readLines() As we are often dealing with text data, we may need to import text files in R for further data processsing. In R, there is a base function readLines(), which reads a txt file with the line breaks as the delimiter and returns the content of the file as a (character) vector. That is, each line in the text will be one element in the vector. alice &lt;- readLines(con = &quot;demo_data/corp-alice.txt&quot;) alice[1:10] ## [1] &quot;[Alice&#39;s Adventures in Wonderland by Lewis Carroll 1865]&quot; ## [2] &quot;&quot; ## [3] &quot;CHAPTER I. Down the Rabbit-Hole&quot; ## [4] &quot;&quot; ## [5] &quot;Alice was beginning to get very tired of sitting by her sister on the&quot; ## [6] &quot;bank, and of having nothing to do: once or twice she had peeped into the&quot; ## [7] &quot;book her sister was reading, but it had no pictures or conversations in&quot; ## [8] &quot;it, &#39;and what is the use of a book,&#39; thought Alice &#39;without pictures or&quot; ## [9] &quot;conversation?&#39;&quot; ## [10] &quot;&quot; class(alice) ## [1] &quot;character&quot; length(alice) ## [1] 3331 Depending on how you arrange the contents in the text file, you may sometimes get a vector of different types: If each paragraph in the text file is a word, you get a word-based vector. If each paragraph in the text file is a sentence, you get a sentence-based vector. If each paragraph in the text file is a paragraph, you get a paragraph-based vector. Exercise 7.1 Based on the inspection of the vector alice created above, what is the content of each line in the original txt file (demo_data/corp-alice.txt)? 7.2 writeLines() After processing the data in R, we often need to save our data in an external file for future reference. For text data, we can use the base function writeLines() to save a character vector. By default, each element will be delimited by a line break after it is exported to the file. writeLines(alice, con = &quot;corp-alice-2.txt&quot;) 7.3 read_csv() Another common source of data is a spreadsheet-like file, which corresponds to the data.frame in R. Usually we save these tabular data in a csv file, i.e., a comma-separated file. Although R has its own base functions for csv-files reading (e.g., read.table(), read.csv() etc.), here we will use the more powerful version read_csv() provided in the library of readr: library(readr) nobel &lt;- read_csv(&quot;demo_data/data-nobel-laureates.csv&quot;) nobel The csv file is in fact a normal plain-text file. Each line consists of a row data, with the columns separated by commas. Sometimes we may receive a dataset with other self-defined characters as the delimiter. Another often-seen case is to use the tab as the delimiter. Files with tab as the delimiter are often with the extension tsv. In readr, we can use read_tsv() to read tsv files. gender_freq &lt;- read_tsv(file = &quot;demo_data/data-stats-f1-freq.tsv&quot;) gender_freq 7.4 write_csv() In readr, we can also export our data frames to external files, using write_csv() or write_tsv(). Exercise 7.2 Load the plain-text file demo_data/data-bnc-bigram.csv into a data frame and print the first 10 rows in the R console. Exercise 7.3 Following Exercise 7.2, please export the first ten rows of the data frame to an external file, named data-bnc-bigram-10.csv, and save it under your current working directory. 7.5 Directory Operations It should now be clear that we need to know very well both the paths and filenames of the external data in order to properly load the data into R. There are a few important directory operations that we often need when doing the data operations (import/export): getwd() setwd() dir(path=&quot;demo_data&quot;, full.names = FALSE, recursive = FALSE) ## [1] &quot;corp-alice.txt&quot; &quot;data-bnc-bigram.csv&quot; ## [3] &quot;data-covid19.csv&quot; &quot;data-datasaurus.csv&quot; ## [5] &quot;data-nobel-laureates.csv&quot; &quot;data-stats-f1-freq.tsv&quot; ## [7] &quot;data-students-performance.csv&quot; &quot;dict-ch-idiom.txt&quot; ## [9] &quot;RegExCheatsheet.pdf&quot; &quot;strings.pdf&quot; ## [11] &quot;US-states.csv&quot; file.exists(&quot;demo_data/data-bnc-bigram.csv&quot;) ## [1] TRUE Exercise 7.4 Please make yourself familar with the following commands: file.create(), dir.create(), unlink(), basename(),file.info(), save(), and load(). Exercise 7.5 Please create a sub-directory in your working directory, named temp. Load the dataset demo_data/data-bnc-bigram.csv and subset bigrams whose bigram frequencies (bi.freq column) are larger than 200. Order the sub data frame according to the bigram frequencies in a descending order and save the sub data frame into a csv file named data-bnc-bigram-freq200.csv in the temp directory. bnc_bigram_freq200 &lt;- read_csv(&quot;temp/data-bnc-bigram-freq200.csv&quot;) bnc_bigram_freq200 "],
["string-manipulation.html", "Chapter 8 String Manipulation 8.1 What is Regular Expression? 8.2 String Basics 8.3 Regular Expression Grammar 8.4 Pattern Matching 8.5 Advanced Pattern Matching: Look Ahead and Behind 8.6 More Practices 8.7 Case Study: Chinese Four-Character Idioms", " Chapter 8 String Manipulation In this chapter, we will introduce some techniques relating to string manipulation. library(tidyverse) library(stringr) 8.1 What is Regular Expression? In text processing, we often do “find” and “replace” in our documents. I am sure that you do this very often in MS-Word or MS-Excel. Regular expression is a language, which allows us to create a textual pattern and use this pattern to match other strings with the same pattern for later processing. This idea of one-pattern-for-multiple-matches is the beauty of regular expression. Several advantages of regular expressions are self-evident: Complicated pattern matching e-mail format checking, phone number checking reduplicated strings date format control Information extraction and text mining extract texts according to a particular format Proper names, e-mails, phone numbers, etc. 8.2 String Basics There are three basic functions: str_length(): get the length of the string (i.e., number of characters) word_string &lt;- c(&quot;the&quot;, &quot;word&quot;, &quot;string&quot;) word_string %&gt;% str_length ## [1] 3 4 6 str_c(): combine strings into a longer one str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;) ## [1] &quot;thewordstring&quot; str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;,sep = &quot;_&quot;) ## [1] &quot;the_word_string&quot; Please note that the following code will generate a different result from the above. Can you tell the differences? How can you generate exactly the same results by using str_c(word_string,…)? Please check ?str_c. str_c(word_string, sep = &quot;_&quot;) ## [1] &quot;the&quot; &quot;word&quot; &quot;string&quot; str_sub(): substract part of the string str_sub(string = &quot;international&quot;, start = 1, end = 5) ## [1] &quot;inter&quot; 8.3 Regular Expression Grammar Now let’s look at the grammar of regular expressions in more detail. In stringr, there is a very useful function, str_view(STRING, PATTERN), which can show us the match of the pattern in the string in a visually intuitive way: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;an&quot;) 8.3.1 Metacharacters In REGEX, . is a special character, referring to any character: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;.a.&quot;) But what if you really want to match a period . sign in your string? x &lt;- c(&quot;apple&quot;, &quot;banana&quot;,&quot;pear&quot;, &quot;orange. And&quot;) str_view(string = x, pattern = &quot;.&quot;) str_view(string = x, pattern = &quot;\\\\.&quot;) This leads us to the notion of escaping character \\. In R, \\ is used if you want to tell R that the character after \\ should be treated literally, not metaphorically as a meta character. But why two slashes \\\\? It’s simple: because \\ itself is a meta character in R as well. We use it to escape quotes like &quot; and '. Therefore, the first backslash is needed to tell R that the second backslash is matched literally (because we need it to serve as an escape character in the regular expression). 8.3.2 Anchors We can find a match anchored in a particular position. ^: The start of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) $: The end of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;^apple$&quot;) 8.3.3 Character Set \\\\d: matches any digit. \\\\s: matches any whitespace (e.g. space, tab, newline). \\\\w: matches any alphanumeric characters x&lt;-c(&quot;apple&quot;,&quot;apple123&quot;,&quot;banana1&quot;) str_view(string = x , pattern = &quot;\\\\d&quot;) x &lt;- c(&quot;aeiouAEIOU1234_ .\\\\$%-*()&quot;) str_view_all(string = x, pattern = &quot;\\\\w&quot;) #compare str_view_all(string = x, pattern = &quot;.&quot;) 8.3.4 Alternatives [abc]: matches a, b, or c. [^abc]: matches anything except a, b, or c. x &lt;- c(&quot;grey&quot;, &quot;gray&quot;) str_view(string = x, pattern = &quot;gr[ea]y&quot;) 8.3.5 Quantifiers We can use quantifiers to quantifier the degrees of repetition of the quantified character (i.e., the char preceding the quantifier): ?: 0 or 1 +: 1 or more *: 0 or more x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) str_view(x, &quot;X+&quot;) Specify exactly the number of repetition: {n}: exactly n {n,}: n or more {,m}: at most m {n,m}: between n and m x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;C{2}&quot;) str_view(x, &quot;C{2,}&quot;) str_view(x, &quot;C{2,3}&quot;) 8.3.6 Greedy vs. Non-greedy match x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CLX+&quot;) str_view(x, &quot;CLX+?&quot;) 8.3.7 Group and Back-reference x &lt;- fruit %&gt;% head(10) x ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; ## [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; Now if you want to extract English fruit words which has two same letter repeating twice in a row (e.g, apple, bell pepper). How would you create your regular expression pattern? str_view(x, &quot;.{2}&quot;) The results are not what you have expected. The trick is that when you use . to match any character, the quantifier does not help much as any character that repeats would fit the pattern. We need a new strategy to ask the regex engine to remember the matched character and quantify the number of occurrences of the remembered character: str_view(x, &quot;(.)\\\\1&quot;) .: matches any character (.): the parenthesis would label the matched as a group. Internally, the regex engine numbers all groups serially from left to right \\\\1: back-reference the first group. The same logic applies to the second group of the regular expression (i.e., \\\\2) So (.)\\\\1 means that when the engine matches a character (which can be any character), there has to be another same character following the former. Exercise 8.1 How do you match abab pattern, such as “banana”? Exercise 8.2 How do you match abba pattern, such as “pepper”? 8.4 Pattern Matching This section will show you examples of how we can make use of regular expresions to process strings. In stringr, there are a list of verbs that we use with regular expressions: str_detect(STRING, PATTERN): Determine which strings in STRING has a match of the PATTERN (binary) x &lt;- fruit %&gt;% head(10) str_detect(x, &quot;e$&quot;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE str_subset(STRING, PATTERN): Subset the full strings in STRING that have either a full or partial match of the PATTERN (character) str_subset(x, &quot;e$&quot;) ## [1] &quot;apple&quot; &quot;blood orange&quot; str_extract(STRING, PATTERN): Extract the content of the matches of the strings in STRING (character) str_extract(x, &quot;e$&quot;) ## [1] &quot;e&quot; NA NA NA NA NA NA NA &quot;e&quot; NA str_replace(STRING, PATTERN, REPLACEMENT): Replace matches of the PATTERN with REPLACEMENT in STRING (character): str_replace() str_replace(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) ## [1] &quot;Vpple&quot; &quot;Vpricot&quot; &quot;Vvocado&quot; &quot;bVnana&quot; &quot;bVll pepper&quot; ## [6] &quot;bVlberry&quot; &quot;blVckberry&quot; &quot;blVckcurrant&quot; &quot;blVod orange&quot; &quot;blVeberry&quot; It should be noted that str_replace() only replaces the first match of each string. str_replace_all(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) ## [1] &quot;VpplV&quot; &quot;VprVcVt&quot; &quot;VvVcVdV&quot; &quot;bVnVnV&quot; &quot;bVll pVppVr&quot; ## [6] &quot;bVlbVrry&quot; &quot;blVckbVrry&quot; &quot;blVckcVrrVnt&quot; &quot;blVVd VrVngV&quot; &quot;blVVbVrry&quot; str_split(STRING, PATTERN): Split a string in STRING based on a PATTERN (character) x &lt;- sentences %&gt;% head(5) x ## [1] &quot;The birch canoe slid on the smooth planks.&quot; ## [2] &quot;Glue the sheet to the dark blue background.&quot; ## [3] &quot;It&#39;s easy to tell the depth of a well.&quot; ## [4] &quot;These days a chicken leg is a rare dish.&quot; ## [5] &quot;Rice is often served in round bowls.&quot; str_split(string = x, pattern = &quot;\\\\s&quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; ## ## [[4]] ## [1] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; ## [8] &quot;rare&quot; &quot;dish.&quot; ## ## [[5]] ## [1] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; Please note that the return of str_split() is a list. fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;: &quot;) ## [[1]] ## [1] &quot;Name&quot; &quot;Hadley&quot; ## ## [[2]] ## [1] &quot;Country&quot; &quot;NZ&quot; ## ## [[3]] ## [1] &quot;Age&quot; &quot;35&quot; fields %&gt;% str_split(&quot;: &quot;, simplify = T) ## [,1] [,2] ## [1,] &quot;Name&quot; &quot;Hadley&quot; ## [2,] &quot;Country&quot; &quot;NZ&quot; ## [3,] &quot;Age&quot; &quot;35&quot; Exercise 8.3 Convert American dates to British dates. Exercise 8.4 Split filenames of ICNALE 8.5 Advanced Pattern Matching: Look Ahead and Behind If you want to find Windows, but only when it is followed by &quot;95, 98, NT, 2000&quot;: win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;Windows3.1&quot;) str_view(win, &quot;Windows(?=95|98|NT|2000)&quot;) Or the other way around: win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;Windows3.1&quot;) str_view(win, &quot;Windows(?!95|98|NT|2000)&quot;) In the regular expression, the () after Windows is a condition for matching. There are four alternatives to specify your conditions: Look-ahead conditions: (?=pattern): The target match has to be followed by the pattern in the condition (?!pattern): The target match cannot be followed by the pattern in the condition Look-behind conditions: (?&lt;=pattern): The target match has to be preceded by the pattern in the condition (?&lt;!pattern): The target match cannot be preceded by the pattern in the condition win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;3.1Windows&quot;) str_view(win, &quot;(?&lt;=95|98|NT|2000)Windows&quot;) win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;3.1Windows&quot;) str_view(win, &quot;(?&lt;!95|98|NT|2000)Windows&quot;) Exercise 8.5 Please use the first ten words in the fruit vector for this exercise. Based on the fruit vocabulary, can you give us all the a's that are followed by STOP_SOUNDS? STOP_SOUNDS refer to p, t, k, b, d, g. Exercise 8.6 Similar to the previous example, Exercise 8.5, also based on the first ten words in fruit, please identify all the vowels that are both followed and preceded by STOP_SOUNDS. 8.6 More Practices 8.6.1 Case 1 How to extract only the number of the week from the y column, and add this information to a new column, z? dt &lt;- tibble( x = 1:4, y = c(&quot;wk 3&quot;, &quot;week-1&quot;, &quot;7&quot;, &quot;w#9&quot;) ) dt 8.6.2 Case 2 How to extract all the vowels from the first ten words in fruit? dt &lt;- tibble( WORD = fruit[1:10] ) dt 8.6.3 Case 3 How to separate the English and Chinese and create two new columns, EN, CH? tb &lt;- tibble(x = c(&quot;I我&quot;, &quot;love愛&quot;, &quot;you你&quot;)) tb 8.6.4 Case 4 How to extract the numbers and split the numbers into START and END? df &lt;- tibble(x = c(&quot;1-12周&quot;, &quot;1-10周&quot;, &quot;5-12周&quot;)) df 8.6.5 Case 5 How to extract numbers of each token and compute the sum of the number and save the results in a new column SUM? df &lt;- tibble( x = c(&quot;1234&quot;, &quot;B246&quot;, &quot;217C&quot;, &quot;2357f&quot;, &quot;21WD4&quot;) ) df 8.6.6 Case 6 How to extract all the numbers that follow a upper-casing letter? For example, 34 after W; 217 after B? df &lt;- tibble( x = c(&quot;12W34&quot;, &quot;AB2C46&quot;, &quot;B217C&quot;, &quot;akTs6df&quot;, &quot;21WD4&quot;) ) df 8.6.7 Case 7 Relating to Section 8.6.6, can you add another column to the resulting data frame, which records the upper-casing letter that the numbers follow for each token? 8.7 Case Study: Chinese Four-Character Idioms Many studies have shown that Chinese makes use of large proportion of four-character idioms in the discourse. Let’s have an exploratory analysis of four-character idioms in Chinese. 8.7.1 Dictionary Entries In our demo_data directory, there is a file dict-ch-idiom.txt, which includes a list of four-character idioms in Chinese. These idioms are collected from 搜狗輸入法詞庫 and the original file formats (.scel) have been combined, removed of duplicate cases, and converted to a more machine-readable format, i.e., .txt. Let’s first import the idioms in the file. all_idioms &lt;- readLines(con = &quot;demo_data/dict-ch-idiom.txt&quot;) head(all_idioms) ## [1] &quot;阿保之功&quot; &quot;阿保之勞&quot; &quot;阿鼻地獄&quot; &quot;阿鼻叫喚&quot; &quot;阿斗太子&quot; &quot;阿芙蓉膏&quot; tail(all_idioms) ## [1] &quot;罪無可逭&quot; &quot;罪人不帑&quot; &quot;作纛旗兒&quot; &quot;坐纛旂兒&quot; &quot;作姦犯科&quot; &quot;作育英才&quot; length(all_idioms) ## [1] 56536 In order to make use of the tidy structure in R, we convert the data into a tibble: idiom &lt;- tibble(string = all_idioms) 8.7.2 Case Study: X來Y去 We can create a regular expression pattern to extract all idioms with the format of X來X去: idiom %&gt;% filter(str_detect(string, &quot;.來.去&quot;)) To analyze the meaning of this constructional schema, we may need to extract the X and Y in the schema: idiom_laiqu &lt;-idiom %&gt;% filter(str_detect(string, &quot;.來.去&quot;)) %&gt;% mutate(pattern = str_replace(string, &quot;(.)來(.)去&quot;, &quot;\\\\1_\\\\2&quot;)) %&gt;% separate(pattern, into = c(&quot;w1&quot;, &quot;w2&quot;), sep = &quot;_&quot;) idiom_laiqu One empirical question is how many of these idioms are of the pattern X=Y (e.g., 想來想去, 直來直去) and how many are of X!=Y (e.g., 說來道去, 朝來暮去): idiom_laiqu %&gt;% mutate(structure = ifelse(w1==w2, &quot;XX&quot;,&quot;XY&quot;)) %&gt;% count(structure) idiom_laiqu %&gt;% mutate(structure = ifelse(w1==w2, &quot;XX&quot;,&quot;XY&quot;)) %&gt;% count(structure) %&gt;% ggplot(aes(structure, n, fill = structure)) + geom_col() 8.7.3 Exercises Exercise 8.7 Please use idiom and extract the idioms with the schema of 一X一Y. Exercise 8.8 Also with the idiom as our data source, now if we are interested in all idioms that have duplicated characters in them, with schemas like either _A_A or A_A_, where A is a fixed character. How can we extract all idioms of these two types from idiom? Also, provide the distribution of the two types. Exercise 8.9 Following Exercise 8.8, for each type of the idioms, please provide their respective proportions of X=Y vs. X!=Y. Exercise 8.10 Folloing Exercise 8.9, please identify the character that is duplicated in the idioms. One follow-up analysis would be to look at the distribution of these pivotal characters. Can you reproduce a graph as shown below as closely as possible? "],
["conditions-and-loops.html", "Chapter 9 Conditions and Loops 9.1 if Statements 9.2 for 9.3 while loop 9.4 Toy Example", " Chapter 9 Conditions and Loops When you start to write more sophisticated programs with R, you will very often need to control the flow and order the executation in your code. You will usually run into two types of scenarios: Make the execution of a particular code chunk dependent on a condition Repeat a particular code chunk a certain number of times, which is often referred to as loops. In this Chapter, we will explore these core programming techniques using if-else statements, for and while loops. However, in Chapter 10, we will talk about loops more and point you to the idiomatic ways of dealing with loops in R. 9.1 if Statements The main purpose of if is to control precisely which operations are carried out in a given code chunk. A if statement runs a code chunk only if a certain condition is true. This conditional expression allows R to respond differently depending on whether the condition is TRUE or FALSE. The basic template of if is as follows: if(CONDITION IS TRUE){ DO THIS CODE CHUNK 1 } else{ DO THIS CODE CHUNK 2 } The condition is palced in parentheses after if. The condition must be an expression that returns only a single logical value (TRUE or FALSE). If it is TRUE, the code chunk 1 in the braces will be executed; if the condition is not satisfied, the code chunk 2 in the braces after else will be executed. Let’s create a simple password checker. Imagine that your system password is stored on the server. You can only get into the system if you enter the correct password. For every password you enter, the system gatekeeper will check if your input password matches the one stored on the server. If they match, you will be allowed to get through. input &lt;- 113 if(input == 987){ writeLines(&quot;Congratulations! Now you may get in!&quot;) } else{ writeLines(&quot;Sorry! Wrong password.&quot;) } ## Sorry! Wrong password. Now we can read the input directly from the user’s input in the R console: input &lt;- readline(prompt=&quot;Please enter your password:&quot;) if(input == 987){ writeLines(&quot;Congratulations! Now you may get in!&quot;) } else{ writeLines(&quot;Sorry! Wrong password.&quot;) } 9.2 for The for loop statment is to repeat a code chunk, often while incrementing an index or counter. The most frequent scenario is to repeat a code chunk through a vector/list, element by element, or through a data frame row by row (or column by column). The basic for loop template is as follows: for(LOOP_INDEX in LOOP_VECTOR){ DO THIS CODE CHUNK } The LOOP_INDEX is a placeholder that represents an element in the LOOP_VECTOR. When the loop begins, the LOOP_INDEX starts off as the first element in the vector. When the loop reaches the end of the brace, the LOOP_INDEX is incremented, taking on the next element in the vector. This process continues until the loop reaches the final element of the LOOP_VECTOR. At this point, the code chunk is executed for the last time, and the loop exits. For example, if we have a character vector with a few words in it. We can use a for loop to get the number of characters for each element in the vector. word_vec &lt;- c(&quot;apple&quot;,&quot;banana&quot;,&quot;watermelon&quot;,&quot;papaya&quot;) for(w in word_vec){ word_nchar &lt;- nchar(w) writeLines(as.character(word_nchar)) } ## 5 ## 6 ## 10 ## 6 For the above example, there is another way to write the for loop: for(i in 1:length(word_vec)){ word_nchar &lt;- nchar(word_vec[i]) writeLines(as.character(word_nchar)) } ## 5 ## 6 ## 10 ## 6 In our first example, the LOOP_INDEX directly represent elements in the LOOP_VECTOR. In our second example, the LOOP_INDEX represents indexs of the vector. 9.3 while loop There is another type of loop. Unlike the for loop, which repeats a code chunk by going through every element in a vector, the while loop repeats a code chunk UNTIL a specific condition evalutes to FALSE. The basic template is as follows: while(LOOP_CONDITION){ DO THIS CODE CHUNK (UNTIL THE LOOP_CONDITION BECOMES FALSE) } Upon the start of a while loop, the LOOP_CONDITION is evaluated. If the condition is TRUE, the braced code chunk is executed line by line till the end of the chunk. At this point, the LOOP_CONDITION will be checked again. The loop terminates immediately when the condition is evaluated to be FALSE. Based on the template above, you should infer that the code chunk executed must somehow cause the loop to exit, and very often will change the value of certain objects, which would eventaully lead to the change of the LOOP_CONDITION. If nothing ever changes the LOOP_CONDITION, R will crash due to the infinite loops. Let’s come back to our password checker. This time let’s create a dumb checker. When you give a wrong password which is smaller than your true answer, it will automatically approach the right asnwer for you (and of course no real-world application would do that!) ans &lt;- 87 guess &lt;- 83 while(guess != ans){ writeLines(&quot;Your `guess` is too small! The system will take care for you!&quot;) guess &lt;- guess + 1 cat(&quot;Now the system is adjusting your `guess` to &quot;, guess, &quot;\\n&quot;) } ## Your `guess` is too small! The system will take care for you! ## Now the system is adjusting your `guess` to 84 ## Your `guess` is too small! The system will take care for you! ## Now the system is adjusting your `guess` to 85 ## Your `guess` is too small! The system will take care for you! ## Now the system is adjusting your `guess` to 86 ## Your `guess` is too small! The system will take care for you! ## Now the system is adjusting your `guess` to 87 9.4 Toy Example Now we are playing the Guess Game. The game is as follows: I pick a number from 1 to 100. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. ans &lt;- 18 guess &lt;- readline(prompt = &quot;Please guess my number(0~100):&quot;) while(guess != ans){ if(guess &lt; ans){ writeLines(&quot;The asnwer is higher.&quot;) guess &lt;- readline(prompt = &quot;Please guess my number(0~100):&quot;) }else{ writeLines(&quot;The asnwer is lower&quot;) guess &lt;- readline(prompt = &quot;Please guess my number(0~100):&quot;) } } writeLines(&quot;Correct!&quot;) "],
["iteration.html", "Chapter 10 Iteration 10.1 Code Duplication 10.2 vector vs. list in R 10.3 Iteration 10.4 purr 10.5 Writing Own Functions", " Chapter 10 Iteration 10.1 Code Duplication Code duplication is tedious and hard to maintain and debug. Plus, there are obvious advantages for reducing code duplications. According to Wickham and Grolemund (2017) Chapter 21 Iteration, there are three main advantages of doing so: It’s easier to see the intent of your code, because your eyes are drawn to what’s different, not what stays the same. It’s easier to respond to changes in requirements. As your needs change, you only need to make changes in one place, rather than remembering to change every place that you copied-and-pasted the code. You’re likely to have fewer bugs because each line of code is used in more places. There are in general two major ways to reduce duplication in coding: wrap the duplicate procedures into a function use iteration This chapter would focus on the second strategy.In this chapter, we talk about code efficiency. In particular we will work on the library purr. 10.2 vector vs. list in R Most of the R-internal functions are vectorized. By default, if we apply a function to a multi-element vector, R will automatically apply the same procedure to each element of the vector, and return the results of the same length. a.vec &lt;- c(1:10) sqrt(a.vec) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 But this is NOT something we can do with a list: a.list &lt;- list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) sqrt(a.list) ## Error in sqrt(a.list): non-numeric argument to mathematical function 10.3 Iteration As we work with list and data.frame very often, it would great if we can have a easy way to apply the same procedure to: - each element in the list - each row in the data.frame - each column in the data.frame Let’s start with a scenario. We first create a pseudo data set, with students’ grades from five different classes. exams.list &lt;- list( class1 = round(runif(30, 0, 100)), # 30 tokens of random numbers in the range &lt;0, 100&gt; class2 = round(runif(30, 0, 100)), class3 = round(runif(30, 0, 100)), class4 = round(runif(30, 0, 100)), class5 = round(runif(30, 0, 100)) ) exams.list ## $class1 ## [1] 55 45 31 43 24 43 72 73 61 33 62 65 82 60 84 1 68 35 2 82 7 37 60 32 22 ## [26] 53 61 74 67 84 ## ## $class2 ## [1] 94 22 59 93 5 73 18 43 92 88 58 60 55 75 37 93 64 30 81 30 65 85 33 33 76 ## [26] 60 73 43 22 47 ## ## $class3 ## [1] 87 25 3 22 16 59 85 96 62 23 70 81 54 81 42 31 44 77 74 80 43 49 50 41 17 ## [26] 19 43 10 13 53 ## ## $class4 ## [1] 68 100 74 81 30 10 11 41 45 44 59 25 60 77 31 84 63 45 75 ## [20] 60 20 14 72 47 13 78 24 77 96 77 ## ## $class5 ## [1] 98 68 76 30 57 40 38 68 87 43 66 35 2 40 18 92 67 70 100 ## [20] 39 95 45 91 94 44 98 34 68 6 9 If we like to compute the mean scores of each cluster, you probably want to use mean(): mean(exams.list) ## [1] NA It should be clear now that mean() expects a numeric vector, on which the mean score is computed. So you may think that why don’t we use the dumb way: set.seed(123) # Make sure we get the same results exams.list.means &lt;- list( class1mean = mean(exams.list$class1), class2mean = mean(exams.list$class2), class3mean = mean(exams.list$class3), class4mean = mean(exams.list$class4), class5mean = mean(exams.list$class5) ) exams.list.means ## $class1mean ## [1] 50.6 ## ## $class2mean ## [1] 56.9 ## ## $class3mean ## [1] 48.33333 ## ## $class4mean ## [1] 53.36667 ## ## $class5mean ## [1] 57.26667 The advantage is obvious: (a) what if you have 10 classes? 100 classes? (b) what if now you decide to compute standard deviation? 10.4 purr library(tidyverse) exams.list %&gt;% map(mean) ## $class1 ## [1] 50.6 ## ## $class2 ## [1] 56.9 ## ## $class3 ## [1] 48.33333 ## ## $class4 ## [1] 53.36667 ## ## $class5 ## [1] 57.26667 With only one-line code, you have achieved your goal. map() is a very powerful function to do iteration. Its usage is as follows: To conceptualize this code map(exams.list, mean): For each element in the exams.list, apply the function mean Do the first element, and save the result in the first elemenet of the new list Do the second element, and save the result in the second elemvent of the new list … After finishing all elements in the exams.list, return the new list result In purrr, by default map() returns results in a list format. You can specify a particular data structure you like by using other variants of the mapping function: exams.list %&gt;% map_df(mean) exams.list %&gt;% map_dbl(mean) ## class1 class2 class3 class4 class5 ## 50.60000 56.90000 48.33333 53.36667 57.26667 Exercise 10.1 Use the same dataset, exam.list, and compute the median and standard deviation for each class. Median ## class1 class2 class3 class4 class5 ## 57.5 59.5 46.5 59.5 61.5 Standard Deviation ## class1 class2 class3 class4 class5 ## 24.14125 25.61028 26.63072 26.74720 29.56108 10.5 Writing Own Functions With the power and flexibility of purrr::map(), we can basically do everything iteratively. More attractively, we can apply a self-defined function as well! First we create own self-defined function my_center: - This function takes a vector object x - Substract each element of x by the mean score of x - return the resulting vector as the output of the function my_center &lt;- function(x) { x - mean(x) } Now we can apply our my_center function to each class in exams.list: exams.list %&gt;% map_df(my_center) Exercise 10.2 Use the built-in the mtcars dataset (?mtcars for more detail). How to get the class type of each column in the mtcars? Exercise 10.3 Create a self-defined function to convert each number of a numeric vector to a “z” score. y &lt;- c(1, 4, 6, 10, 20) my_z(y) ## [1] -7.2000000 -2.1000000 -0.8981462 0.5692100 2.6385602 Exercise 10.4 Use the dataset exams.list in this chapter. For each class, please convert the student’s score to a z-score. exams.list %&gt;% map_df(my_z) References "],
["data-scientist-first-step.html", "Chapter 11 Data Scientist First Step 11.1 Nobel Laureates Dataset 11.2 Before we start 11.3 Data Completeness NA 11.4 Hypotheses 11.5 At what age did these people receive the prizes?", " Chapter 11 Data Scientist First Step Finally this chapter will demonstrate how you can make use of what you have learned from the previous chapters to perform a exploratory data analysis on the dataset you are interested in. Here we will look at a dataset of Nobel Laureates. library(tidyverse) 11.1 Nobel Laureates Dataset df &lt;- read_csv(&quot;demo_data/data-nobel-laureates.csv&quot;) df 11.2 Before we start Before we start, it is clear to see that the column names are full of spaces, which we would like to get rid off. So first, we remove all the spaces in the columns and replace them with _: names(df) &lt;- str_replace_all(names(df), &quot;\\\\s&quot;,&quot;_&quot;) df 11.3 Data Completeness NA It is always important to check if the information of each row is complete. check_num_NA &lt;- function(x){ x %&gt;% is.na %&gt;% sum } df %&gt;% map_df(check_num_NA) You can check rows with NA’s: df %&gt;% filter(is.na(Sex)) 11.4 Hypotheses When given a dataset, before you explore your data, you may first have some hypotheses in mind: 11.4.1 How many laureates were there in different discplines? df %&gt;% count(Category) df %&gt;% count(Category) %&gt;% ggplot(aes(x = Category, y = n, fill = Category)) + geom_col() + geom_text(aes(label = n), vjust = -0.25) + labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) df %&gt;% count(Category) %&gt;% ggplot(aes(x = fct_reorder(Category, n), y = n, fill = Category)) + geom_col() + geom_text(aes(label = n), vjust = -0.25) + labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) An even more dynamic graph: library(gganimate) #install.packages(&quot;gganimate&quot;, dependencies = T) df %&gt;% count(Category) %&gt;% mutate(Category = fct_reorder(Category, n)) %&gt;% ggplot(aes(x = Category, y = n, fill = Category)) + geom_text(aes(label = n), vjust = -0.25) + geom_col()+ labs(title = &quot;No. of Laureates in Different Disciplines&quot;, x = &quot;Category&quot;, y = &quot;N&quot;) + theme(legend.position = &quot;none&quot;) + transition_states(Category) + shadow_mark(past = TRUE) 11.4.2 Chinese Laureates df %&gt;% filter(Birth_Country == &quot;China&quot;) There are duplicate tokens in our dataset. nobel_winners &lt;- df %&gt;% mutate_if(is.character, tolower) %&gt;% # lower all character vectors distinct_at(vars(Full_Name, Year, Category), .keep_all = TRUE) %&gt;% mutate(Decade = 10 * (Year %/% 10), Prize_Age = Year - lubridate::year(Birth_Date)) nobel_winners Check Chinese laureates again: nobel_winners %&gt;% filter(Birth_Country == &quot;china&quot;) %&gt;% select(Full_Name, Year, Category) Create a subset of `nobel_winners`, which includes only winners who won the prizes more than once and in more than one category. 11.5 At what age did these people receive the prizes? nobel_winners %&gt;% ggplot(aes(x = Prize_Age)) + geom_histogram(color=&quot;white&quot;) nobel_winners %&gt;% filter(!is.na(Prize_Age)) %&gt;% ggplot(aes(x = Prize_Age, fill = Category, color = Category)) + geom_density() + facet_wrap(~Category) + theme(legend.position = &quot;none&quot;) Exercise 11.1 Please create data frame that shows us the average agae of the winners in different categories, as shown below. Exercise 11.2 Please create data frame that shows us the distributions of male and female winners in different categories. Please show the number of males and females as well as the proportions. (i.e., frequencies and normalizaed frequencies) Exercise 11.3 Please show us the states distribution of the US Nobel Winners. This would give us an idea from which states in the United States there were the most Nobel winners. Exercise 11.4 Following Exercise 11.3, can you include the full names of states in the above table by adding another column? In the demo-data directory, you can find a csv with the mapping between states abbreviations and their full names. The US-states.csv dataset US_states &lt;- read_csv(&quot;demo_data/US-states.csv&quot;) US_states "],
["the-shell.html", "A The Shell A.1 Why do you need to know shell commands? A.2 Shebang Line A.3 Basic Shell Commands A.4 Text-Analytic Related Commands A.5 References", " A The Shell A.1 Why do you need to know shell commands? A.2 Shebang Line A.3 Basic Shell Commands Linux Man Pages The most basic commands are listed below: pwd (print working directory). Shows directory or “folder” you are currently operating in. This is not necessarily the same as the R working directory you get from getwd(). ls (list files). Shows the files in the current working directory. This is equivalent to looking at the files in your Finder/Explorer/File Manager. Use ls -a to also list hidden files, such as .Rhistory and .git. cd (change directory). Allows you to navigate through your directories by changing the shell’s working directory. You can navigate like so: go to subdirectory foo of current working directory: cd foo go to parent of current working directory: cd .. go to your “home” directory: cd ~ or simply cd go to directory using absolute path, works regardless of your current working directory: cd /home/my_username/Desktop. Windows uses a slightly different syntax with the slashes between the folder names reversed, \\, e.g. cd C:\\Users\\MY_USERNAME\\Desktop. Pro tip 1: Dragging and dropping a file or folder into the terminal window will paste the absolute path into the window. Pro tip 2: Use the tab key to autocomplete unambiguous directory and file names. Hit tab twice to see all ambiguous options. Use arrow-up and arrow-down to repeat previous commands. Or search for previous commands with CTRL + r. which Show the full path of a shell commands which python: Check which version of python your system uses which r: Check which version of R your system uses cp Copy files and directories rm Remove files and directories mv Move files and directories mkdir Make directories A.4 Text-Analytic Related Commands gzip [-cd#] FILENAME. Zips/Unzips a file. The zipped file created by gzip is often with the extension *.gz. -c: write output on standard output -d: decompress -#: Regulate the speed of compression using the specified digit #, where -1 or –fast indicates the fastest compression method (less compression) and -9 or –best indicates the slowest compression method (best compression). The default compression level is -6. tar [-j|-z] [cv] [-f FILENAME] filename.... Archive many files into one single file -j: Use bzip2 compression -z: Use gzip compression -c: Create a new archive -v: Print all files processed verbosely tar [-j|-z] [xv] [-f FILENAME] [-C PATH. Restore the original files from the achive file -j: Use bzip2 compression -z: Use gzip compression -x: Extract files from archive -v: Print all files processed verbosely C: Extract files to a particular path So when you see a file with the extention of *.tar.gz, this indicates that this file is a zipped file, which compresses a list of multiple files into one tar archive. Usually people pass their collection of multiple text files (i.e., a corpus) in this way because it is often easier to share one file instead of tons of files at a time. A.5 References If you are interested in more functions and potentials of shell commands, I would highly recommend the book Data Science at the Command Line. "],
["references-1.html", "References", " References "]
]
