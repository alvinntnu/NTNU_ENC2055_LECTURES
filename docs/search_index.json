[
["iteration.html", "Chapter 11 Iteration 11.1 Code Duplication 11.2 vector vs. list in R 11.3 Iteration 11.4 purr 11.5 purr + dplyr 11.6 Writing Own Functions", " Chapter 11 Iteration 11.1 Code Duplication Code duplication is tedious and hard to maintain and debug. Plus, there are obvious advantages for reducing code duplications. According to Wickham and Grolemund (2017) Chapter 21 Iteration, there are three main advantages of doing so: It’s easier to see the intent of your code, because your eyes are drawn to what’s different, not what stays the same. It’s easier to respond to changes in requirements. As your needs change, you only need to make changes in one place, rather than remembering to change every place that you copied-and-pasted the code. You’re likely to have fewer bugs because each line of code is used in more places. There are in general two major ways to reduce duplication in coding: wrap the duplicate procedures into a function use iteration In this chapter, we talk about code efficiency. In particular we will work with the library purr. 11.2 vector vs. list in R Most of the R-internal functions are vectorized. By default, if we apply a function to a multi-element vector, R will automatically apply the same procedure to each element of the vector, and return the results of the same length. a.vec &lt;- c(1:10) sqrt(a.vec) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 round(a.vec, 2) ## [1] 1 2 3 4 5 6 7 8 9 10 But this is NOT something we can do with a list: a.list &lt;- list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) sqrt(a.list) ## Error in sqrt(a.list): non-numeric argument to mathematical function 11.3 Iteration As we work with list and data.frame (tibble) very often, it would be great if we can have an easy way to apply the same procedure to: each element in the list each row in the data.frame each column in the data.frame These three scenarios are the most-often used contexts for iteration. Let’s start with a scenario. We first create a pseudo data set, i.e., a list with students’ grades from five different classes. exams.list &lt;- list( class1 = round(runif(30, 0, 100)), # 30 tokens of random numbers in the range &lt;0, 100&gt; class2 = round(runif(30, 0, 100)), class3 = round(runif(30, 0, 100)), class4 = round(runif(30, 0, 100)), class5 = round(runif(30, 0, 100)) ) exams.list ## $class1 ## [1] 97 96 64 22 98 80 90 46 69 81 54 23 18 85 22 35 38 86 13 41 23 24 85 7 77 ## [26] 98 75 82 52 21 ## ## $class2 ## [1] 14 98 56 48 91 20 10 37 33 25 35 66 59 99 70 96 51 59 18 ## [20] 72 92 29 11 27 58 48 100 19 86 85 ## ## $class3 ## [1] 23 91 41 53 79 90 4 97 14 15 48 41 41 58 92 8 33 53 98 ## [20] 100 1 15 6 28 6 91 80 95 41 63 ## ## $class4 ## [1] 99 66 97 67 1 4 49 29 82 38 55 19 95 9 28 69 52 15 66 38 0 31 97 45 63 ## [26] 85 22 34 71 9 ## ## $class5 ## [1] 13 67 54 31 97 16 52 85 97 93 13 90 5 80 48 69 43 84 19 85 25 64 89 32 26 ## [26] 58 21 11 11 75 If we like to compute the mean scores of each cluster, you probably want to use mean(): mean(exams.list) ## [1] NA It should be clear now that mean() expects a numeric vector, on which the mean score is computed. So you may think that why not do it in a dumb way? We can compute the mean scores for each class and save all the five scores in a list: set.seed(123) # Make sure we get the same results exams.list.means &lt;- list( class1mean = mean(exams.list$class1), class2mean = mean(exams.list$class2), class3mean = mean(exams.list$class3), class4mean = mean(exams.list$class4), class5mean = mean(exams.list$class5) ) exams.list.means ## $class1mean ## [1] 56.73333 ## ## $class2mean ## [1] 53.73333 ## ## $class3mean ## [1] 50.16667 ## ## $class4mean ## [1] 47.83333 ## ## $class5mean ## [1] 51.76667 The disadvantage is obvious: (a) what if you have 10 classes? 100 classes? (b) what if now you decide to compute standard deviation? The rule-of-thumb is that the more you find code reduplication in your script, the more you need to restructure your codes with iterations. 11.4 purr library(tidyverse) Now let’s take a look at how iteration structures can help us with repeated procedures. exams.list %&gt;% map(mean) ## $class1 ## [1] 56.73333 ## ## $class2 ## [1] 53.73333 ## ## $class3 ## [1] 50.16667 ## ## $class4 ## [1] 47.83333 ## ## $class5 ## [1] 51.76667 With only one-line code, you have achieved your goal. map() is a very powerful function to do iteration. Its usage is as follows: To conceptualize this code map(exams.list, mean): For each element in the exams.list, apply the function mean Do the first element, and save the result in the first elemenet of the new list Do the second element, and save the result in the second elemvent of the new list … After finishing all elements in the exams.list, return the new list result In purrr, by default map() returns results in a list format. You can specify a particular data structure you like by using other variants of the mapping function: exams.list %&gt;% map_df(mean) exams.list %&gt;% map_dbl(mean) ## class1 class2 class3 class4 class5 ## 56.73333 53.73333 50.16667 47.83333 51.76667 Exercise 11.1 Use the same dataset, exam.list, and compute the median and standard deviation for each class. Median ## class1 class2 class3 class4 class5 ## 59.0 53.5 44.5 47.0 53.0 Standard Deviation ## class1 class2 class3 class4 class5 ## 30.50487 29.86167 33.97979 31.04955 31.10459 11.5 purr + dplyr The map() function can be very powerful and efficient in data frame manipulation when used in combination with the mutate(). Let’s first load the dataset of four-word idioms from the previous chapter. idiom &lt;- tibble(string = readLines(&quot;demo_data/dict-ch-idiom.txt&quot;, encoding=&quot;utf-8&quot;)) idiom Now if we would like to find out whether each idiom has duplicate characters in it, we can make use of regular expressions: x &lt;- idiom$string[1:10] str_detect(x, &quot;.*(.).*\\\\1.*&quot;) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE FALSE What if we would like to include this information in an independent column of idiom? Two important things should come up in your mind: We need mutate() to help us create a new column We need to apply the above procedure, str_detect(), to each element in the column idiom$string. So would you give it a try? (The following example shows only rows whose duplicate column is TRUE) Exercise 11.2 This exercise will use the subset of idiom, which include only four-word idioms with at least one duplicate character in them. Please create a new column, showing how many types of duplications there are in each idiom? For example, in 阿狗阿貓, there is only one duplicate character 阿; but in 矮矮胖胖, there are two duplicate characters, 矮 and 胖. Exercise 11.3 Continuing the previous exercise, please create another new column, showing all the duplicate characters in each idiom. For example, in 阿狗阿貓, the duplicate character is 阿; but in 矮矮胖胖, the duplicate character is矮_胖. That is, if the idiom has more than one duplicate character, please use the _ as the delimiter and concatenate all duplicate characters into a long string. Exercise 11.4 Based on the previous exercise, please analyze the distribution of all the duplicate characters in the four-character idioms included in the dictionary (i.e., the duplicate_char column from the previous exercise) and identify the top 20 duplicate characters. Please visualize your results in a bar plot with both the top 20 duplicate characters as well as the number of the character’s duplications in the idiom. 11.6 Writing Own Functions With the power and flexibility of purrr::map(), we can basically do everything iteratively. More attractively, we can apply a self-defined function as well! A function object is defined using the following template: FUNCTION_NAME &lt;- function(ARG1, ARG2) { THINGS TO BE DONE WITHIN THE FUNCTION return(...) } A function object usually include: Self-defined name Arguments Return Let’s consider a simple example. First we create own self-defined function my_center(): This function takes a vector object x Substract each element of x by the mean score of x return the resulting vector as the output of the function my_center &lt;- function(x) { x - mean(x) } Now we can apply our my_center function to each class in exams.list: exams.list %&gt;% map_df(my_center) ## or alternatively # map_df(exams.list, my_center) Exercise 11.5 Use the built-in the mtcars dataset (?mtcars for more detail). How do you get the class type of each column in the mtcars by using map()? Exercise 11.6 Create a self-defined function to convert each number of a numeric vector to a “z” score. y &lt;- c(1, 4, 6, 10, 20) my_z(y) ## [1] -0.9779865 -0.5704921 -0.2988292 0.2444966 1.6028112 Exercise 11.7 Use the earlier dataset exams.list. For each element in exams.list, please convert the student’s score to a z-score by applying your self-defined function in an iterative structure (e.g., map). Please present the result as a data frame. References "]
]
