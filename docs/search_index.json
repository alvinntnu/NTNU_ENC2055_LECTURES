[["string-manipulation.html", "Chapter 9 String Manipulation 9.1 What is Regular Expression? 9.2 String Basics 9.3 Regular Expression Grammar 9.4 Pattern Matching 9.5 Advanced Pattern Matching: Look Ahead and Behind 9.6 More Practices 9.7 Case Study: Chinese Four-Character Idioms", " Chapter 9 String Manipulation In the field of data analysis, a significant portion of the data usually consists of text or strings. As such, it is often necessary to use various techniques for string manipulations such as finding, replacing, removing, combining, or splitting strings. A comprehensive understanding of string processing is essential for a competent data scientist. One of the most important tools for effective string manipulation is regular expressions, which can be used to match, extract, and manipulate specific patterns within strings. In this chapter, we will cover several frequently-used techniques for string manipulation, with a particular focus on regular expressions. We will use the stringr package to illustrate the various functions and methods for string manipulation. The stringr package is part of the tidyverse framework, which provides a suite of packages for data wrangling and analysis in R. library(tidyverse) ## library(stringr) # loaded when loading tidyverse 9.1 What is Regular Expression? In text processing, it is common to perform “find-and-replace” operations in documents. This is a routine task in programs like MS-Word or MS-Excel, where specific processing is performed on sets of strings by locating and modifying them. Regular expressions are a powerful tool in this domain, allowing us to create a schematic textual pattern that can be used to match other strings that fit this pattern. The ability to use one pattern for multiple matches is the beauty of regular expressions. Regular expressions have several advantages, including: Efficient pattern matching Checking the format of email addresses, phone numbers, etc. Identifying reduplicated strings Controlling date format Information extraction and text mining Extracting texts according to a specific format Identifying proper names, email addresses, phone numbers, etc. The one-to-many mapping nature of regular expressions enables us to retrieve strings with similar properties in a simpler and more coherent way. Another advantage of regular expressions is that with the knowledge of regular expression and coding capability, you can perform pattern matching tasks on any machine-readable dataset (i.e., corpora) without being limited to the platform created by the corpus provider. Without regular expression knowledge, every time we need to retrieve patterns from a corpus, we must learn the system-specific syntax for corpus query, which may limit us to what the platform is capable of. However, it is important to note that access to the full-text corpus data is required, and a licensed use must be obtained beforehand. That’s another issue !) 9.2 String Basics Before we introduce regular expressions, let’s look at some of the basic string-related functions. Functions from the library stringr often start with str_*(). There are three basic functions: str_length(): get the length of the string (i.e., number of characters) word_string &lt;- c(&quot;the&quot;, &quot;word&quot;, &quot;string&quot;) word_string %&gt;% str_length [1] 3 4 6 str_c(): combine strings into a longer one str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;) [1] &quot;thewordstring&quot; str_c(&quot;the&quot;,&quot;word&quot;,&quot;string&quot;,sep = &quot;_&quot;) [1] &quot;the_word_string&quot; From the above output, can you tell what is the default value for the argument str_c(..., sep = ...)? Please note that the following code generates a different result from the above. Can you tell the differences? How can you create exactly the same results by using str_c(word_string,...)? Please check ?str_c. str_c(word_string, sep = &quot;_&quot;) [1] &quot;the&quot; &quot;word&quot; &quot;string&quot; Can you predict the outputs of the following code? x &lt;- letters[1:10] y &lt;- c(&quot;suffix1&quot;, &quot;suffix2&quot;) z &lt;- LETTERS[1:10] str_c(x, y) str_c(x, z) str_c(x, z, sep = &quot;_&quot;) str_c(x, collapse=&quot;&quot;) str_c(x, collapse=&quot; &quot;) str_c(x, z, collapse=&quot;&quot;) str_c(x, z, collapse=&quot; &quot;) str_c(x, z, sep = &quot;_&quot;, collapse = &quot; &quot;) str_c(x, z, x, sep=&quot;_&quot;) When we have several vectors of the same lengths in the str_c(), we can use the argument str_c(..., sep = ...) to combine each pair of the corresponding elements in the vectors with the sep as the separator. x &lt;- letters[1:10] y &lt;- c(&quot;suffix1&quot;, &quot;suffix2&quot;) z &lt;- LETTERS[1:10] str_c(x, z, sep = &quot;_&quot;) [1] &quot;a_A&quot; &quot;b_B&quot; &quot;c_C&quot; &quot;d_D&quot; &quot;e_E&quot; &quot;f_F&quot; &quot;g_G&quot; &quot;h_H&quot; &quot;i_I&quot; &quot;j_J&quot; str_c(x, z , sep = &quot;/&quot;) [1] &quot;a/A&quot; &quot;b/B&quot; &quot;c/C&quot; &quot;d/D&quot; &quot;e/E&quot; &quot;f/F&quot; &quot;g/G&quot; &quot;h/H&quot; &quot;i/I&quot; &quot;j/J&quot; When we have only one vector (but it is a multiple-element character vector) in the str_c(), we can use the argument str_c(..., collpase = ...) to collapse the vector into a long single string with the collapse as the delimiter of the original vector elements. The default value is collapse = NULL (i.e., str_c() by default does not collapse the vector.) str_c(x, collapse = &quot;&quot;) [1] &quot;abcdefghij&quot; str_c(x, collapse = &quot; &quot;) [1] &quot;a b c d e f g h i j&quot; str_c(x, collapse = &quot;_&quot;) [1] &quot;a_b_c_d_e_f_g_h_i_j&quot; When we have one or more vectors that are of the same lengths in the str_c(), we can use the argument str_c(..., sep = ...., collpase = ...) to collapse the vectors into a long single string, with the sep as the separator for each pair of elements in the vectors, and the collapse as the delimiter of the paired elements. str_c(x, z, sep=&quot;_&quot;, collapse=&quot; &quot;) [1] &quot;a_A b_B c_C d_D e_E f_F g_G h_H i_I j_J&quot; str_c(x, z, sep=&quot;-&quot;, collapse=&quot;/&quot;) [1] &quot;a-A/b-B/c-C/d-D/e-E/f-F/g-G/h-H/i-I/j-J&quot; str_sub(): extract part of the string by positions str_sub(string = &quot;international&quot;, start = 1, end = 5) [1] &quot;inter&quot; Please note that in R most of the functions are vectorized (i.e., if you apply a vectorized function to a vector, it will perform the same operation on each element of the vector and return a new vector with the results.) ## create a vector set.seed(12) random_fruits &lt;- sample(fruit, 5) ## `fruit` is a default vector random_fruits [1] &quot;purple mangosteen&quot; &quot;loquat&quot; &quot;rambutan&quot; [4] &quot;tangerine&quot; &quot;grape&quot; ## str_sub() all strings in the vector str_sub(random_fruits, start = 1, end = 3) [1] &quot;pur&quot; &quot;loq&quot; &quot;ram&quot; &quot;tan&quot; &quot;gra&quot; 9.3 Regular Expression Grammar Now let’s look at the grammar of regular expressions in more detail. In this section, we will discuss the standard Perl-compatible regular expression syntax. This is by now the most widely used version of regular expressions in most programming languages. To start with, in stringr, there is a very useful function, str_view(STRING, PATTERN), which can show us the match of the pattern in the string in a visually intuitive way. Let’s look at a simple regular expression pattern: \".a\". It is a pattern that matches any two-character sequence where the first character can be any character (represented by the period .) and the second character must be “a”. x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) ## Show only strings with the match str_view(string = x, pattern = &quot;.a&quot;) [2] │ &lt;ba&gt;&lt;na&gt;&lt;na&gt; [3] │ p&lt;ea&gt;r ## Show all strings of the input x str_view_all(string = x, pattern = &quot;.a&quot;) [1] │ apple [2] │ &lt;ba&gt;&lt;na&gt;&lt;na&gt; [3] │ p&lt;ea&gt;r In the above example, the matches of the (regular) pattern are surrounded by &lt; &gt; in the output of str_view(). Also, we know that the pattern (i.e., .a) exists only in the second and third strings of x. You can also use RegExplain addin to test your regular expressions. RegExplain is a very useful tool for the use of regular expressions–RegExplain, which is an RStudio addin. It allows you to: interactively build your regexp and check the output of common string matching functions use the included resources to learn regular expressions consult the interactive help pages This is very useful because we can prepare our regular expressions and use them in the code chunk after we have made sure that they work properly in the RegExplain. You can install the addin using `remotes``: ## Please install `remotes` if you haven&#39;t install.packages(&quot;remotes&quot;) remotes::install_github(&quot;gadenbuie/regexplain&quot;) For basic syntax of regular expressions, I will use this str_view() to show you how the regular pattern works in string-matching. Depending on your purpose, we can retrieve different information from each element of x based on this regular expression: str_detect(string = x, pattern = &quot;.a&quot;) ## Boolean [1] FALSE TRUE TRUE str_match(string = x, pattern = &quot;(.)a&quot;) ## Exact matches (group) [,1] [,2] [1,] NA NA [2,] &quot;ba&quot; &quot;b&quot; [3,] &quot;ea&quot; &quot;e&quot; str_match_all(string = x, pattern = &quot;(.)a&quot;) ## Exact matches all (group) [[1]] [,1] [,2] [[2]] [,1] [,2] [1,] &quot;ba&quot; &quot;b&quot; [2,] &quot;na&quot; &quot;n&quot; [3,] &quot;na&quot; &quot;n&quot; [[3]] [,1] [,2] [1,] &quot;ea&quot; &quot;e&quot; str_extract(string = x, pattern = &quot;.a&quot;) ## Exact matches [1] NA &quot;ba&quot; &quot;ea&quot; str_extract_all(string = x, pattern = &quot;.a&quot;) ## Exact matches all [[1]] character(0) [[2]] [1] &quot;ba&quot; &quot;na&quot; &quot;na&quot; [[3]] [1] &quot;ea&quot; str_subset(string = x, pattern = &quot;.a&quot;) ## Input strings with matches [1] &quot;banana&quot; &quot;pear&quot; str_view() has two useful functions: to see how a pattern matches to print the ambiguous zero-width characters in the string. str1 &lt;- &quot;hello world!&quot; str2 &lt;- &quot;hello world!&quot; str_view(str1) [1] │ hello world! str_view(str2) [1] │ hello{\\u3000}world! With str_view(), we can check whether the string contains any unusual whitespace (i.e., all whitespaces apart from \" \" and \"\\n\"). In the above example, the \"\\u3000\" is a full-width whitespace, often used in Chinese text. 9.3.1 Metacharacters To implement the idea of one-to-many mapping, RegEx defines several metacharacters, which are of special use in regular expressions. Their meanings are NOT the same as their literal counterparts. In RegEx, . is a special character, referring to any character: x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;.a.&quot;) [2] │ &lt;ban&gt;ana [3] │ p&lt;ear&gt; The above regular expression .a. is a pattern that matches any three-character sequence where: the first character can be any character (i.e., .); the second character must be a; the third character can by any character (i.e., .). What if you need to match the period . symbol literally in your string? In this case, you would need to use an escape character \\. In regular expression syntax, the backslash \\ is used to indicate that the following character should be treated literally, rather than as a metacharacter. However, in R, the backslash itself is also a metacharacter. Therefore, to use the backslash as an escape character, you need to double it up, like \\\\. The first backslash tells the R engine that the second backslash should be taken literally, and the second backslash tells the regular expression engine that the following character should be taken literally as a period. x &lt;- c(&quot;apple&quot;, &quot;banana&quot;,&quot;pear&quot;, &quot;orange. And&quot;) str_view(string = x, pattern = &quot;.&quot;) [1] │ &lt;a&gt;&lt;p&gt;&lt;p&gt;&lt;l&gt;&lt;e&gt; [2] │ &lt;b&gt;&lt;a&gt;&lt;n&gt;&lt;a&gt;&lt;n&gt;&lt;a&gt; [3] │ &lt;p&gt;&lt;e&gt;&lt;a&gt;&lt;r&gt; [4] │ &lt;o&gt;&lt;r&gt;&lt;a&gt;&lt;n&gt;&lt;g&gt;&lt;e&gt;&lt;.&gt;&lt; &gt;&lt;A&gt;&lt;n&gt;&lt;d&gt; str_view(string = x, pattern = &quot;\\\\.&quot;) [4] │ orange&lt;.&gt; And In the above example, the . metacharacter matches any character except for a newline character, so it will match all characters in the string. However, in the second example, the \\\\. regular expression matches only the period character, because the backslash is used to escape the period and tell the regular expression engine to treat it literally. So, if you have the following three elements in x. How can you identify the double quotes \" in the strings? my &quot;apple&quot; banana apple peel [1] │ my &lt;&quot;&gt;apple&lt;&quot;&gt; [2] │ banana [3] │ apple peel 9.3.2 Anchors RegEx defines a few metacharacters, which serve as anchors in pattern matching. These anchoring metacharacters allow us to find a match in a particular position of the string (e.g., at the beginning/ending of the string). ^: The start of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) [1] │ &lt;a&gt;pple $: The end of the string x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) [2] │ banan&lt;a&gt; x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;^apple$&quot;) [2] │ &lt;apple&gt; The anchors are evaluated according to the base unit you are matching. In our previous examples, the RegEx pattern is applied to find a match in each element of the vector. The vector includes words. Therefore, the ^ indicates a word-initial position; \\$ indicates a word-final position. If you have a vector of sentences, the ^ would indicate a sentence-initial position; \\$ would indicate a sentence-final position. See below: x &lt;- c(&quot;apple is good&quot;, &quot;banana is better than apple&quot;, &quot;an apple a day keeps the doctor away&quot;) str_view(x, &quot;^apple&quot;) [1] │ &lt;apple&gt; is good str_view(x, &quot;apple$&quot;) [2] │ banana is better than &lt;apple&gt; 9.3.3 Character Set RegEx also defines a few character sets because in our patten-matching, the characters included in a set often show similar behaviors. Common predefined character sets include: \\\\d: a one-character pattern that matches any digit \\\\s: a one-character pattern that matches any whitespace (e.g. space, tab, newline) \\\\w: a one-character pattern that matches any alphanumeric character .: one character pattern that matches any character except the line break x&lt;-c(&quot;apple&quot;,&quot;apple123&quot;,&quot;banana1&quot;) str_view(string = x , pattern = &quot;\\\\d&quot;) [2] │ apple&lt;1&gt;&lt;2&gt;&lt;3&gt; [3] │ banana&lt;1&gt; In pattern-matching, very often you will have cases where one base unit may have more than one match. In the previous example, str_view() prints only the elements with at least one match from x. You can check whether each element of x has a match or not using str_view_all(). str_view_all(string = x , pattern = &quot;\\\\d&quot;) [1] │ apple [2] │ apple&lt;1&gt;&lt;2&gt;&lt;3&gt; [3] │ banana&lt;1&gt; Please compare the two metacharacters, \\\\w and ., and examine their differences in their matches. In particular, which characters are not included in the character set defined by \\\\w? x &lt;- c(&quot;aeiouAEIOU1234_ .\\\\$%-*()&quot;) str_view(string = x, pattern = &quot;\\\\w&quot;, html = T) #compare str_view(string = x, pattern = &quot;.&quot;, html = T) 9.3.4 Alternatives Section 9.3.3 describes a few prefined character sets in RegEx. We can also define our own character set using the square brackets [ ]. And we can use [^...] to define a complementary character set. (Please note that ^ has a different RegEx meaning within [].) [abc]: a one-character pattern that matches a, b, or c (inclusive set) [^abc]: a one-character pattern that matches any character except a, b, or c (exclusive set) x &lt;- c(&quot;grey&quot;, &quot;gray&quot;) str_view(string = x, pattern = &quot;gr[ea]y&quot;) [1] │ &lt;grey&gt; [2] │ &lt;gray&gt; If you know very well which characters you are to match/find, use inclusive character sets, i.e., [...]. If you know very well which characters you do NOT like to match/find, use exclusive character sets, i.e., [^...]. For example, what if we would like to find all non-vowel letters in the words? Instead of coming up with an inclusive character set [...], which includes all possible consonant letters, it would be more efficient if you create an exclusive character set, [^aeiou], which suggests that you need any characters that do not belong to vowels. x &lt;- c(&quot;grey&quot;, &quot;gray&quot;) str_view(string = x, pattern = &quot;[^aeiou]&quot;) [1] │ &lt;g&gt;&lt;r&gt;e&lt;y&gt; [2] │ &lt;g&gt;&lt;r&gt;a&lt;y&gt; 9.3.5 Quantifiers So far, we have mostly focused on patterns that refer to a single-character sequence, such as \\\\w, [^aeiou], [aeiou]. These patterns match any one-character sequence, as long as the character is included in the set defined by the regular expression. However, in many cases, we do not know the exact length of the match beforehand. The length of the match can vary, depending on the input data. For example, if we want to find words that start with the letter “a”, we need to create a regular expression that can match strings of variable lengths. To specify the number of occurrences of a particular unit in the regular expression (i.e., the character preceding the quantifier), we can use quantifiers. Quantifiers allow us to specify how many times a particular unit (i.e., the character preceding the quantifier) should occur in the input string. Some examples of quantifiers include: ?: 0 or 1 occurrence of the preceding character +: 1 or more occurrences of the preceding character *: 0 or more occurrences of the preceding character x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) [1] │ Roman numerals: MD&lt;CC&gt;&lt;C&gt;LXXXVIII str_view(x, &quot;X+&quot;) [1] │ Roman numerals: MDCCCL&lt;XXX&gt;VIII We can specify an exact range of number of occurrences using the curly brackets { , }: {n}: exactly n occurrences of the preceding character {n,}: n or more occurrences of the preceding character {,m}: at most m occurrences of the preceding character {n,m}: between n and m occurrences of the preceding character x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;C{2}&quot;) [1] │ Roman numerals: MD&lt;CC&gt;CLXXXVIII str_view(x, &quot;C{2,}&quot;) [1] │ Roman numerals: MD&lt;CCC&gt;LXXXVIII str_view(x, &quot;C{2,3}&quot;) [1] │ Roman numerals: MD&lt;CCC&gt;LXXXVIII When we use the quantifiers, be very careful about the scope of the quantifier. By default, the quantifier takes only its preceding character as the scope. If you need to specify the number of occurrences for a group of characters or a specific sub-pattern, you need to put the pattern in a group (...) and then put your quantifier right after the group. x &lt;- &quot;aaabbbababcdf&quot; str_view(x, &quot;ab{2,}&quot;) # the scope of the quantifier is `b` [1] │ aa&lt;abbb&gt;ababcdf str_view(x, &quot;(ab){2,}&quot;) # the scope of the quantifier is `ab` [1] │ aaabbb&lt;abab&gt;cdf 9.3.6 Greedy vs. Non-greedy match The earlier example, as repeated here, shows you that when the RegEx locates the pattern in the string, it prefers to find a longest match that satisfies the pattern. x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;C{2,}&quot;) [1] │ Roman numerals: MD&lt;CCC&gt;LXXXVIII In the above example, the substring CC should satisfy the RegEx C{2,} already but the RegEx returns CCC as the first match. This is the idea of greedy match. In other words, by default, when we apply quantifiers in our regular expressions, the RegEx engine assumes a greedy match (i.e., to find a longest possible match). To cancel this default greedy match, we can add ? after the quantifiers. It applies to all quantifiers we’ve looked at (e.g., ?, +, *). Before running the following code chunk, please predict their respective outputs. x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CL?&quot;) # find longest match str_view(x, &quot;CL??&quot;) # find shortest match str_view(x, &quot;CLX+&quot;) # find longest match str_view(x, &quot;CLX+?&quot;) # find shortest match str_view(x, &quot;CLX*&quot;) # find longest match str_view(x, &quot;CLX*?&quot;) # find shortest match 9.3.7 Group and Back-reference # `fruit` is a preloaded vector from `stringr` x &lt;- fruit %&gt;% head(10) x [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; Now let’s look at a more complicated example.What if we want to extract English fruit words which have a letter repeating twice in a row (e.g, apple, bell pepper). The main problem is: we don’t know which letters are going to be repeated in the word. How should we create our regular expression? Can we use the metacharacter . plus a quantifier {2} to match any possible alphanumeric character that repeats twice, as below? str_view(x, &quot;.{2}&quot;) [1] │ &lt;ap&gt;&lt;pl&gt;e [2] │ &lt;ap&gt;&lt;ri&gt;&lt;co&gt;t [3] │ &lt;av&gt;&lt;oc&gt;&lt;ad&gt;o [4] │ &lt;ba&gt;&lt;na&gt;&lt;na&gt; [5] │ &lt;be&gt;&lt;ll&gt;&lt; p&gt;&lt;ep&gt;&lt;pe&gt;r [6] │ &lt;bi&gt;&lt;lb&gt;&lt;er&gt;&lt;ry&gt; [7] │ &lt;bl&gt;&lt;ac&gt;&lt;kb&gt;&lt;er&gt;&lt;ry&gt; [8] │ &lt;bl&gt;&lt;ac&gt;&lt;kc&gt;&lt;ur&gt;&lt;ra&gt;&lt;nt&gt; [9] │ &lt;bl&gt;&lt;oo&gt;&lt;d &gt;&lt;or&gt;&lt;an&gt;&lt;ge&gt; [10] │ &lt;bl&gt;&lt;ue&gt;&lt;be&gt;&lt;rr&gt;y The results are not what we have expected. The above pattern would only give us the first two characters of each word. The quantifier {2} in the regular expression only indicates the number of occurrences (i.e., twice), but it says nothing about the requirement that the two letters have to be exactly the same. This is a time when we need to introduce the concept of back-reference. The trick is that when you use . to match any character, the quantifier does not help much as any character that repeats would fit the pattern. We need a new strategy to ask the RegEx engine to remember the previously matched character and quantify the number of occurrences of the remembered character: str_view(x, &quot;(.)\\\\1&quot;) [1] │ a&lt;pp&gt;le [5] │ be&lt;ll&gt; pe&lt;pp&gt;er [6] │ bilbe&lt;rr&gt;y [7] │ blackbe&lt;rr&gt;y [8] │ blackcu&lt;rr&gt;ant [9] │ bl&lt;oo&gt;d orange [10] │ bluebe&lt;rr&gt;y The regular expression can be conceptualized as follows: .: matches any character (.): the parenthesis would label the matched as a group. Internally, the RegEx engine numbers all groups serially from left to right \\\\1: back-reference the first group. The same logic applies to the second group of the regular expression (i.e., \\\\2) So (.)\\\\1 means that when the engine matches a character (i.e., . = any character), there has to be another same character following the former. Exercise 9.1 With the same set of fruit names in x, how do we match fruits with a abab pattern, such as “banana”? [4] │ b&lt;anan&gt;a Exercise 9.2 With the same set of fruit names in x, how do we match fruits with a abba pattern, such as “pepper”? [5] │ bell p&lt;eppe&gt;r Exercise 9.3 With the same set of fruit names in x, please find fruit names which has at least one letter that is the same as their initial letters [3] │ &lt;avoca&gt;do [6] │ &lt;bilb&gt;erry [7] │ &lt;blackb&gt;erry [10] │ &lt;blueb&gt;erry 9.4 Pattern Matching This section will show you examples of how we can make use of regular expresions to process strings. In stringr, there are a list of verbs that we use with regular expressions: In the following example, we use the upper-casing STRING to refer to the character vector to which the PATTERN (i.e., regular expression) is matched. 9.4.1 str_detect() str_detect(STRING, PATTERN): Determine which strings in STRING has a match of the PATTERN (binary) str_detect(x, &quot;e$&quot;) [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE 9.4.2 str_subset() str_subset(STRING, PATTERN): Subset the STRING by identifying elements that have either a full or partial match of the PATTERN (character) str_subset(x, &quot;e$&quot;) [1] &quot;apple&quot; &quot;blood orange&quot; 9.4.3 str_extract() str_extract(STRING, PATTERN): Extract the content of the matches of the strings in STRING (character) str_extract(x, &quot;e$&quot;) [1] &quot;e&quot; NA NA NA NA NA NA NA &quot;e&quot; NA Also, please note that str_extract() only extracts the first match of the string. To extract all matches from the strings: str_extract(x, &quot;[aeiou]&quot;) # find only the first match [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;a&quot; &quot;a&quot; &quot;o&quot; &quot;u&quot; str_extract_all(x, &quot;[aeiou]&quot;) # find all matches in each string [[1]] [1] &quot;a&quot; &quot;e&quot; [[2]] [1] &quot;a&quot; &quot;i&quot; &quot;o&quot; [[3]] [1] &quot;a&quot; &quot;o&quot; &quot;a&quot; &quot;o&quot; [[4]] [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; [[5]] [1] &quot;e&quot; &quot;e&quot; &quot;e&quot; [[6]] [1] &quot;i&quot; &quot;e&quot; [[7]] [1] &quot;a&quot; &quot;e&quot; [[8]] [1] &quot;a&quot; &quot;u&quot; &quot;a&quot; [[9]] [1] &quot;o&quot; &quot;o&quot; &quot;o&quot; &quot;a&quot; &quot;e&quot; [[10]] [1] &quot;u&quot; &quot;e&quot; &quot;e&quot; 9.4.4 str_match() str_match(STRING, PATTERN): Extract the content of the matches of the strings in STRING as well as each capture group (character) in the regular expression. str_match(x, &quot;(bl)([aeiou]+)&quot;) [,1] [,2] [,3] [1,] NA NA NA [2,] NA NA NA [3,] NA NA NA [4,] NA NA NA [5,] NA NA NA [6,] NA NA NA [7,] &quot;bla&quot; &quot;bl&quot; &quot;a&quot; [8,] &quot;bla&quot; &quot;bl&quot; &quot;a&quot; [9,] &quot;bloo&quot; &quot;bl&quot; &quot;oo&quot; [10,] &quot;blue&quot; &quot;bl&quot; &quot;ue&quot; For each match, we will get not only the full match, but also the capture groups substrings specified in the parentheses in the regular expression. Each group (i.e., parenthesis) in the regular expression will have a partial match in the str_match() results. We can compare the results from str_extract(): str_extract(x, &quot;(bl)([aeiou]+)&quot;) [1] NA NA NA NA NA NA &quot;bla&quot; &quot;bla&quot; &quot;bloo&quot; &quot;blue&quot; Exercise 9.4 How do you use str_match() to find out all the c+Vowel structures, and at the same time identify which vowels follow the letter c? [2] │ apri&lt;co&gt;t [3] │ avo&lt;ca&gt;do [8] │ black&lt;cu&gt;rrant [,1] [,2] [1,] NA NA [2,] &quot;co&quot; &quot;o&quot; [3,] &quot;ca&quot; &quot;a&quot; [4,] NA NA [5,] NA NA [6,] NA NA [7,] NA NA [8,] &quot;cu&quot; &quot;u&quot; [9,] NA NA [10,] NA NA Exercise 9.5 Please use str_match() to find out all fruit names whose initial letter is a consonant letter (i.e., not any of a, e, i, o, u) and gets repeated in the remaining part of the word. The following is a sample output from str_match(). Column 1 refers to the match; Column 2 refers to the initial letter; Column 3 refers to the letters between the initial letter and the repeated same letter; Column 4 refers to the repeated letter, which is the same as the initial letter. [,1] [,2] [,3] [,4] [1,] NA NA NA NA [2,] NA NA NA NA [3,] NA NA NA NA [4,] NA NA NA NA [5,] NA NA NA NA [6,] &quot;bilb&quot; &quot;b&quot; &quot;il&quot; &quot;b&quot; [7,] &quot;blackb&quot; &quot;b&quot; &quot;lack&quot; &quot;b&quot; [8,] NA NA NA NA [9,] NA NA NA NA [10,] &quot;blueb&quot; &quot;b&quot; &quot;lue&quot; &quot;b&quot; 9.4.5 str_replace() str_replace(STRING, PATTERN, REPLACEMENT): Replace matches of the PATTERN with REPLACEMENT in STRING. str_replace(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) [1] &quot;Vpple&quot; &quot;Vpricot&quot; &quot;Vvocado&quot; &quot;bVnana&quot; &quot;bVll pepper&quot; [6] &quot;bVlberry&quot; &quot;blVckberry&quot; &quot;blVckcurrant&quot; &quot;blVod orange&quot; &quot;blVeberry&quot; It should be noted that str_replace() only replaces the first match of each string. str_replace_all(string = x, pattern = &quot;[aeiou]&quot;, replacement = &quot;V&quot;) [1] &quot;VpplV&quot; &quot;VprVcVt&quot; &quot;VvVcVdV&quot; &quot;bVnVnV&quot; &quot;bVll pVppVr&quot; [6] &quot;bVlbVrry&quot; &quot;blVckbVrry&quot; &quot;blVckcVrrVnt&quot; &quot;blVVd VrVngV&quot; &quot;blVVbVrry&quot; 9.4.6 str_split() str_split(STRING, PATTERN): Split a string in STRING based on a PATTERN (character) x &lt;- sentences %&gt;% head(5) x [1] &quot;The birch canoe slid on the smooth planks.&quot; [2] &quot;Glue the sheet to the dark blue background.&quot; [3] &quot;It&#39;s easy to tell the depth of a well.&quot; [4] &quot;These days a chicken leg is a rare dish.&quot; [5] &quot;Rice is often served in round bowls.&quot; str_split(string = x, pattern = &quot;\\\\s&quot;) [[1]] [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; [8] &quot;planks.&quot; [[2]] [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; [[3]] [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; [[4]] [1] &quot;These&quot; &quot;days&quot; &quot;a&quot; &quot;chicken&quot; &quot;leg&quot; &quot;is&quot; &quot;a&quot; [8] &quot;rare&quot; &quot;dish.&quot; [[5]] [1] &quot;Rice&quot; &quot;is&quot; &quot;often&quot; &quot;served&quot; &quot;in&quot; &quot;round&quot; &quot;bowls.&quot; Please note that the return of str_split() is a list. fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;[^\\\\w]+&quot;) [[1]] [1] &quot;Name&quot; &quot;Hadley&quot; [[2]] [1] &quot;Country&quot; &quot;NZ&quot; [[3]] [1] &quot;Age&quot; &quot;35&quot; # To get a simpler structure in return: fields %&gt;% str_split(&quot;[^\\\\w]+&quot;, simplify = T) [,1] [,2] [1,] &quot;Name&quot; &quot;Hadley&quot; [2,] &quot;Country&quot; &quot;NZ&quot; [3,] &quot;Age&quot; &quot;35&quot; A list is considered a more complex structure compared to a data.frame because a list element can be any kind of data structures, including a complex list as well. Exercise 9.6 Convert American dates American.dates to British dates using str_replace_all(). Please note that in your output, you need to preserve the original delimiters for each date. American.dates &lt;- c(&quot;7/31/1976&quot;, &quot;02.15.1970&quot;, &quot;11-31-1986&quot;, &quot;04/01.2020&quot;) [1] &quot;31/7/1976&quot; &quot;15.02.1970&quot; &quot;31-11-1986&quot; &quot;01/04.2020&quot; Exercise 9.7 Please use the default sentences vector as your input and find all patterns of “any BE verbs + words ending with ‘en’ or ‘ed’”. Please extract these matches from the sentences and your result should be a vector of these matches, as shown below. sentences[1:5] [1] &quot;The birch canoe slid on the smooth planks.&quot; [2] &quot;Glue the sheet to the dark blue background.&quot; [3] &quot;It&#39;s easy to tell the depth of a well.&quot; [4] &quot;These days a chicken leg is a rare dish.&quot; [5] &quot;Rice is often served in round bowls.&quot; length(sentences) [1] 720 [1] &quot;is often&quot; &quot;were fed&quot; &quot;is used&quot; &quot;was cooked&quot; [5] &quot;was seized&quot; &quot;is used&quot; &quot;was spattered&quot; &quot;is red&quot; [9] &quot;was fired&quot; &quot;is ten&quot; &quot;is used&quot; &quot;are pushed&quot; [13] &quot;are men&quot; &quot;are used&quot; &quot;were hired&quot; &quot;was covered&quot; [17] &quot;were lined&quot; &quot;was ten&quot; &quot;is used&quot; &quot;are paved&quot; [21] &quot;is carved&quot; &quot;were led&quot; &quot;is needed&quot; &quot;were painted&quot; [25] &quot;were mailed&quot; &quot;was pressed&quot; &quot;is seen&quot; &quot;was packed&quot; [29] &quot;was barred&quot; &quot;was crowded&quot; &quot;was carved&quot; &quot;was drilled&quot; [33] &quot;was hidden&quot; &quot;was seen&quot; &quot;were pierced&quot; &quot;are jangled&quot; [37] &quot;is tinged&quot; &quot;were stamped&quot; &quot;was jammed&quot; &quot;was robbed&quot; [1] │ Rice &lt;is often&gt; served in round bowls. [2] │ The hogs &lt;were fed&gt; chopped corn and garbage. [3] │ A rod &lt;is used&gt; to catch pink salmon. [4] │ The meal &lt;was cooked&gt; before the bell rang. [5] │ The walled town &lt;was seized&gt; without a fight. [6] │ A Tusk &lt;is used&gt; to make costly gifts. [7] │ Mud &lt;was spattered&gt; on the front of his white shirt. [8] │ The sofa cushion &lt;is red&gt; and of light weight. [9] │ The new girl &lt;was fired&gt; today at noon. [10] │ There the flood mark &lt;is ten&gt; inches. [11] │ The lure &lt;is used&gt; to catch trout and flounder. [12] │ They &lt;are pushed&gt; back each time they attack. [13] │ They &lt;are men&gt; who walk the middle of the road. [14] │ Fruit flavors &lt;are used&gt; in fizz drinks. [15] │ Nine men &lt;were hired&gt; to dig the ruins. [16] │ The old pan &lt;was covered&gt; with hard fudge. [17] │ The store walls &lt;were lined&gt; with colored frocks. [18] │ The purple tie &lt;was ten&gt; years old. [19] │ Code &lt;is used&gt; when secrets are sent. [20] │ Roads &lt;are paved&gt; with sticky tar. ... and 20 more Exercise 9.8 Please create a regular expression to extract all word tokens of the sentences from the vector x, which is defined as follows. x &lt;- c(&quot;It&#39;s a three-legged char.&quot;, &quot;The book (you read) was quite boring!&quot;) The returned object is a list, including the word vectors of each text in x. [[1]] [1] &quot;It&#39;s&quot; &quot;a&quot; &quot;three-legged&quot; &quot;char&quot; [[2]] [1] &quot;The&quot; &quot;book&quot; &quot;you&quot; &quot;read&quot; &quot;was&quot; &quot;quite&quot; &quot;boring&quot; Exercise 9.9 In stringr::sentences, there are 720 English sentences. Please create a regular expression to subset sentences with at least one word containing a hyphen. There are TWO sentences that satisfy the condition. [1] &quot;A zestful food is the hot-cross bun.&quot; Exercise 9.10 Please extract all the word tokens that are tagged as NOUNS from the following text using a self-defined regular expressions. NOUNS are defined as words with parts-of-speech tags starting with N. x &lt;- &quot;中央(Nc) 流行(VH) 疫情(Na) 指揮(VC) 中心(Nc) 醫療(VC) 應變組(Nc) 副組長(Na) 羅一鈞(Nb) 今天(Nd) 說明(VE) ，(COMMACATEGORY) 截至(P) 12月(Nd) 1日(Nd) 全球(Nc) 累計(VJ) 至少(Da) 27(Neu) 國(Nc) 、(PAUSECATEGORY) 共有(VJ) 370(Neu) 例(Na) 確診(VA) 感染(VJ) Omicron(FW) 變異株(Na) ，(COMMACATEGORY) 多(D) 來自(VJ) 南非(Nc) 或(Caa) 具(VJ) 非洲(Nc) 國家(Na) 旅遊史(Na) 。(PERIODCATEGORY)&quot; [[1]] [1] &quot;中央(Nc)&quot; &quot;疫情(Na)&quot; &quot;中心(Nc)&quot; &quot;應變組(Nc)&quot; &quot;副組長(Na)&quot; [6] &quot;羅一鈞(Nb)&quot; &quot;今天(Nd)&quot; &quot;12月(Nd)&quot; &quot;1日(Nd)&quot; &quot;全球(Nc)&quot; [11] &quot;27(Neu)&quot; &quot;國(Nc)&quot; &quot;370(Neu)&quot; &quot;例(Na)&quot; &quot;變異株(Na)&quot; [16] &quot;南非(Nc)&quot; &quot;非洲(Nc)&quot; &quot;國家(Na)&quot; &quot;旅遊史(Na)&quot; Exercise 9.11 Please use the same Chinese texts as the input. Please use str_replace_all() along with a self-defined regular expression to remove all part-of-speech tags in the original texts. x &lt;- &quot;中央(Nc) 流行(VH) 疫情(Na) 指揮(VC) 中心(Nc) 醫療(VC) 應變組(Nc) 副組長(Na) 羅一鈞(Nb) 今天(Nd) 說明(VE) ，(COMMACATEGORY) 截至(P) 12月(Nd) 1日(Nd) 全球(Nc) 累計(VJ) 至少(Da) 27(Neu) 國(Nc) 、(PAUSECATEGORY) 共有(VJ) 370(Neu) 例(Na) 確診(VA) 感染(VJ) Omicron(FW) 變異株(Na) ，(COMMACATEGORY) 多(D) 來自(VJ) 南非(Nc) 或(Caa) 具(VJ) 非洲(Nc) 國家(Na) 旅遊史(Na) 。(PERIODCATEGORY)&quot; [1] &quot;中央 流行 疫情 指揮 中心 醫療 應變組 副組長 羅一鈞 今天 說明 ， 截至 12月 1日 全球 累計 至少 27 國 、 共有 370 例 確診 感染 Omicron 變異株 ， 多 來自 南非 或 具 非洲 國家 旅遊史 。&quot; 9.5 Advanced Pattern Matching: Look Ahead and Behind The regular expressions we have introduced so far will consume the input strings when doing the pattern matching. I would like to illustrate this idea with the following simple example. If we want to find Windows, but only when it is followed by \"95, 98, NT, 2000\", how should we write our RegEx pattern? win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;WindowsNT&quot;, &quot;Windows7&quot;, &quot;Windows10&quot;) str_view(win, &quot;Windows(95|98|NT|2000)&quot;) [1] │ &lt;Windows2000&gt; [3] │ &lt;WindowsNT&gt; The pattern seems OK because we did find the Windows2000 that satisfies our RegEx. But what if you would like to replace the word “Windows” with “OldSystem” but only when “Windows” is followed by \"95, 98, NT, 2000\"? str_replace(win, pattern = &quot;Windows(95|98|NT|2000)&quot;, replacement = &quot;OldSystem&quot;) [1] &quot;OldSystem&quot; &quot;Windows&quot; &quot;OldSystem&quot; &quot;Windows7&quot; &quot;Windows10&quot; Now you see the problem? Not only “Windows” was replaced, but also the entire string. This is not what we expect to get. Instead, we would expect something like: [1] &quot;OldSystem2000&quot; &quot;Windows&quot; &quot;OldSystemNT&quot; &quot;Windows7&quot; [5] &quot;Windows10&quot; That is why we need lookahead function in RegEx. (?=...): Positive lookahead—extract a match only when ... (the conditional pattern) is on the right (?!...): Negative lookahead—extract a match only when ... (the conditional pattern) is NOT on the right str_view(win, &quot;Windows(?=95|98|NT|2000)&quot;) [1] │ &lt;Windows&gt;2000 [3] │ &lt;Windows&gt;NT In the above regular expression, the () after Windows is a lookahead condition for matching. The strings of “2000” and “NT” in the condition are NOT consumed. The RegEx engine looks ahead the following few characters first to check the patterns. Most importantly, after it finds a match, the lookahead characters will still be available as the input of the next pattern-matching. We can make use of this lookahead to do the string replacement: str_replace(string = win, pattern = &quot;Windows(?=95|98|NT|2000)&quot;, replacement = &quot;OldSystem&quot;) [1] &quot;OldSystem2000&quot; &quot;Windows&quot; &quot;OldSystemNT&quot; &quot;Windows7&quot; [5] &quot;Windows10&quot; Moreover, we can create a negative lookahead as well: str_view(win, &quot;Windows(?!7|10)&quot;) [1] │ &lt;Windows&gt;2000 [2] │ &lt;Windows&gt; [3] │ &lt;Windows&gt;NT str_replace(string = win, pattern = &quot;Windows(?!7|10)&quot;, replacement = &quot;NewSystem&quot;) [1] &quot;NewSystem2000&quot; &quot;NewSystem&quot; &quot;NewSystemNT&quot; &quot;Windows7&quot; [5] &quot;Windows10&quot; In addition to lookahead, we can also specify look-behind conditions: Look-behind conditions: (?&lt;=...): Positive look-behind—extract a match only when it is preceded by ... (conditional pattern). (?&lt;!...): Negative look-behind—extract a match only when it is NOT preceded by ... (conditional pattern). win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;NTWindows&quot;, &quot;7Windows&quot;, &quot;10Windows&quot;) str_replace_all(win, &quot;(?&lt;=95|98|NT|2000)Windows&quot;, &quot;OldSystem&quot;) [1] &quot;2000OldSystem&quot; &quot;Windows&quot; &quot;NTOldSystem&quot; &quot;7Windows&quot; [5] &quot;10Windows&quot; win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;NTWindows&quot;, &quot;7Windows&quot;, &quot;10Windows&quot;) str_replace_all(win, &quot;(?&lt;!95|98|NT|2000)Windows&quot;, &quot;NewSystem&quot;) [1] &quot;2000Windows&quot; &quot;NewSystem&quot; &quot;NTWindows&quot; &quot;7NewSystem&quot; &quot;10NewSystem&quot; Exercise 9.12 Please use the first ten words in the fruit vector for this exercise. Based on the fruit vocabulary, can you identify all the a that is followed by STOP_SOUNDS and replace them with “V”? STOP_SOUNDS refer to p, t, k, b, d, g Hint: str_replace_all() dataset fruit[1:10] [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; target matches [1] │ &lt;a&gt;pple [2] │ &lt;a&gt;pricot [3] │ avoc&lt;a&gt;do [4] │ banana [5] │ bell pepper [6] │ bilberry [7] │ blackberry [8] │ blackcurrant [9] │ blood orange [10] │ blueberry your result [1] &quot;Vpple&quot; &quot;Vpricot&quot; &quot;avocVdo&quot; &quot;banana&quot; &quot;bell pepper&quot; [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; Exercise 9.13 Similar to the previous example, Exercise 9.12, also based on the first ten words in fruit, please identify all the vowels that are both followed and preceded by STOP_SOUNDS and replace them with “V”. Vowels are defined as letters including a, e, i, o,and u, dataset fruit[1:10] [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pepper&quot; [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; target matches [1] │ apple [2] │ apricot [3] │ avocado [4] │ banana [5] │ bell p&lt;e&gt;pper [6] │ bilberry [7] │ blackberry [8] │ blackcurrant [9] │ blood orange [10] │ blueberry your result [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;banana&quot; &quot;bell pVpper&quot; [6] &quot;bilberry&quot; &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; &quot;blueberry&quot; 9.6 More Practices This section will show you more examples of the RegEx applications. Most importantly, I will specifically point out the capacities and potentials of regular expressions in helping us manipulating the datasets. In Chapter 8, we have talked about important ways in which we can manipulate our data as a data.frame/tibble. Please refer to the Chapter 8 for a review of the important verbs in dplyr. Exercise 9.14 In the library tidyr, there are two very useful functions for data manipulation: separate(), extract() and unnest(). Please read the documentations of these two functions and run the examples provided in the documentation to make sure that you understand how they work. 9.6.1 Case 1 If we have a data frame like dt below, how do we extract only the numbers of the weeks from the y column, and add this information to a new column, z? Original data frame: dt &lt;- tibble( x = 1:4, y = c(&quot;wk 3&quot;, &quot;week-1&quot;, &quot;7&quot;, &quot;w#9&quot;) ) dt Expected data frame: Hints: We need to know how to extract numbers from the values in y columns. We need to create a new column for the data frame dt. Exercise 9.15 If we have a data frame like dt below, how do we extract all the vowels of the words in the WORD column and create two additional columns: Because a word may have several vowels, create a new column, which shows all the vowels in the word by combining them into a long string with the delimiter “_” Create another column for the number of vowels for each word Vowels are defined as [aeiou]. dt &lt;- tibble( WORD = fruit[1:10] ) dt 9.6.2 Case 2 How to separate the English and Chinese strings in x column and create two new columns, EN, CH? Original data frame: tb &lt;- tibble(x = c(&quot;I我&quot;, &quot;love愛&quot;, &quot;you你&quot;)) tb Expected data frame: Hints: Please check tidyr::extract(), which is a function to split a column into several columns using regular expression. We need to know how to extract alphanumeric (or non-alphanumeric) characters from the values of x column. Exercise 9.16 How to extract the numbers and split the numbers into START and END? Original data frame: df &lt;- tibble(x = c(&quot;1-12周&quot;, &quot;1-10周&quot;, &quot;5-12周&quot;)) df Expected data frame: 9.6.3 Case 3 How to extract all the individual digits of each token and compute the sum of the numbers and save the results in a new column SUM? Original data frame: df &lt;- tibble( x = c(&quot;1234&quot;, &quot;B246&quot;, &quot;217C&quot;, &quot;2357f&quot;, &quot;21WD4&quot;) ) df Expected data frame: Hints: We need to know how to extract all numbers from the values in x. We need to know how to compute the sum of the numbers extracted from each value in x. We need to add these sums to the new column. Exercise 9.17 How to extract all the numbers that follow a upper-casing letter? For example, 34 after W; 217 after B? Original data frame: df &lt;- tibble( x = c(&quot;12W34&quot;, &quot;AB2C46&quot;, &quot;B217C&quot;, &quot;akTs6df&quot;, &quot;21WD4&quot;) ) df Expected data frame: Exercise 9.18 Based on Exercise 9.17, can you add another column to the resulting data frame, which records the upper-casing letter that the numbers follow for each row? 9.7 Case Study: Chinese Four-Character Idioms Many studies have shown that Chinese makes use of large proportion of four-character idioms (四字成語) in discourse. Let’s have an exploratory analysis of four-character idioms in Chinese. 9.7.1 Dictionary Entries In our demo_data directory, there is a file demo_data/dict-ch-idiom.txt, which includes a list of four-character idioms in Chinese. These idioms are collected from 搜狗輸入法詞庫 and the original file formats (.scel) have been combined, removed of duplicate cases, and converted to a more machine-readable format, i.e., .txt. Let’s first load the idioms dataset in R. all_idioms &lt;- readLines(con = &quot;demo_data/dict-ch-idiom.txt&quot;,encoding = &quot;UTF-8&quot;) head(all_idioms) [1] &quot;阿保之功&quot; &quot;阿保之勞&quot; &quot;阿鼻地獄&quot; &quot;阿鼻叫喚&quot; &quot;阿斗太子&quot; &quot;阿芙蓉膏&quot; tail(all_idioms) [1] &quot;罪無可逭&quot; &quot;罪人不帑&quot; &quot;作纛旗兒&quot; &quot;坐纛旂兒&quot; &quot;作姦犯科&quot; &quot;作育英才&quot; length(all_idioms) [1] 56536 In order to make use of the tidy structure in R, we convert the data into a tibble (or a data.frame): idiom &lt;- tibble(string = all_idioms) idiom %&gt;% head 9.7.2 Case Study: X來Y去 We can create a regular expression pattern to extract all idioms with the format of X來Ｙ去: idiom %&gt;% filter(str_detect(string, &quot;.來.去&quot;)) To analyze the meaning of this constructional schema, we may need to extract the X and Y in the schema: idiom_laiqu &lt;-idiom %&gt;% filter(str_detect(string, &quot;.來.去&quot;)) %&gt;% mutate(pattern = str_replace(string, &quot;(.)來(.)去&quot;, &quot;\\\\1_\\\\2&quot;)) %&gt;% separate(pattern, into = c(&quot;w1&quot;, &quot;w2&quot;), sep = &quot;_&quot;) idiom_laiqu # # version 2 # require(tidyr) # idiom %&gt;% # filter(str_detect(string, &quot;.來.去&quot;)) %&gt;% # mutate(string2 = string) %&gt;% # extract(col=&quot;string2&quot;, # into=c(&quot;w1&quot;,&quot;w2&quot;), # regex = &quot;(.)來(.)去&quot;) One empirical question is how many of these idioms are of the pattern W1 = W2 (e.g., 想來想去, 直來直去) and how many are of the pattern W1 != W2 (e.g., 說來道去, 朝來暮去): # Create `structure` column idiom_laiqu_2 &lt;- idiom_laiqu %&gt;% mutate(structure = ifelse(w1==w2, &quot;XX&quot;,&quot;XY&quot;)) idiom_laiqu_2 # Count `structure` frequecnies idiom_laiqu_count &lt;- idiom_laiqu_2 %&gt;% count(structure) idiom_laiqu_count # Create barplots idiom_laiqu_count %&gt;% ggplot(aes(structure, n, fill = structure)) + geom_col() ########################## ### Another alterantive### ########################## # idiom_laiqu %&gt;% # mutate(structure = ifelse(w1==w2, &quot;XX&quot;,&quot;XY&quot;)) %&gt;% # count(structure) %&gt;% # ggplot(aes(structure, n, fill = structure)) + # geom_col() Exercise 9.19 Please use same dataset idiom (loaded from demo_data/dict-ch-idiom.txt) and extract all the idioms that fall into the schema of 一X一Y. idiom &lt;- tibble(string = readLines(&quot;demo_data/dict-ch-idiom.txt&quot;)) Exercise 9.20 Also with the idiom as our data source, now if we are interested in all idioms that have duplicated characters in them, with schemas like either _A_A or A_A_, where A is a fixed character. How can we extract all idioms of these two types from idiom? Also, please visualize the distribution of the two idiom types using a bar plot. Sample answers have been provided below. Idioms with duplicate characters in them Type Distribution Exercise 9.21 Following Exercise 9.20, for each type of the idioms (i.e., “A_A_” or “_A_A”), please provide their respective proportions of W1 = W2 vs. W1 != W2, where W1 and W2 refer to the words filled in the variable slots of the idiomatic templates. The following table is a random sample of each idiom type (5 tokens for each type) (Not sure if you can get the exact sample results with set.seed(123)): "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
